<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UofT Cognitive Synthesis Engine - Super-Brain Strict RAG</title>
    <style>
        :root {
            --primary: #002A5C;
            --primary-light: #003d82;
            --secondary: #FFE498;
            --accent: #008BB0;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .brain-badge {
            background: var(--secondary);
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            border-radius: 999px;
            padding: 0.25rem 0.7rem;
        }

        .header-btn {
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: white;
            padding: 0.5rem 0.85rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .main-container {
            flex: 1;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            display: flex;
            gap: 1rem;
        }

        .chat-section {
            flex: 1;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            padding: 1rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.16);
        }

        .chat-header h2 {
            font-size: 1rem;
            margin-bottom: 0.2rem;
        }

        .chat-header p {
            font-size: 0.78rem;
            opacity: 0.9;
        }

        .chat-messages {
            flex: 1;
            min-height: 420px;
            max-height: calc(100vh - 320px);
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .message {
            max-width: 88%;
            border-radius: 12px;
            padding: 0.85rem 1rem;
            line-height: 1.55;
            font-size: 0.94rem;
        }

        .message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            align-self: flex-start;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .message.system {
            align-self: center;
            max-width: 100%;
            background: #fff7d6;
            border: 1px solid #f6df9b;
            color: #4d3b00;
            font-size: 0.86rem;
        }

        .message.assistant p { margin-bottom: 0.55rem; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant ul, .message.assistant ol { margin: 0.4rem 0 0.7rem 1.25rem; }
        .message.assistant code {
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            padding: 0.05rem 0.3rem;
            font-size: 0.9em;
        }

        .chat-input-container {
            border-top: 1px solid var(--border);
            background: #f9fbfd;
            padding: 0.9rem 1rem;
        }

        .attachment-preview {
            display: none;
            align-items: center;
            gap: 0.75rem;
            background: #eff9ff;
            border: 1px solid #cbeeff;
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            margin-bottom: 0.75rem;
        }

        .attachment-preview.active { display: flex; }
        .attachment-preview-name { font-size: 0.9rem; font-weight: 600; }
        .attachment-preview-meta { font-size: 0.76rem; color: var(--text-muted); }
        .attachment-preview-remove {
            margin-left: auto;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 0.6rem;
        }

        .attach-btn {
            width: 42px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            color: var(--text-muted);
            cursor: pointer;
        }

        .chat-input {
            flex: 1;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.94rem;
            resize: none;
            font-family: inherit;
            min-height: 48px;
        }

        .send-btn {
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.1rem;
            font-weight: 600;
            color: white;
            background: var(--primary);
            cursor: pointer;
        }

        .send-btn:disabled { opacity: 0.65; cursor: not-allowed; }

        .synthesis-indicator {
            display: none;
            margin: 0.8rem 1rem 0;
            padding: 0.7rem 0.9rem;
            border-radius: 8px;
            background: #eaf7fb;
            color: #0b5d72;
            font-size: 0.85rem;
            align-items: center;
            gap: 0.55rem;
        }
        .synthesis-indicator.active { display: flex; }
        .pulse {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--accent);
            animation: pulse 1.4s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.25); opacity: 0.55; }
        }

        .citation {
            display: inline-flex;
            align-items: center;
            background: var(--accent);
            color: white;
            border-radius: 5px;
            padding: 0.12rem 0.45rem;
            font-size: 0.73rem;
            margin: 0 0.1rem;
            cursor: pointer;
        }

        .attachment-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            opacity: 0.9;
            background: rgba(255,255,255,0.16);
            border-radius: 4px;
            padding: 0.2rem 0.45rem;
            margin-bottom: 0.4rem;
        }

        .corpus-sidebar {
            width: 320px;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .corpus-header {
            border-bottom: 1px solid var(--border);
            padding: 0.9rem 1rem;
            background: #f8fafc;
        }

        .corpus-header h3 {
            font-size: 0.98rem;
            margin-bottom: 0.6rem;
        }

        .corpus-stats {
            display: flex;
            gap: 0.9rem;
            font-size: 0.79rem;
            color: var(--text-muted);
        }

        .corpus-list {
            flex: 1;
            overflow-y: auto;
            max-height: 360px;
            padding: 0.65rem;
        }

        .corpus-item {
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #f8fafc;
            padding: 0.65rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .corpus-item-name {
            font-size: 0.85rem;
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 190px;
        }
        .corpus-item-meta { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.15rem; }
        .corpus-item-delete {
            border: none;
            background: transparent;
            color: #8f9bab;
            cursor: pointer;
            font-size: 1rem;
        }

        .corpus-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
            padding: 1.3rem 0.7rem;
        }

        .admin-panel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1.2rem;
            z-index: 1000;
        }

        .admin-panel.active { display: flex; }
        .admin-content {
            width: 100%;
            max-width: 860px;
            max-height: 92vh;
            background: white;
            border-radius: 14px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .admin-header {
            background: var(--primary);
            color: white;
            padding: 1rem 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .admin-body {
            padding: 1rem 1.2rem;
            overflow-y: auto;
        }

        .api-section {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            background: #f8fafc;
        }

        .api-input-group { display: flex; gap: 0.55rem; }
        .api-input {
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.65rem 0.75rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 0.85rem;
        }

        .api-save-btn {
            border: none;
            border-radius: 6px;
            background: var(--success);
            color: white;
            padding: 0.65rem 0.95rem;
            font-weight: 600;
            cursor: pointer;
        }

        .model-section {
            margin-top: 0.85rem;
            border: 1px solid #cceaf3;
            background: #eff9fc;
            border-radius: 8px;
            padding: 0.85rem;
        }

        .model-select {
            width: 100%;
            margin-top: 0.45rem;
            padding: 0.55rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: white;
        }

        .upload-zone {
            margin-top: 1rem;
            border: 2px dashed var(--border);
            border-radius: 12px;
            background: #f8fafc;
            text-align: center;
            padding: 2rem 1rem;
            cursor: pointer;
        }
        .upload-zone.dragover {
            border-color: var(--accent);
            background: #f0fbff;
        }

        .processing-status {
            margin-top: 0.9rem;
            display: none;
            border: 1px solid #cdebf3;
            background: #edf9fd;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.85rem;
        }
        .processing-status.active { display: block; }
        .processing-bar {
            margin-top: 0.55rem;
            height: 6px;
            background: #dce9ef;
            border-radius: 4px;
            overflow: hidden;
        }
        .processing-bar-fill {
            height: 100%;
            width: 0;
            background: var(--accent);
            transition: width 0.2s;
        }

        .admin-actions {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
        }
        .admin-action-btn {
            border: 1px solid var(--border);
            border-radius: 7px;
            background: white;
            padding: 0.58rem 0.8rem;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .admin-action-btn.danger {
            border-color: #f4a7ad;
            color: #bd2430;
            background: #fff7f8;
        }

        .citation-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.45);
            z-index: 1002;
            padding: 1rem;
        }
        .citation-modal.active { display: flex; }
        .citation-content {
            width: 100%;
            max-width: 620px;
            max-height: 76vh;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .citation-header {
            background: var(--accent);
            color: white;
            padding: 0.9rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .citation-body {
            padding: 1rem;
            overflow-y: auto;
        }
        .citation-source {
            color: var(--text-muted);
            font-size: 0.82rem;
            margin-bottom: 0.8rem;
        }
        .citation-text {
            border-left: 3px solid var(--accent);
            background: #f8fafc;
            border-radius: 6px;
            padding: 0.85rem;
            line-height: 1.62;
        }

        .toast-container {
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            z-index: 1003;
            display: flex;
            flex-direction: column;
            gap: 0.55rem;
        }
        .toast {
            background: white;
            border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.18);
            padding: 0.7rem 0.85rem;
            max-width: 360px;
            font-size: 0.84rem;
            border-left: 4px solid var(--accent);
        }
        .toast.success { border-left-color: var(--success); }
        .toast.warning { border-left-color: var(--warning); }
        .toast.error { border-left-color: var(--error); }

        .keyboard-hint {
            position: fixed;
            left: 1rem;
            bottom: 1rem;
            background: white;
            border-radius: 6px;
            padding: 0.45rem 0.6rem;
            color: var(--text-muted);
            font-size: 0.73rem;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
        }
        .keyboard-hint kbd {
            border: 1px solid var(--border);
            border-radius: 4px;
            background: #f8fafc;
            padding: 0.08rem 0.32rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        @media (max-width: 980px) {
            .main-container { flex-direction: column; }
            .corpus-sidebar { width: 100%; }
            .chat-messages { max-height: 50vh; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>UofT Cognitive Synthesis Engine</h1>
        <div style="display:flex;align-items:center;gap:.75rem;">
            <span class="brain-badge">Brain-Aligned Strict RAG</span>
            <button class="header-btn" id="openAdminBtn" title="Open Admin Panel (Ctrl+Shift+A)">Admin Panel</button>
        </div>
    </header>

    <div class="main-container">
        <section class="chat-section">
            <div class="chat-header">
                <div>
                    <h2>Knowledge Synthesis Interface</h2>
                    <p>Strict source-grounded, full-corpus, concept-linked reasoning</p>
                </div>
                <button class="header-btn" id="clearChatBtn" style="font-size:.8rem;padding:.42rem .7rem;">Clear Chat</button>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    Welcome! This engine performs strict RAG synthesis with:
                    full-corpus activation, concept-bridge retrieval, mental-model planning, and claim-level citations.
                    <br><br>
                    Open <strong>Admin Panel</strong> (Ctrl+Shift+A) to upload documents and set your API key.
                </div>
            </div>

            <div class="synthesis-indicator" id="synthesisIndicator">
                <div class="pulse"></div>
                <span id="synthesisIndicatorText">Activating full corpus and building mental model...</span>
            </div>

            <div class="chat-input-container">
                <div class="attachment-preview" id="attachmentPreview">
                    <div>
                        <div class="attachment-preview-name" id="attachmentName">attachment.pdf</div>
                        <div class="attachment-preview-meta" id="attachmentMeta">Temporary one-turn analysis</div>
                    </div>
                    <button class="attachment-preview-remove" id="attachmentRemove" title="Remove attachment">âœ•</button>
                </div>

                <input type="file" id="chatFileInput" accept=".pdf,.docx,.txt,.csv,.xlsx,.md" style="display:none;">
                <div class="chat-input-wrapper">
                    <button class="attach-btn" id="chatAttachBtn" title="Attach file">ðŸ“Ž</button>
                    <textarea class="chat-input" id="chatInput" placeholder="Ask a question..." rows="2"></textarea>
                    <button class="send-btn" id="sendBtn">Send</button>
                </div>
            </div>
        </section>

        <aside class="corpus-sidebar">
            <div class="corpus-header">
                <h3>Document Corpus</h3>
                <div class="corpus-stats">
                    <span id="docCount">0 documents</span>
                    <span id="chunkCount">0 chunks</span>
                </div>
            </div>
            <div class="corpus-list" id="corpusList">
                <div class="corpus-empty">No documents yet. Open Admin Panel to upload files.</div>
            </div>
        </aside>
    </div>

    <div class="admin-panel" id="adminPanel">
        <div class="admin-content">
            <div class="admin-header">
                <h2 style="font-size:1.08rem;">Admin Panel</h2>
                <button class="header-btn" id="adminClose">Close</button>
            </div>

            <div class="admin-body">
                <div class="api-section">
                    <h4 style="margin-bottom:.6rem;">OpenAI API Key</h4>
                    <div class="api-input-group">
                        <input type="password" class="api-input" id="apiKeyInput" placeholder="sk-...">
                        <button class="api-save-btn" id="saveApiKey">Save Key</button>
                    </div>

                    <div class="model-section">
                        <h4 style="font-size:.9rem;color:#0d667d;">Model Selection</h4>
                        <select class="model-select" id="modelSelect">
                            <option value="gpt-4.1">GPT-4.1 (Best synthesis quality)</option>
                            <option value="gpt-4o">GPT-4o (Balanced)</option>
                            <option value="gpt-4o-mini">GPT-4o mini (Faster)</option>
                        </select>
                        <p style="margin-top:.45rem;color:#516377;font-size:.76rem;">
                            Strict RAG mode enforces source-grounded reasoning, continuity-safe context use, and citations.
                        </p>
                    </div>
                </div>

                <div class="upload-zone" id="uploadZone">
                    <h3 style="font-size:1rem;margin-bottom:.35rem;">Drag & Drop Documents</h3>
                    <p style="color:#627487;font-size:.85rem;">
                        Click to upload permanent corpus files (PDF, DOCX, XLSX, TXT, CSV, MD)
                    </p>
                    <input type="file" id="fileInput" multiple accept=".pdf,.docx,.xlsx,.txt,.csv,.md" style="display:none;">
                </div>

                <div class="processing-status" id="processingStatus">
                    <div id="processingText">Processing...</div>
                    <div class="processing-bar"><div class="processing-bar-fill" id="processingBarFill"></div></div>
                </div>

                <div class="admin-actions">
                    <button class="admin-action-btn" id="rebuildIndex">Rebuild Index</button>
                    <button class="admin-action-btn danger" id="clearCorpus">Clear All Documents</button>
                    <button class="admin-action-btn" id="clearChatAdmin">Clear Chat History</button>
                    <button class="admin-action-btn" id="runEvalHarness">Run Eval Harness</button>
                </div>
            </div>
        </div>
    </div>

    <div class="citation-modal" id="citationModal">
        <div class="citation-content">
            <div class="citation-header">
                <h3 style="font-size:.98rem;">Source Citation</h3>
                <button class="header-btn" id="citationClose">Close</button>
            </div>
            <div class="citation-body">
                <div class="citation-source" id="citationSource"></div>
                <div class="citation-text" id="citationText"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>
    <div class="keyboard-hint"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>A</kbd> Admin Panel</div>

    <script>
    const DB_NAME = 'CognitiveSynthesisDB';
    const DB_VERSION = 2;
    const STORE_NAME = 'documents';

    const LONG_DOC_WORD_THRESHOLD = 12000;
    const MAX_CONTEXT_CHARS = 90000;
    const RETRIEVAL_LOW_SCORE_THRESHOLD = 0.18;
    const MULTIPASS_CHUNK_THRESHOLD = 16;
    const MULTIPASS_CONTEXT_CHAR_THRESHOLD = 70000;
    const MAP_PASS_CONTEXT_BUDGET = 15000;
    const MAX_MAP_PASSES = 7;
    const EMBEDDING_MODEL = 'text-embedding-3-small';
    const EMBEDDING_RERANK_CANDIDATE_LIMIT = 160;
    const EMBEDDING_BATCH_SIZE = 24;
    const CLAIM_CITATION_TARGET = 0.55;
    const CLAIM_SUPPORT_TARGET = 0.45;
    const CITATION_PRECISION_TARGET = 0.5;
    const TPM_CONTEXT_TOKEN_BUDGET = 9500;
    const TPM_RETRY_CONTEXT_TOKEN_BUDGET = 7200;
    const MAP_PHASE_MAX_TOKENS = 420;
    const RESPONSE_CACHE_KEY = 'completion_response_cache_v1';
    const RESPONSE_CACHE_MAX_ENTRIES = 120;
    const RESPONSE_CACHE_TTL_MS = 1000 * 60 * 30;
    const COMPLETION_TELEMETRY_KEY = 'completion_telemetry_v1';
    const MODEL_FALLBACK_ORDER = ['gpt-4.1', 'gpt-4o', 'gpt-4o-mini'];
    const RETRIEVER_STOP_WORDS = new Set([
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
        'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be',
        'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
        'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'this', 'that',
        'these', 'those', 'what', 'which', 'who', 'whom', 'whose', 'when', 'where',
        'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more', 'most', 'other',
        'some', 'such', 'than', 'too', 'very', 'just', 'also', 'into', 'about',
        'over', 'under', 'through', 'across'
    ]);
    const DIAGNOSTIC_STOP_WORDS = new Set([
        'the', 'a', 'an', 'and', 'or', 'but', 'if', 'then', 'in', 'on', 'at', 'to', 'for', 'of',
        'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'it', 'its', 'that',
        'this', 'these', 'those', 'we', 'they', 'their', 'there', 'here', 'which', 'what', 'when',
        'where', 'why', 'how', 'can', 'could', 'should', 'would', 'may', 'might', 'will', 'also'
    ]);
    const SUPER_BRAIN_STOP_WORDS = new Set([
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of',
        'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'it',
        'this', 'that', 'these', 'those', 'can', 'could', 'should', 'would', 'may',
        'might', 'will', 'also', 'than', 'then', 'into', 'over', 'under'
    ]);
    const HUMAN_BASELINE_METRICS = {
        overall: 0.74,
        coverage: 0.76,
        citationCoverage: 0.72,
        citationPrecision: 0.75,
        instructionAdherence: 0.77,
        decisionQuality: 0.71
    };
    const BENCHMARK_TASKS = [
        {
            id: 'bmk-1',
            category: 'cross_source_decision',
            query: 'Using all relevant uploaded sources, recommend a single course of action and justify it with cross-source trade-offs, risks, and constraints.'
        },
        {
            id: 'bmk-2',
            category: 'conflict_resolution',
            query: 'Identify any conflicts or tensions across sources, explain the conflict drivers, and provide a reconciled interpretation with citations.'
        },
        {
            id: 'bmk-3',
            category: 'constraint_planning',
            query: 'Build a constraint-aware plan from the corpus, including dependencies, exceptions, and failure modes, then propose mitigations.'
        },
        {
            id: 'bmk-4',
            category: 'gap_detection',
            query: 'What cannot be concluded yet from the corpus, what evidence gaps remain, and which exact documents/data are required next?'
        }
    ];

    const REFUSAL_PATTERNS = [
        /cannot\s+(?:directly\s+)?access/i,
        /outside of (?:the )?provided excerpts/i,
        /training cut[- ]?off/i,
        /cannot review documents outside/i,
        /i do not have access to your document/i
    ];

    class DocumentDatabase {
        constructor() {
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    this.db = request.result;
                    resolve(this.db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('filename', 'filename', { unique: false });
                        store.createIndex('type', 'type', { unique: false });
                    }
                };
            });
        }

        async addDocument(doc) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.add(doc);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getAllDocuments() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async deleteDocument(id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async clearAll() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }

    class DocumentProcessor {
        constructor() {
            this.stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                'this', 'that', 'these', 'those', 'what', 'which', 'who', 'when',
                'where', 'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more',
                'most', 'other', 'some', 'such', 'than', 'too', 'very', 'just', 'also',
                'into', 'about', 'over', 'under', 'through', 'across'
            ]);

            this.unsupportedLegacyExtensions = new Set(['doc', 'xls']);
            this.supportedExtensions = new Set(['pdf', 'docx', 'xlsx', 'txt', 'csv', 'md']);

            this.mimeProcessors = {
                'application/pdf': this.processPDF.bind(this),
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': this.processDOCX.bind(this),
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': this.processXLSX.bind(this),
                'text/plain': this.processText.bind(this),
                'text/csv': this.processCSV.bind(this),
                'text/markdown': this.processText.bind(this)
            };

            this.extensionProcessors = {
                'pdf': this.processPDF.bind(this),
                'docx': this.processDOCX.bind(this),
                'xlsx': this.processXLSX.bind(this),
                'txt': this.processText.bind(this),
                'csv': this.processCSV.bind(this),
                'md': this.processText.bind(this)
            };
        }

        getExtension(filename = '') {
            const parts = filename.split('.');
            if (parts.length < 2) return '';
            return parts.pop().toLowerCase();
        }

        resolveProcessor(file, extension) {
            return this.extensionProcessors[extension] || this.mimeProcessors[file.type] || this.processText.bind(this);
        }

        normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\u0000/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/[^\S\n]+/g, ' ')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
        }

        splitIntoSentences(text) {
            return text
                .split(/(?<=[.!?])\s+(?=[A-Z0-9"â€œ'`])/)
                .map(s => s.trim())
                .filter(Boolean);
        }

        tokenizeForMemory(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.stopWords.has(token));
        }

        extractHeadings(text) {
            const lines = text.split('\n');
            const headings = [];
            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line || line.length > 120) continue;
                if (/^\[Page\s+\d+\]$/i.test(line)) {
                    headings.push(line);
                    continue;
                }
                const markdownHeading = /^#{1,6}\s+(.+)$/;
                const numberedHeading = /^\d+(\.\d+){0,3}\s+[A-Z]/;
                const titleCaseHeading = /^[A-Z][A-Za-z0-9\s,:;()/-]{4,}$/;
                if (markdownHeading.test(line) || numberedHeading.test(line) || titleCaseHeading.test(line)) {
                    if (!/[.!?]$/.test(line)) {
                        headings.push(line.replace(/^#{1,6}\s*/, ''));
                    }
                }
            }
            return Array.from(new Set(headings)).slice(0, 24);
        }

        isLikelyHeading(line) {
            if (!line) return false;
            if (line.length < 4 || line.length > 120) return false;
            if (/^[\[\](){}]/.test(line)) return false;
            if (/[.!?]$/.test(line)) return false;
            if (/^[-*â€¢]/.test(line)) return false;
            if (/^\d+$/.test(line)) return false;
            return (
                /^#{1,6}\s+/.test(line) ||
                /^\d+(\.\d+){0,3}\s+[A-Z]/.test(line) ||
                /^[A-Z][A-Za-z0-9\s,:;()/-]+$/.test(line)
            );
        }

        splitLargeParagraph(paragraph, maxChars = 1500) {
            const cleaned = paragraph.trim();
            if (!cleaned) return [];
            if (cleaned.length <= maxChars) return [cleaned];
            const sentences = this.splitIntoSentences(cleaned);
            if (sentences.length <= 1) {
                const chunks = [];
                for (let i = 0; i < cleaned.length; i += maxChars) chunks.push(cleaned.slice(i, i + maxChars));
                return chunks;
            }
            const result = [];
            let current = '';
            for (const sentence of sentences) {
                const candidate = current ? `${current} ${sentence}` : sentence;
                if (candidate.length > maxChars && current) {
                    result.push(current.trim());
                    current = sentence;
                } else if (sentence.length > maxChars) {
                    const hardSplit = this.splitLargeParagraph(sentence, maxChars);
                    if (current) { result.push(current.trim()); current = ''; }
                    result.push(...hardSplit);
                } else {
                    current = candidate;
                }
            }
            if (current.trim()) result.push(current.trim());
            return result;
        }

        getOverlapTail(text, overlapChars = 260) {
            if (!text || text.length <= overlapChars) return text;
            const tail = text.slice(-overlapChars);
            const boundary = tail.search(/[.!?]\s+[A-Z]/);
            if (boundary > 0) return tail.slice(boundary + 2).trim();
            return tail.trim();
        }

        splitIntoSections(text) {
            const sections = [];
            const lines = text.split('\n');
            let currentTitle = 'Document';
            let currentPage = null;
            let buffer = [];

            const flush = () => {
                const content = buffer.join('\n').trim();
                if (content) {
                    sections.push({ title: currentTitle, page: currentPage, content });
                }
                buffer = [];
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                const pageMatch = line.match(/^\[Page\s+(\d+)\]$/i);
                if (pageMatch) {
                    flush();
                    currentPage = parseInt(pageMatch[1], 10);
                    currentTitle = `Page ${currentPage}`;
                    continue;
                }
                if (this.isLikelyHeading(line) && buffer.join('\n').length > 700) {
                    flush();
                    currentTitle = line.replace(/^#{1,6}\s*/, '');
                    continue;
                }
                buffer.push(rawLine);
            }

            flush();
            return sections.length ? sections : [{ title: 'Document', page: null, content: text }];
        }

        extractPageFromText(text) {
            const match = text.match(/\[Page\s+(\d+)\]/i);
            return match ? parseInt(match[1], 10) : null;
        }

        scoreSentence(sentence, conceptSet) {
            const words = sentence.toLowerCase().match(/\b[a-z][a-z0-9-]+\b/g) || [];
            let score = 0;
            for (const word of words) if (conceptSet.has(word)) score += 1;
            if (/\d/.test(sentence)) score += 0.7;
            if (/[A-Z][a-z]+ [A-Z][a-z]+/.test(sentence)) score += 0.6;
            if (sentence.length >= 60 && sentence.length <= 260) score += 0.5;
            return score;
        }

        buildDocumentMemory(text, chunks, filename) {
            const words = text.split(/\s+/).filter(Boolean);
            const wordCount = words.length;
            const readingTimeMinutes = Math.max(1, Math.round(wordCount / 220));
            const headings = this.extractHeadings(text);
            const tokens = this.tokenizeForMemory(text);
            const frequencies = new Map();
            for (const token of tokens) frequencies.set(token, (frequencies.get(token) || 0) + 1);
            const keyConcepts = Array.from(frequencies.entries())
                .filter(([, count]) => count > 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 18)
                .map(([token]) => token);
            const conceptSet = new Set(keyConcepts);
            const sentences = this.splitIntoSentences(text).filter(s => s.length >= 35 && s.length <= 320);
            const everyNth = Math.max(1, Math.floor(sentences.length / 14));
            const scored = sentences.map((sentence, idx) => ({
                sentence,
                score: this.scoreSentence(sentence, conceptSet) + ((idx % everyNth === 0) ? 0.3 : 0)
            }));
            const salientSentences = scored
                .sort((a, b) => b.score - a.score)
                .slice(0, 14)
                .map(item => item.sentence.trim());
            const synopsis = salientSentences.slice(0, 6).join(' ').trim();
            return {
                filename,
                wordCount,
                chunkCount: chunks.length,
                readingTimeMinutes,
                outline: headings,
                keyConcepts,
                salientSentences,
                synopsis
            };
        }

        intelligentChunk(text, filename, baseChunkSize = 1800, overlap = 260) {
            const cleaned = this.normalizeText(text);
            if (!cleaned) return [];
            const dynamicChunkSize = cleaned.length > 350000 ? 2400 :
                cleaned.length > 150000 ? 2100 :
                cleaned.length > 50000 ? 1900 : baseChunkSize;
            const sections = this.splitIntoSections(cleaned);
            const chunks = [];
            let chunkIndex = 0;

            for (const section of sections) {
                const paragraphs = section.content
                    .split(/\n{2,}/)
                    .map(p => p.trim())
                    .filter(Boolean);
                let current = section.title ? `${section.title}\n` : '';
                let currentPage = section.page || null;

                const pushChunk = () => {
                    const chunkText = current.trim();
                    if (!chunkText) return;
                    chunks.push({
                        id: `${filename}-chunk-${chunkIndex}`,
                        text: chunkText,
                        filename,
                        section: section.title || 'Document',
                        page: currentPage || this.extractPageFromText(chunkText),
                        index: chunkIndex,
                        preview: chunkText.replace(/\s+/g, ' ').slice(0, 120) + (chunkText.length > 120 ? '...' : '')
                    });
                    chunkIndex++;
                };

                for (const paragraph of paragraphs) {
                    const pageInParagraph = paragraph.match(/\[Page\s+(\d+)\]/i);
                    if (pageInParagraph) currentPage = parseInt(pageInParagraph[1], 10);
                    const units = this.splitLargeParagraph(paragraph, Math.floor(dynamicChunkSize * 0.9));
                    for (const unit of units) {
                        const candidate = current ? `${current}\n\n${unit}` : unit;
                        if (candidate.length > dynamicChunkSize && current.trim()) {
                            pushChunk();
                            const overlapText = this.getOverlapTail(current, overlap);
                            current = overlapText ? `${overlapText}\n\n${unit}` : unit;
                        } else if (candidate.length > dynamicChunkSize && !current.trim()) {
                            const hardUnits = this.splitLargeParagraph(unit, Math.floor(dynamicChunkSize * 0.8));
                            for (const hardUnit of hardUnits) {
                                current = hardUnit;
                                pushChunk();
                                current = '';
                            }
                        } else {
                            current = candidate;
                        }
                    }
                }
                if (current.trim()) pushChunk();
            }
            return chunks;
        }

        async processFile(file) {
            const extension = this.getExtension(file.name);
            if (this.unsupportedLegacyExtensions.has(extension)) {
                throw new Error(`Legacy ${extension.toUpperCase()} is not supported in-browser. Convert to DOCX or XLSX first.`);
            }
            if (!this.supportedExtensions.has(extension)) {
                throw new Error(`Unsupported file type: .${extension || 'unknown'}`);
            }

            const processor = this.resolveProcessor(file, extension);
            const extracted = await processor(file);
            const text = this.normalizeText(extracted);
            if (!text || text.length < 20) throw new Error(`Could not extract readable text from ${file.name}.`);

            const chunks = this.intelligentChunk(text, file.name);
            const memory = this.buildDocumentMemory(text, chunks, file.name);

            return {
                filename: file.name,
                type: file.type || extension,
                extension,
                size: file.size,
                uploadedAt: new Date().toISOString(),
                fullText: text,
                chunks,
                memory
            };
        }

        async processText(file) { return await file.text(); }

        async processCSV(file) {
            const text = await file.text();
            const lines = text.split('\n');
            let formatted = `CSV Data from ${file.name}:\n\n`;
            if (lines.length > 0) {
                const headers = lines[0].split(',').map(h => h.trim());
                formatted += `Columns: ${headers.join(', ')}\n\n`;
                for (let i = 1; i < Math.min(lines.length, 300); i++) {
                    const values = lines[i].split(',');
                    if (!values.some(value => value.trim())) continue;
                    formatted += `Row ${i}: `;
                    headers.forEach((header, idx) => {
                        if (values[idx] && values[idx].trim()) formatted += `${header}: ${values[idx].trim()}; `;
                    });
                    formatted += '\n';
                }
            }
            return formatted;
        }

        async processPDF(file) {
            if (typeof pdfjsLib === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js');
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += `[Page ${i}]\n${pageText}\n\n`;
            }
            return fullText;
        }

        async processDOCX(file) {
            if (typeof mammoth === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js');
            }
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        async processXLSX(file) {
            if (typeof XLSX === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
            }
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            let fullText = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                fullText += `[Sheet: ${sheetName}]\n`;
                jsonData.forEach((row, rowIndex) => {
                    if (row.length > 0) fullText += `Row ${rowIndex + 1}: ${row.join(' | ')}\n`;
                });
                fullText += '\n';
            });
            return fullText;
        }

        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    }

    class CognitiveRetriever {
        constructor() {
            this.documents = [];
            this.allChunks = [];
            this.idf = new Map();
            this.avgChunkLength = 1;
            this.chunkTokenCache = new Map();
            this.chunkLookup = new Map();
            this.conceptIndex = new Map();
            this.documentConceptMap = new Map();
            this.embeddingApiKey = localStorage.getItem('openai_api_key') || '';
            this.embeddingModel = EMBEDDING_MODEL;
            this.chunkEmbeddingCache = new Map();
            this.queryEmbeddingCache = new Map();
            this.chunkEmbeddingTextCache = new Map();
            this.embeddingEnabled = true;
            this.lastEmbeddingError = '';
            this.stopWords = RETRIEVER_STOP_WORDS;
        }

        setEmbeddingApiKey(apiKey) { this.embeddingApiKey = apiKey || ''; }

        normalizeEmbeddingText(text, maxChars = 2200) {
            return String(text || '').replace(/\s+/g, ' ').trim().slice(0, maxChars);
        }

        prepareChunkEmbeddingText(chunk) {
            const header = `${chunk.filename || 'document'} ${chunk.section || ''} ${chunk.page ? `page ${chunk.page}` : ''}`;
            const body = this.normalizeEmbeddingText(chunk.text || '');
            return `${header}\n${body}`.trim();
        }

        cosineSimilarity(vecA, vecB) {
            if (!Array.isArray(vecA) || !Array.isArray(vecB) || vecA.length !== vecB.length || vecA.length === 0) return 0;
            let dot = 0; let normA = 0; let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                const a = vecA[i]; const b = vecB[i];
                dot += a * b; normA += a * a; normB += b * b;
            }
            if (normA === 0 || normB === 0) return 0;
            return dot / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        async embedTextBatch(texts) {
            if (!this.embeddingApiKey) return null;
            const response = await fetch('https://api.openai.com/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.embeddingApiKey}`
                },
                body: JSON.stringify({ model: this.embeddingModel, input: texts })
            });
            if (!response.ok) {
                let detail = `Embedding API failed (HTTP ${response.status})`;
                try {
                    const error = await response.json();
                    detail = error.error?.message || detail;
                } catch {}
                throw new Error(detail);
            }
            const data = await response.json();
            return data.data.map(item => item.embedding);
        }

        async getQueryEmbedding(query) {
            if (!this.embeddingApiKey || !this.embeddingEnabled) return null;
            const normalizedQuery = this.normalizeEmbeddingText(query, 1000).toLowerCase();
            if (!normalizedQuery) return null;
            if (this.queryEmbeddingCache.has(normalizedQuery)) return this.queryEmbeddingCache.get(normalizedQuery);
            try {
                const vectors = await this.embedTextBatch([normalizedQuery]);
                const vector = vectors?.[0] || null;
                if (vector) this.queryEmbeddingCache.set(normalizedQuery, vector);
                return vector;
            } catch (error) {
                this.lastEmbeddingError = error.message;
                return null;
            }
        }

        async ensureEmbeddingsForChunks(chunks) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !chunks?.length) return;
            const uniqueChunks = [];
            const seen = new Set();
            for (const chunk of chunks) {
                if (!chunk?.id || seen.has(chunk.id)) continue;
                seen.add(chunk.id);
                uniqueChunks.push(chunk);
            }
            const missing = uniqueChunks.filter(chunk => !this.chunkEmbeddingCache.has(chunk.id));
            if (missing.length === 0) return;
            for (let i = 0; i < missing.length; i += EMBEDDING_BATCH_SIZE) {
                const batch = missing.slice(i, i + EMBEDDING_BATCH_SIZE);
                const batchTexts = batch.map(chunk => {
                    const text = this.prepareChunkEmbeddingText(chunk);
                    this.chunkEmbeddingTextCache.set(chunk.id, text);
                    return text;
                });
                try {
                    const vectors = await this.embedTextBatch(batchTexts);
                    vectors.forEach((vector, idx) => {
                        const chunkId = batch[idx].id;
                        if (chunkId && vector) this.chunkEmbeddingCache.set(chunkId, vector);
                    });
                } catch (error) {
                    this.lastEmbeddingError = error.message;
                    return;
                }
            }
        }

        async semanticRerank(query, candidates, topK, intent = {}) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !candidates?.length) return null;
            const limited = candidates.slice(0, EMBEDDING_RERANK_CANDIDATE_LIMIT);
            const queryVector = await this.getQueryEmbedding(query);
            if (!queryVector) return null;
            await this.ensureEmbeddingsForChunks(limited);
            const reranked = limited.map(chunk => {
                const embedding = this.chunkEmbeddingCache.get(chunk.id);
                const semanticScore = embedding ? this.cosineSimilarity(queryVector, embedding) : 0;
                const lexicalScore = chunk.score || 0;
                let hybridScore = (lexicalScore * 0.62) + (semanticScore * 0.38);
                if (intent.broadCoverage) hybridScore += semanticScore * 0.05;
                return { ...chunk, lexicalScore, semanticScore, score: hybridScore };
            }).sort((a, b) => b.score - a.score);
            return this.diversifyResults(reranked, topK);
        }

        shouldUseSemanticRerank(intent = {}, candidates = [], topK = 10) {
            if (!this.embeddingEnabled || !this.embeddingApiKey) return false;
            if (!Array.isArray(candidates) || candidates.length < Math.max(topK * 2, 18)) return false;
            if (intent.broadCoverage || intent.comparative || intent.timeline) return true;
            return this.allChunks.length > 30;
        }

        updateCorpus(documents) {
            this.documents = documents.map(doc => {
                if (doc.memory) return doc;
                return { ...doc, memory: this.deriveMemoryFromChunks(doc) };
            });
            this.allChunks = this.documents.flatMap(doc => doc.chunks || []);
            this.chunkLookup = new Map(this.allChunks.map(chunk => [chunk.id, chunk]));
            this.chunkEmbeddingCache.clear();
            this.chunkEmbeddingTextCache.clear();
            this.buildTokenStats();
            this.buildConceptIndex();
        }

        deriveMemoryFromChunks(doc) {
            const chunks = doc.chunks || [];
            const previews = chunks.slice(0, 8).map(chunk => chunk.preview || chunk.text.slice(0, 120));
            const synopsis = previews.join(' ');
            return {
                filename: doc.filename,
                wordCount: Math.max(0, Math.round((doc.fullText || '').split(/\s+/).filter(Boolean).length)),
                chunkCount: chunks.length,
                readingTimeMinutes: Math.max(1, Math.round(((doc.fullText || '').split(/\s+/).length || 0) / 220)),
                outline: [],
                keyConcepts: this.extractConcepts((doc.fullText || '').slice(0, 4000)).slice(0, 10),
                salientSentences: previews,
                synopsis
            };
        }

        buildTokenStats() {
            this.idf.clear();
            this.chunkTokenCache.clear();
            if (this.allChunks.length === 0) { this.avgChunkLength = 1; return; }

            const df = new Map();
            let totalLength = 0;
            for (const chunk of this.allChunks) {
                const tokens = this.tokenize(chunk.text);
                const tf = new Map();
                for (const token of tokens) tf.set(token, (tf.get(token) || 0) + 1);
                this.chunkTokenCache.set(chunk.id, { tokens, tf, length: tokens.length || 1 });
                totalLength += tokens.length;
                const uniqueTokens = new Set(tokens);
                for (const token of uniqueTokens) df.set(token, (df.get(token) || 0) + 1);
            }
            this.avgChunkLength = totalLength / Math.max(1, this.allChunks.length);
            const N = this.allChunks.length;
            for (const [token, count] of df.entries()) {
                const idf = Math.log(((N - count + 0.5) / (count + 0.5)) + 1);
                this.idf.set(token, idf);
            }
        }

        buildConceptIndex() {
            this.conceptIndex.clear();
            this.documentConceptMap.clear();
            for (const doc of this.documents) {
                const docConcepts = new Set();
                for (const chunk of (doc.chunks || [])) {
                    const concepts = this.extractKeyConceptsFromChunk(chunk.text);
                    for (const concept of concepts) {
                        docConcepts.add(concept);
                        if (!this.conceptIndex.has(concept)) this.conceptIndex.set(concept, []);
                        this.conceptIndex.get(concept).push({ docId: doc.id, filename: doc.filename, chunkId: chunk.id });
                    }
                }
                this.documentConceptMap.set(doc.filename, docConcepts);
            }
        }

        detectQueryIntent(query) {
            const q = query.toLowerCase();
            return {
                broadCoverage: /\b(whole|entire|full|overall|comprehensive|big picture|summari[sz]e|main themes|analyze.*document|review.*document)\b/.test(q),
                comparative: /\b(compare|contrast|versus|vs\.?)\b/.test(q),
                extraction: /\b(list|extract|enumerate|all instances|find all)\b/.test(q),
                timeline: /\b(timeline|chronological|over time|sequence)\b/.test(q)
            };
        }

        splitIntoSubQueries(query) {
            const compact = query.replace(/\s+/g, ' ').trim();
            const pieces = compact.split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|along with)\b\s+)/i)
                .map(piece => piece.trim())
                .filter(piece => piece.length >= 12);
            return Array.from(new Set(pieces)).slice(0, 6);
        }

        extractQueryPhrases(query) {
            const phrases = query.toLowerCase().match(/\b[a-z0-9][a-z0-9-]{2,}(?:\s+[a-z0-9][a-z0-9-]{2,}){1,2}\b/g) || [];
            return Array.from(new Set(phrases))
                .filter(phrase => phrase.split(/\s+/).some(word => !this.isStopWord(word)))
                .slice(0, 10);
        }

        generateQueryVariants(query, intent = {}) {
            const variants = [query.trim()];
            variants.push(...this.splitIntoSubQueries(query).slice(0, 3));
            variants.push(...this.extractQueryPhrases(query).slice(0, 3));
            if (intent.broadCoverage) variants.push(`${query} key themes and overall synthesis`);
            if (intent.timeline) variants.push(`${query} timeline chronology milestones`);
            if (intent.comparative) variants.push(`${query} differences similarities trade-offs`);
            return Array.from(new Set(variants.map(v => v.trim()).filter(Boolean))).slice(0, 7);
        }

        calculateQueryVariantScore(chunk, query, queryTokens, queryEntities, queryConcepts, weight = 1) {
            const score = this.calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts);
            return score * weight;
        }

        tokenize(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.isStopWord(token));
        }

        isStopWord(word) {
            return this.stopWords.has(word);
        }

        extractEntities(text) {
            const entities = [];
            const capitalizedWords = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
            entities.push(...capitalizedWords.map(e => e.toLowerCase()));
            const numbers = text.match(/\d+(?:\.\d+)?%?/g) || [];
            entities.push(...numbers);
            const dates = text.match(/\d{4}|\d{1,2}\/\d{1,2}\/\d{2,4}/g) || [];
            entities.push(...dates);
            return entities;
        }

        extractConcepts(text) {
            const concepts = [];
            const phrases = text.match(/\b\w+\s+\w+(?:\s+\w+)?\b/g) || [];
            concepts.push(...phrases.map(p => p.toLowerCase()));
            return concepts;
        }

        extractKeyConceptsFromChunk(text) {
            const concepts = new Set();
            const properNouns = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
            properNouns.forEach(p => concepts.add(p.toLowerCase()));
            const technical = text.match(/\b[a-z]+[-_]?[a-z]*\d+[a-z]*\b/gi) || [];
            technical.forEach(t => concepts.add(t.toLowerCase()));
            const quoted = text.match(/"([^"]+)"/g) || [];
            quoted.forEach(q => concepts.add(q.replace(/"/g, '').toLowerCase()));
            return concepts;
        }

        calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts) {
            const cache = this.chunkTokenCache.get(chunk.id) || { tokens: this.tokenize(chunk.text), tf: new Map(), length: 1 };
            if (cache.tf.size === 0) {
                for (const token of cache.tokens) cache.tf.set(token, (cache.tf.get(token) || 0) + 1);
            }

            const uniqueQueryTokens = Array.from(new Set(queryTokens));
            const chunkTextLower = chunk.text.toLowerCase();
            const queryTextLower = query.toLowerCase().trim();
            let score = 0;

            if (uniqueQueryTokens.length > 0) {
                const k1 = 1.2; const b = 0.75;
                let bm25 = 0; let maxIdf = 0;
                for (const token of uniqueQueryTokens) {
                    const tf = cache.tf.get(token) || 0;
                    const idf = this.idf.get(token) || 0.4;
                    maxIdf += idf;
                    if (tf === 0) continue;
                    const numerator = tf * (k1 + 1);
                    const denominator = tf + k1 * (1 - b + b * (cache.length / this.avgChunkLength));
                    bm25 += idf * (numerator / denominator);
                }
                if (maxIdf > 0) score += (bm25 / maxIdf) * 0.55;
            }

            if (queryTextLower.length > 12 && chunkTextLower.includes(queryTextLower)) score += 0.2;
            if (queryEntities.length > 0) {
                const entityMatches = queryEntities.filter(entity => chunkTextLower.includes(entity.toLowerCase())).length;
                score += (entityMatches / queryEntities.length) * 0.15;
            }
            if (queryConcepts.length > 0) {
                const conceptMatches = queryConcepts.filter(concept => chunkTextLower.includes(concept)).length;
                score += (conceptMatches / queryConcepts.length) * 0.08;
            }
            const tokenMatches = uniqueQueryTokens.filter(token => cache.tf.has(token)).length;
            const density = tokenMatches / Math.max(1, cache.length / 100);
            score += Math.min(density * 0.04, 0.06);
            return score;
        }

        pickEvenlyDistributed(chunks, count) {
            if (!chunks || chunks.length === 0 || count <= 0) return [];
            if (chunks.length <= count) return chunks.slice();
            const selected = [];
            for (let i = 0; i < count; i++) {
                const index = Math.floor((i * (chunks.length - 1)) / Math.max(1, count - 1));
                selected.push(chunks[index]);
            }
            return selected;
        }

        mergeUniqueChunks(primary, additions, limit) {
            const result = [];
            const seen = new Set();
            for (const chunk of [...primary, ...additions]) {
                if (!chunk || seen.has(chunk.id)) continue;
                result.push(chunk);
                seen.add(chunk.id);
                if (result.length >= limit) break;
            }
            return result;
        }

        diversifyResults(scoredChunks, topK) {
            const results = [];
            const seenDocuments = new Map();
            const maxPerDocument = Math.max(2, Math.ceil(topK / 2));
            for (const chunk of scoredChunks) {
                if (results.length >= topK) break;
                const docCount = seenDocuments.get(chunk.filename) || 0;
                if (docCount < maxPerDocument) {
                    results.push(chunk);
                    seenDocuments.set(chunk.filename, docCount + 1);
                }
            }
            if (results.length < topK) {
                for (const chunk of scoredChunks) {
                    if (results.length >= topK) break;
                    if (!results.some(existing => existing.id === chunk.id)) results.push(chunk);
                }
            }
            return results;
        }

        buildCoverageCandidates(primaryResults, scoredChunks, count) {
            if (count <= 0) return [];
            const topDocs = Array.from(new Set(primaryResults.map(chunk => chunk.filename)));
            if (topDocs.length === 0) {
                for (const chunk of scoredChunks.slice(0, 3)) topDocs.push(chunk.filename);
            }
            const coverage = [];
            const perDoc = Math.max(1, Math.ceil(count / Math.max(1, topDocs.length)));
            for (const filename of topDocs) {
                const docChunks = this.allChunks
                    .filter(chunk => chunk.filename === filename)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));
                coverage.push(...this.pickEvenlyDistributed(docChunks, perDoc));
            }
            return coverage.slice(0, count);
        }

        findConceptLinkedChunks(primaryChunks, query, queryTokens, queryConcepts) {
            const linkedChunkIds = new Set();
            const linkedChunks = [];
            for (const chunk of primaryChunks) {
                const chunkConcepts = this.extractKeyConceptsFromChunk(chunk.text);
                for (const concept of chunkConcepts) {
                    const links = this.conceptIndex.get(concept) || [];
                    for (const link of links) {
                        if (linkedChunkIds.has(link.chunkId)) continue;
                        linkedChunkIds.add(link.chunkId);
                        const linkedChunk = this.chunkLookup.get(link.chunkId);
                        if (linkedChunk) {
                            const score = this.calculateRelevanceScore(linkedChunk, query, queryTokens, [], queryConcepts);
                            linkedChunks.push({ ...linkedChunk, score, isLinked: true });
                        }
                    }
                }
            }
            linkedChunks.sort((a, b) => b.score - a.score);
            return linkedChunks;
        }

        async retrieve(query, topK = null, options = {}) {
            if (this.allChunks.length === 0) return [];
            const intent = options.intent || this.detectQueryIntent(query);
            const corpusSize = this.allChunks.length;
            if (topK === null) {
                if (intent.broadCoverage) topK = corpusSize <= 60 ? 18 : corpusSize <= 200 ? 24 : Math.min(32, Math.ceil(corpusSize * 0.08));
                else if (corpusSize <= 50) topK = 10;
                else if (corpusSize <= 200) topK = 15;
                else if (corpusSize <= 500) topK = 20;
                else topK = Math.min(25, Math.ceil(corpusSize * 0.05));
            }

            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                return {
                    variant,
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.58 : (0.42 / Math.max(1, queryVariants.length - 1))
                };
            });

            const scoredChunks = this.allChunks.map(chunk => {
                let score = 0; let maxVariantScore = 0;
                for (const features of variantFeatures) {
                    const variantScore = this.calculateQueryVariantScore(
                        chunk, features.variant, features.queryTokens, features.queryEntities, features.queryConcepts, features.weight
                    );
                    score += variantScore;
                    maxVariantScore = Math.max(maxVariantScore, variantScore);
                }
                score += maxVariantScore * 0.18;
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let primaryResults = this.diversifyResults(scoredChunks, Math.ceil(topK * 0.7));
            const bestScore = primaryResults[0]?.score || 0;
            if (intent.broadCoverage || bestScore < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const coverage = this.buildCoverageCandidates(primaryResults, scoredChunks, Math.ceil(topK * 0.5));
                primaryResults = this.mergeUniqueChunks(primaryResults, coverage, topK);
            }
            const baseFeatures = variantFeatures[0];
            const linkedChunks = this.findConceptLinkedChunks(primaryResults, query, baseFeatures.queryTokens, baseFeatures.queryConcepts)
                .slice(0, Math.max(2, Math.floor(topK * 0.25)));
            const merged = this.mergeUniqueChunks(primaryResults, linkedChunks, topK);
            if (merged.length === 0) return this.allChunks.slice(0, topK);

            const rerankCandidates = this.mergeUniqueChunks(
                scoredChunks.slice(0, Math.max(topK * 8, 80)),
                merged,
                EMBEDDING_RERANK_CANDIDATE_LIMIT
            );

            if (this.shouldUseSemanticRerank(intent, rerankCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, rerankCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = merged.slice(0, Math.ceil(topK * 0.5));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.7));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }
            return merged;
        }

        calculateLocalRelevanceScore(chunk, queryTokens, queryEntities, queryConcepts) {
            const chunkTokens = this.tokenize(chunk.text);
            const chunkTokenSet = new Set(chunkTokens);
            const chunkText = chunk.text.toLowerCase();
            let score = 0;
            if (queryTokens.length > 0) {
                const matches = queryTokens.filter(token => chunkTokenSet.has(token)).length;
                score += (matches / queryTokens.length) * 0.55;
            }
            if (queryEntities.length > 0) {
                const matches = queryEntities.filter(entity => chunkText.includes(entity.toLowerCase())).length;
                score += (matches / queryEntities.length) * 0.2;
            }
            if (queryConcepts.length > 0) {
                const matches = queryConcepts.filter(concept => chunkText.includes(concept)).length;
                score += (matches / queryConcepts.length) * 0.1;
            }
            if (queryTokens.length > 0) {
                const density = queryTokens.filter(token => chunkTokenSet.has(token)).length / Math.max(1, chunk.text.length / 120);
                score += Math.min(density * 0.06, 0.08);
            }
            return score;
        }

        async retrieveFromChunks(query, chunks, topK = 10, options = {}) {
            if (!chunks || chunks.length === 0) return [];
            const intent = options.intent || this.detectQueryIntent(query);
            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                return {
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.6 : (0.4 / Math.max(1, queryVariants.length - 1))
                };
            });
            const scored = chunks.map(chunk => {
                let score = 0;
                for (const features of variantFeatures) {
                    const localScore = this.calculateLocalRelevanceScore(chunk, features.queryTokens, features.queryEntities, features.queryConcepts);
                    score += localScore * features.weight;
                }
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let selected = scored.slice(0, Math.ceil(topK * 0.65));
            if (intent.broadCoverage || selected[0]?.score < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const orderedByIndex = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                const coverage = this.pickEvenlyDistributed(orderedByIndex, Math.ceil(topK * 0.5));
                selected = this.mergeUniqueChunks(selected, coverage, topK);
            }
            const semanticCandidates = this.mergeUniqueChunks(scored.slice(0, Math.max(topK * 6, 48)), selected, Math.min(EMBEDDING_RERANK_CANDIDATE_LIMIT, 96));
            if (this.shouldUseSemanticRerank(intent, semanticCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, semanticCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = selected.slice(0, Math.ceil(topK * 0.55));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.65));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }
            return selected.slice(0, topK);
        }

        extractBestSentence(text, queryTokens) {
            const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
            if (sentences.length === 0) return text.slice(0, 180);
            if (queryTokens.length === 0) return sentences[0].slice(0, 220);
            let bestSentence = sentences[0]; let bestScore = -1;
            for (const sentence of sentences) {
                const lower = sentence.toLowerCase();
                const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                if (score > bestScore) { bestScore = score; bestSentence = sentence; }
            }
            return bestSentence.slice(0, 260);
        }

        buildAttachmentDigest(query, chunks, maxEntries = 14) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            const ranked = chunks.map(chunk => ({ ...chunk, score: this.calculateLocalRelevanceScore(chunk, queryTokens, [], []) }))
                .sort((a, b) => b.score - a.score);
            const top = ranked.slice(0, Math.ceil(maxEntries * 0.65));
            const ordered = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
            const coverage = this.pickEvenlyDistributed(ordered, Math.ceil(maxEntries * 0.4));
            const merged = this.mergeUniqueChunks(top, coverage, maxEntries);
            return merged.map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        buildCorpusDigest(query, chunks, maxEntries = 16) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            return chunks.slice(0, maxEntries).map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        getTopConnectedConcepts(limit = 10) {
            const conceptDocCounts = new Map();
            for (const [concept, links] of this.conceptIndex) {
                const uniqueDocs = new Set(links.map(link => link.filename));
                if (uniqueDocs.size > 1) conceptDocCounts.set(concept, uniqueDocs.size);
            }
            return Array.from(conceptDocCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([concept, docCount]) => ({ concept, docCount }));
        }
    }

    class CognitiveSynthesizer {
        constructor() {
            this.apiKey = localStorage.getItem('openai_api_key') || '';
            this.model = localStorage.getItem('openai_model') || 'gpt-4.1';
            this.conversationHistory = this.loadChatHistory();
            this.workingMemory = this.loadWorkingMemory();
            this.responseCache = this.loadResponseCache();
            this.completionTelemetry = this.loadCompletionTelemetry();
            this.__skipCoreStrictPostProcessing = false;
        }

        loadChatHistory() {
            const saved = localStorage.getItem('chat_history');
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }

        loadWorkingMemory() {
            const saved = localStorage.getItem('working_memory');
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }

        loadResponseCache() {
            const saved = localStorage.getItem(RESPONSE_CACHE_KEY);
            if (!saved) return new Map();
            try {
                const parsed = JSON.parse(saved);
                if (!Array.isArray(parsed)) return new Map();
                const entries = parsed
                    .filter(item => Array.isArray(item) && item.length === 2 && typeof item[0] === 'string' && item[1] && typeof item[1] === 'object')
                    .slice(-RESPONSE_CACHE_MAX_ENTRIES);
                return new Map(entries);
            } catch {
                return new Map();
            }
        }

        saveResponseCache() {
            const now = Date.now();
            const entries = Array.from(this.responseCache.entries())
                .filter(([, value]) => value && (now - Number(value.timestamp || 0)) <= RESPONSE_CACHE_TTL_MS)
                .slice(-RESPONSE_CACHE_MAX_ENTRIES);
            this.responseCache = new Map(entries);
            localStorage.setItem(RESPONSE_CACHE_KEY, JSON.stringify(entries));
        }

        loadCompletionTelemetry() {
            const saved = localStorage.getItem(COMPLETION_TELEMETRY_KEY);
            const defaults = {
                totalCalls: 0,
                cacheHits: 0,
                fallbackUses: 0,
                lastRequestedModel: '',
                lastServedModel: '',
                updatedAt: null
            };
            if (!saved) return defaults;
            try {
                const parsed = JSON.parse(saved);
                if (!parsed || typeof parsed !== 'object') return defaults;
                return {
                    totalCalls: Number(parsed.totalCalls || 0),
                    cacheHits: Number(parsed.cacheHits || 0),
                    fallbackUses: Number(parsed.fallbackUses || 0),
                    lastRequestedModel: String(parsed.lastRequestedModel || ''),
                    lastServedModel: String(parsed.lastServedModel || ''),
                    updatedAt: parsed.updatedAt || null
                };
            } catch {
                return defaults;
            }
        }

        saveCompletionTelemetry() {
            localStorage.setItem(COMPLETION_TELEMETRY_KEY, JSON.stringify(this.completionTelemetry || {}));
        }

        recordCompletionTelemetry({ cacheHit = false, fallbackUsed = false, requestedModel = '', servedModel = '' } = {}) {
            if (!this.completionTelemetry || typeof this.completionTelemetry !== 'object') {
                this.completionTelemetry = this.loadCompletionTelemetry();
            }
            this.completionTelemetry.totalCalls = Number(this.completionTelemetry.totalCalls || 0) + 1;
            if (cacheHit) this.completionTelemetry.cacheHits = Number(this.completionTelemetry.cacheHits || 0) + 1;
            if (fallbackUsed) this.completionTelemetry.fallbackUses = Number(this.completionTelemetry.fallbackUses || 0) + 1;
            this.completionTelemetry.lastRequestedModel = String(requestedModel || this.model || '');
            this.completionTelemetry.lastServedModel = String(servedModel || requestedModel || this.model || '');
            this.completionTelemetry.updatedAt = new Date().toISOString();
            this.saveCompletionTelemetry();
        }

        saveChatHistory() {
            const trimmed = this.conversationHistory.slice(-40);
            localStorage.setItem('chat_history', JSON.stringify(trimmed));
        }

        saveWorkingMemory() {
            const trimmed = this.workingMemory.slice(-18);
            localStorage.setItem('working_memory', JSON.stringify(trimmed));
        }

        clearHistory() {
            this.conversationHistory = [];
            this.workingMemory = [];
            localStorage.removeItem('chat_history');
            localStorage.removeItem('working_memory');
        }

        setApiKey(key) {
            this.apiKey = key;
            localStorage.setItem('openai_api_key', key);
        }

        setModel(model) {
            this.model = model;
            localStorage.setItem('openai_model', model);
        }

        hashString(value = '') {
            let hash = 2166136261;
            const text = String(value || '');
            for (let i = 0; i < text.length; i++) {
                hash ^= text.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            return (hash >>> 0).toString(16);
        }

        buildCompletionCacheKey(messages, payload = {}) {
            const signature = JSON.stringify({
                model: String(payload.model || this.model || ''),
                temperature: Number(payload.temperature ?? 0.25),
                top_p: Number(payload.top_p ?? 0.9),
                max_tokens: Number(payload.max_tokens ?? 2500),
                messages: (messages || []).map(msg => ({
                    role: String(msg?.role || ''),
                    content: String(msg?.content || '')
                }))
            });
            return `cc_v1_${this.hashString(signature)}`;
        }

        shouldUseCompletionCache(payload = {}) {
            const temperature = Number(payload.temperature ?? 0.25);
            return temperature <= 0.35;
        }

        getCachedCompletion(cacheKey) {
            if (!cacheKey || !this.responseCache.has(cacheKey)) return null;
            const entry = this.responseCache.get(cacheKey);
            if (!entry || typeof entry.response !== 'string') {
                this.responseCache.delete(cacheKey);
                return null;
            }
            const ageMs = Date.now() - Number(entry.timestamp || 0);
            if (!Number.isFinite(ageMs) || ageMs > RESPONSE_CACHE_TTL_MS) {
                this.responseCache.delete(cacheKey);
                return null;
            }
            return entry;
        }

        setCachedCompletion(cacheKey, responseText, modelUsed) {
            if (!cacheKey || !responseText) return;
            this.responseCache.set(cacheKey, {
                response: String(responseText),
                model: String(modelUsed || this.model || ''),
                timestamp: Date.now()
            });
            this.saveResponseCache();
        }

        buildModelFallbackChain(primaryModel) {
            const preferred = String(primaryModel || this.model || '').trim();
            const chain = [];
            for (const model of [preferred, ...MODEL_FALLBACK_ORDER]) {
                const name = String(model || '').trim();
                if (!name || chain.includes(name)) continue;
                chain.push(name);
            }
            return chain.length ? chain : [this.model];
        }

        isFallbackEligibleError(error) {
            const status = Number(error?.status);
            if (Number.isFinite(status) && ([408, 409, 429].includes(status) || status >= 500)) return true;
            const msg = String(error?.message || '').toLowerCase();
            return /rate limit|overloaded|temporar|timeout|timed out|network|failed to fetch|tokens per min|tpm|connection|econn|unavailable|gateway/.test(msg);
        }

        async requestCompletion(payload) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                let detail = 'API request failed';
                try {
                    const error = await response.json();
                    detail = error.error?.message || detail;
                } catch {
                    detail = `${detail} (HTTP ${response.status})`;
                }
                const err = new Error(detail);
                err.status = response.status;
                throw err;
            }
            const data = await response.json();
            return data.choices?.[0]?.message?.content || '';
        }

        buildInstructionProfile(query) {
            const lower = query.toLowerCase();
            const wordLimitMatch = query.match(/(\d{2,4})\s*words?/i);
            return {
                requestedFormat: /\btable\b/.test(lower) ? 'table' :
                    /\b(json)\b/.test(lower) ? 'json' :
                    /\b(bullet|bulleted|list|points)\b/.test(lower) ? 'bullet list' :
                    'structured prose',
                wantsSteps: /\b(step[- ]by[- ]step|steps)\b/.test(lower),
                wordLimit: wordLimitMatch ? parseInt(wordLimitMatch[1], 10) : null,
                strictSourceOnly: /\b(only use|based only|strictly from|from provided|from uploaded)\b/.test(lower),
                userIntent: lower
            };
        }

        getWorkingMemorySummary() {
            if (!this.workingMemory.length) return 'No prior working memory yet.';
            return this.workingMemory
                .slice(-6)
                .map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`)
                .join('\n');
        }

        rememberTurn(query, response) {
            const cleaned = response.replace(/\[Source:[^\]]+\]/g, '').replace(/\s+/g, ' ').trim();
            const gist = cleaned.slice(0, 380);
            this.workingMemory.push({
                timestamp: new Date().toISOString(),
                query: query.slice(0, 160),
                gist
            });
            this.saveWorkingMemory();
        }

        safeJsonParse(rawText) {
            if (!rawText) return null;
            const trimmed = rawText.trim();
            try { return JSON.parse(trimmed); } catch {}
            const fenced = trimmed.match(/```json\s*([\s\S]*?)\s*```/i) || trimmed.match(/```([\s\S]*?)```/);
            if (fenced?.[1]) {
                try { return JSON.parse(fenced[1]); } catch {}
            }
            const start = trimmed.indexOf('{');
            const end = trimmed.lastIndexOf('}');
            if (start >= 0 && end > start) {
                const candidate = trimmed.slice(start, end + 1);
                try { return JSON.parse(candidate); } catch { return null; }
            }
            return null;
        }

        heuristicPlan(query, instructionProfile = {}) {
            const normalized = query.replace(/\s+/g, ' ').trim();
            const clauses = normalized
                .split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|then)\b\s+)/i)
                .map(c => c.trim())
                .filter(c => c.length > 10);
            const subQuestions = clauses.length > 0 ? clauses.slice(0, 5) : [
                `What is the core answer to: ${normalized}?`,
                'What evidence supports the answer?',
                'What cross-document links strengthen confidence?'
            ];
            return {
                analysis_mode: 'hierarchical-rag',
                sub_questions: subQuestions,
                evidence_strategy: 'Retrieve broad evidence, then verify every claim with citations.',
                output_spec: {
                    format: instructionProfile.requestedFormat || 'structured prose',
                    step_by_step: !!instructionProfile.wantsSteps,
                    max_words: instructionProfile.wordLimit || null,
                    strict_source_only: !!instructionProfile.strictSourceOnly
                }
            };
        }

        normalizePlan(plan, fallback) {
            if (!plan || typeof plan !== 'object') return fallback;
            const subQuestions = Array.isArray(plan.sub_questions)
                ? plan.sub_questions.filter(q => typeof q === 'string' && q.trim().length > 0).slice(0, 6)
                : [];
            return {
                analysis_mode: typeof plan.analysis_mode === 'string' ? plan.analysis_mode : fallback.analysis_mode,
                sub_questions: subQuestions.length ? subQuestions : fallback.sub_questions,
                evidence_strategy: typeof plan.evidence_strategy === 'string' ? plan.evidence_strategy : fallback.evidence_strategy,
                output_spec: {
                    format: plan.output_spec?.format || fallback.output_spec.format,
                    step_by_step: typeof plan.output_spec?.step_by_step === 'boolean' ? plan.output_spec.step_by_step : fallback.output_spec.step_by_step,
                    max_words: Number.isFinite(plan.output_spec?.max_words) ? plan.output_spec.max_words : fallback.output_spec.max_words,
                    strict_source_only: typeof plan.output_spec?.strict_source_only === 'boolean'
                        ? plan.output_spec.strict_source_only
                        : fallback.output_spec.strict_source_only
                }
            };
        }

        shouldUseModelPlanner(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const wordCount = String(query || '').split(/\s+/).filter(Boolean).length;
            const complexSeparators = /[;:?]/.test(query) || /\b(and|also|plus|compare|contrast|timeline)\b/i.test(query);
            const largeCorpus = (corpusStats.numChunks || 0) > 120 || (corpusStats.numDocs || 0) > 10;
            const largeAttachment = (attachmentContext?.chunks?.length || 0) > 12;
            const constrainedFormat = instructionProfile.wantsSteps || instructionProfile.requestedFormat !== 'structured prose';
            return wordCount > 24 || complexSeparators || largeCorpus || largeAttachment || constrainedFormat;
        }

        async buildCognitivePlan(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const fallback = this.heuristicPlan(query, instructionProfile);
            if (!this.shouldUseModelPlanner(query, instructionProfile, corpusStats, attachmentContext)) return fallback;
            const plannerSystem = `You are a planning module for a strict citation-grounded RAG system.
Return ONLY valid JSON object with keys:
- analysis_mode (string)
- sub_questions (array of 2-6 strings)
- evidence_strategy (string)
- output_spec (object: format, step_by_step, max_words, strict_source_only)
No prose outside JSON.`;
            const plannerUser = `Question: ${query}
Corpus docs: ${corpusStats.numDocs || 0}
Corpus chunks: ${corpusStats.numChunks || 0}
Attachment present: ${attachmentContext ? 'yes' : 'no'}
Requested format: ${instructionProfile.requestedFormat || 'structured prose'}
Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
Word limit: ${instructionProfile.wordLimit || 'none'}
Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}`;
            try {
                const raw = await this.callCompletion([
                    { role: 'system', content: plannerSystem },
                    { role: 'user', content: plannerUser }
                ], { temperature: 0.1, max_tokens: 420, top_p: 0.9 });
                const parsed = this.safeJsonParse(raw);
                return this.normalizePlan(parsed, fallback);
            } catch {
                return fallback;
            }
        }

        estimateChunkChars(chunks = []) {
            return chunks.reduce((sum, chunk) => sum + (chunk.text?.length || 0), 0);
        }

        shouldUseMultiPass(relevantChunks, attachmentContext = null, corpusStats = {}, plan = null) {
            const corpusChars = this.estimateChunkChars(relevantChunks);
            const attachmentChars = this.estimateChunkChars(attachmentContext?.chunks || []);
            const totalChunks = (relevantChunks?.length || 0) + (attachmentContext?.chunks?.length || 0);
            const planBreadth = plan?.sub_questions?.length || 0;
            return (
                totalChunks >= MULTIPASS_CHUNK_THRESHOLD ||
                (corpusChars + attachmentChars) >= MULTIPASS_CONTEXT_CHAR_THRESHOLD ||
                (corpusStats.numChunks || 0) > 260 ||
                (planBreadth >= 5 && totalChunks >= 10)
            );
        }

        dedupeChunks(chunks = []) {
            const seen = new Set();
            const deduped = [];
            for (const chunk of chunks) {
                const key = chunk.id || `${chunk.filename}:${chunk.index}`;
                if (!key || seen.has(key)) continue;
                seen.add(key);
                deduped.push(chunk);
            }
            return deduped;
        }

        buildEvidenceBatches(relevantChunks, attachmentContext = null, maxChars = MAP_PASS_CONTEXT_BUDGET, maxBatches = MAX_MAP_PASSES) {
            const corpusTagged = (relevantChunks || []).map(chunk => ({ ...chunk, _scope: 'corpus' }));
            const attachmentTagged = (attachmentContext?.chunks || []).map(chunk => ({ ...chunk, _scope: 'attachment' }));
            const allChunks = this.dedupeChunks([...attachmentTagged, ...corpusTagged]);
            const batches = [];
            let currentBatch = [];
            let currentChars = 0;
            for (const chunk of allChunks) {
                const text = chunk.text || '';
                const blockSize = text.length + 220;
                if (currentBatch.length > 0 && currentChars + blockSize > maxChars) {
                    batches.push(currentBatch);
                    currentBatch = [];
                    currentChars = 0;
                }
                currentBatch.push(chunk);
                currentChars += blockSize;
                if (batches.length >= maxBatches) break;
            }
            if (currentBatch.length > 0 && batches.length < maxBatches) batches.push(currentBatch);
            return batches.slice(0, maxBatches);
        }

        formatEvidenceBatch(batch = [], label = '') {
            const lines = [`## ${label}`];
            for (const chunk of batch) {
                const page = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const scopeLabel = chunk._scope === 'attachment' ? 'ATTACHMENT' : 'CORPUS';
                lines.push(`### [${scopeLabel}] ${chunk.filename} (${page})`);
                lines.push((chunk.text || '').slice(0, 3000));
            }
            return lines.join('\n\n');
        }

        formatPlanForContext(plan) {
            if (!plan) return '';
            const subQuestions = (plan.sub_questions || []).map((q, i) => `${i + 1}. ${q}`).join('\n');
            return `## COGNITIVE PLAN
Analysis mode: ${plan.analysis_mode || 'hierarchical-rag'}
Evidence strategy: ${plan.evidence_strategy || 'N/A'}
Sub-questions:
${subQuestions || '1. Answer the user query directly.'}

Output spec:
- Format: ${plan.output_spec?.format || 'structured prose'}
- Step-by-step: ${plan.output_spec?.step_by_step ? 'yes' : 'no'}
- Max words: ${plan.output_spec?.max_words || 'none'}
- Strict source only: ${plan.output_spec?.strict_source_only ? 'yes' : 'no'}`;
        }

        async runMapPhase(query, plan, evidenceBatches) {
            const mapNotes = [];
            for (let i = 0; i < evidenceBatches.length; i++) {
                const batch = evidenceBatches[i];
                const batchContext = this.formatEvidenceBatch(batch, `EVIDENCE BATCH ${i + 1}/${evidenceBatches.length}`);
                const mapPrompt = `Question: ${query}

Plan sub-questions:
${(plan.sub_questions || []).map((q, idx) => `${idx + 1}. ${q}`).join('\n')}

Extract the highest-value findings from this batch only.
Rules:
- Use concise bullet points.
- Include only findings supported by this batch.
- Every bullet must include citation in exact format:
  [Source: filename, page X, "brief relevant quote"]
- End with one line: "Batch confidence: High/Medium/Low"`;
                const mapMessages = [
                    { role: 'system', content: 'You are an evidence extractor for long-context RAG map-reduce. Only use the provided batch. Do not generalize beyond it.' },
                    { role: 'user', content: `${batchContext}\n\n${mapPrompt}` }
                ];
                let note = '';
                try {
                    note = await this.callCompletion(mapMessages, { temperature: 0.1, max_tokens: MAP_PHASE_MAX_TOKENS, top_p: 0.85 });
                } catch {
                    note = `- Map pass ${i + 1} unavailable due to transient model error.`;
                }
                mapNotes.push({ batchIndex: i + 1, note });
            }
            return mapNotes;
        }

        formatMapNotes(mapNotes = []) {
            if (!mapNotes.length) return '';
            const blocks = mapNotes.map(item => `### MAP NOTE ${item.batchIndex}\n${item.note}`);
            return `## MAP-REDUCE EVIDENCE NOTES\n${blocks.join('\n\n')}`;
        }

        estimateTokens(text = '') {
            return Math.ceil(String(text || '').length / 4);
        }

        estimateMessagesTokens(messages = []) {
            return (messages || []).reduce((sum, msg) => {
                return sum + this.estimateTokens(msg?.content || '') + 10;
            }, 0);
        }

        isTpmLimitError(error) {
            const msg = String(error?.message || error || '');
            return /tokens per min|TPM|Request too large/i.test(msg);
        }

        truncateSection(section, maxChars) {
            const text = String(section || '');
            if (!text || text.length <= maxChars) return text;
            const clipped = text.slice(0, Math.max(800, maxChars - 220));
            return `${clipped}\n\n[Section truncated for token budget safety.]`;
        }

        getSectionCharCap(section) {
            if (!section) return 6000;
            if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) return 24000;
            if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) return 11000;
            if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) return 12000;
            if (section.startsWith('## FULL-CORPUS REDUCE SYNTHESIS')) return 5000;
            if (section.startsWith('## CONTRADICTION CHECK')) return 4200;
            if (section.startsWith('## MAP-REDUCE EVIDENCE NOTES')) return 8000;
            if (section.startsWith('## DOCUMENT MEMORY BLOCKS')) return 7000;
            if (section.startsWith('## ATTACHMENT MEMORY (FULL FILE)')) return 4500;
            if (section.startsWith('## CORPUS DIGEST')) return 4000;
            if (section.startsWith('## CROSS-DOCUMENT CONCEPT BRIDGES')) return 3000;
            if (section.startsWith('## COGNITIVE PLAN')) return 2600;
            return 5000;
        }

        sectionPriority(section) {
            if (!section) return 9;
            if (section.startsWith('## COGNITIVE PLAN')) return 1;
            if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) return 1;
            if (section.startsWith('## FULL-CORPUS REDUCE SYNTHESIS')) return 2;
            if (section.startsWith('## CONTRADICTION CHECK')) return 2;
            if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) return 3;
            if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) return 3;
            if (section.startsWith('## MAP-REDUCE EVIDENCE NOTES')) return 4;
            if (section.startsWith('## CROSS-DOCUMENT CONCEPT BRIDGES')) return 5;
            if (section.startsWith('## DOCUMENT MEMORY BLOCKS')) return 6;
            if (section.startsWith('## ATTACHMENT MEMORY (FULL FILE)')) return 7;
            if (section.startsWith('## CORPUS DIGEST')) return 8;
            return 9;
        }

        applyContextBudget(contextSections = [], tokenBudget = TPM_CONTEXT_TOKEN_BUDGET) {
            let sections = (contextSections || [])
                .map(section => this.truncateSection(section, this.getSectionCharCap(section)))
                .filter(Boolean);

            const calcTokens = () => this.estimateTokens(sections.join('\n\n'));
            let totalTokens = calcTokens();

            // Drop lower-priority sections until within budget.
            while (sections.length > 2 && totalTokens > tokenBudget) {
                let dropIdx = -1;
                let worstPriority = -1;
                for (let i = 0; i < sections.length; i++) {
                    const p = this.sectionPriority(sections[i]);
                    if (p > worstPriority) {
                        worstPriority = p;
                        dropIdx = i;
                    }
                }
                if (dropIdx < 0 || worstPriority <= 3) break;
                sections.splice(dropIdx, 1);
                totalTokens = calcTokens();
            }

            // If still too large, compress key long sections.
            if (totalTokens > tokenBudget) {
                sections = sections.map(section => {
                    if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) {
                        return this.truncateSection(section, 15000);
                    }
                    if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) {
                        return this.truncateSection(section, 8500);
                    }
                    if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) {
                        return this.truncateSection(section, 7000);
                    }
                    return section;
                });
                totalTokens = calcTokens();
            }

            return {
                sections,
                context: sections.join('\n\n'),
                tokenBudget,
                estimatedTokens: totalTokens
            };
        }

        countCitations(text) {
            return (text.match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }

        tokenizeForDiagnostics(text) {
            return String(text || '').toLowerCase().replace(/[^\w\s-]/g, ' ')
                .split(/\s+/).filter(token => token.length > 2 && !DIAGNOSTIC_STOP_WORDS.has(token));
        }

        normalizeFilename(name) {
            return String(name || '').trim().toLowerCase();
        }

        extractCitations(text) {
            const regex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citations = [];
            let match;
            while ((match = regex.exec(text)) !== null) {
                citations.push({
                    filename: String(match[1] || '').trim(),
                    page: String(match[2] || '').trim(),
                    quote: String(match[3] || '').trim()
                });
            }
            return citations;
        }

        buildSourceCaches(sources = []) {
            return (sources || []).map(source => {
                const textLower = String(source.text || '').toLowerCase();
                return {
                    filename: this.normalizeFilename(source.filename),
                    textLower,
                    tokenSet: new Set(this.tokenizeForDiagnostics(textLower))
                };
            });
        }

        getTokenOverlapRatio(tokens, tokenSet) {
            if (!tokens.length) return 0;
            let matches = 0;
            for (const token of tokens) if (tokenSet.has(token)) matches++;
            return matches / tokens.length;
        }

        computeClaimSupportScore(claim, sourceCaches = []) {
            const claimTokens = this.tokenizeForDiagnostics(claim);
            if (!claimTokens.length || sourceCaches.length === 0) return 0;
            let best = 0;
            for (const source of sourceCaches) {
                const overlap = this.getTokenOverlapRatio(claimTokens, source.tokenSet);
                if (overlap > best) best = overlap;
                if (best >= 0.98) break;
            }
            return best;
        }

        evaluateCitationPrecision(citations = [], sourceCaches = []) {
            if (citations.length === 0) return { total: 0, valid: 0, precision: 0 };
            let valid = 0;
            for (const citation of citations) {
                const citedName = this.normalizeFilename(citation.filename);
                const quoteLower = citation.quote.toLowerCase();
                const quoteTokens = this.tokenizeForDiagnostics(quoteLower);
                const filenameMatches = sourceCaches.filter(source =>
                    source.filename === citedName ||
                    source.filename.includes(citedName) ||
                    citedName.includes(source.filename)
                );
                if (filenameMatches.length === 0) continue;
                let quoteSupported = false;
                for (const source of filenameMatches) {
                    if (quoteLower.length >= 8 && source.textLower.includes(quoteLower)) {
                        quoteSupported = true; break;
                    }
                    if (quoteTokens.length > 0) {
                        const overlap = this.getTokenOverlapRatio(quoteTokens, source.tokenSet);
                        if (overlap >= 0.55) { quoteSupported = true; break; }
                    }
                }
                if (quoteSupported) valid++;
            }
            return { total: citations.length, valid, precision: citations.length ? (valid / citations.length) : 0 };
        }

        isLikelyClaimLine(line) {
            const cleaned = line.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim();
            if (cleaned.length < 28) return false;
            if (/^\[Source:/i.test(cleaned)) return false;
            if (/^#{1,6}\s+/.test(cleaned)) return false;
            return /[a-zA-Z]/.test(cleaned);
        }

        extractClaimLines(text) {
            const lines = String(text || '').split('\n').map(line => line.trim()).filter(Boolean);
            const claims = lines
                .map(line => line.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim())
                .filter(line => this.isLikelyClaimLine(line));
            if (claims.length > 0) return claims.slice(0, 40);
            return String(text || '').split(/(?<=[.!?])\s+/)
                .map(sentence => sentence.trim()).filter(sentence => sentence.length > 28).slice(0, 40);
        }

        buildClaimCitationDiagnostics(responseText, sources = []) {
            const sourceCaches = this.buildSourceCaches(sources);
            const claims = this.extractClaimLines(responseText);
            const citations = this.extractCitations(responseText);
            const citationPrecision = this.evaluateCitationPrecision(citations, sourceCaches);
            const claimEvaluations = claims.map(claim => {
                const hasCitation = /\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(claim);
                const supportScore = this.computeClaimSupportScore(claim, sourceCaches);
                return { claim, hasCitation, supportScore };
            });
            const totalClaims = claimEvaluations.length;
            const citedClaims = claimEvaluations.filter(item => item.hasCitation).length;
            const supportedClaims = claimEvaluations.filter(item => item.supportScore >= 0.22).length;

            const directCoverage = totalClaims ? (citedClaims / totalClaims) : 1;
            const citationDensityCoverage = totalClaims ? Math.min(1, citations.length / Math.max(1, Math.ceil(totalClaims * 0.75))) : 1;
            const claimCitationCoverage = Math.max(directCoverage, citationDensityCoverage * 0.92);
            const claimSupportRatio = totalClaims ? (supportedClaims / totalClaims) : 1;
            const weakClaims = claimEvaluations
                .filter(item => !item.hasCitation || item.supportScore < 0.22)
                .slice(0, 5)
                .map(item => `- ${item.claim.slice(0, 180)} (citation=${item.hasCitation ? 'yes' : 'no'}, support=${item.supportScore.toFixed(2)})`);

            const needsRepair = (
                (citations.length === 0 && totalClaims > 0) ||
                (totalClaims >= 3 && claimCitationCoverage < CLAIM_CITATION_TARGET && citations.length < Math.max(2, Math.round(totalClaims * 0.35))) ||
                (totalClaims >= 3 && claimSupportRatio < CLAIM_SUPPORT_TARGET && citationPrecision.precision < CITATION_PRECISION_TARGET)
            );
            return {
                totalClaims,
                citedClaims,
                supportedClaims,
                claimCitationCoverage,
                claimSupportRatio,
                citationPrecision: citationPrecision.precision,
                citationCount: citations.length,
                weakClaims,
                needsRepair
            };
        }

        maybeViolatesOutputContract(text, instructionProfile = {}) {
            const citationCount = this.countCitations(text);
            if (citationCount === 0) return true;
            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                if (!(trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.includes('```json'))) return true;
            }
            if (instructionProfile.requestedFormat === 'table') {
                if (!/\|.+\|/.test(text)) return true;
            }
            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                if (words > Math.ceil(instructionProfile.wordLimit * 1.25)) return true;
            }
            return false;
        }

        async verifyAndRepairAnswer(query, answer, instructionProfile, contextSnippet, diagnostics = null) {
            const diagnosticsBlock = diagnostics ? `
Claim/citation diagnostics:
- Total claims: ${diagnostics.totalClaims}
- Claim citation coverage: ${(diagnostics.claimCitationCoverage * 100).toFixed(1)}%
- Claim support ratio: ${(diagnostics.claimSupportRatio * 100).toFixed(1)}%
- Citation precision: ${(diagnostics.citationPrecision * 100).toFixed(1)}%
Weak claim samples:
${(diagnostics.weakClaims || []).join('\n') || '- none'}
` : '';
            const verifierMessages = [
                {
                    role: 'system',
                    content: `You are a response verifier for strict RAG answers.
If the answer violates instructions or lacks proper citations, repair it.
Always preserve factual grounding and keep citations in format:
[Source: filename, page X, "brief relevant quote"].
Return only the repaired answer text.`
                },
                {
                    role: 'user',
                    content: `Question: ${query}
Instruction profile:
- Format: ${instructionProfile.requestedFormat}
- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
- Word limit: ${instructionProfile.wordLimit || 'none'}
- Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}

Evidence snippet:
${contextSnippet}

${diagnosticsBlock}

Answer to verify/repair:
${answer}`
                }
            ];
            const repaired = await this.callCompletion(verifierMessages, {
                temperature: 0.1,
                max_tokens: 2200,
                top_p: 0.9
            });
            return repaired?.trim() ? repaired : answer;
        }

        evaluateCoreCognitiveStructure(text, instructionProfile = {}) {
            const value = String(text || '');
            const lower = value.toLowerCase();
            const reasons = [];
            const hasMentalModel = /(^|\n)\s*#{1,3}\s*mental model\b/i.test(value);
            const hasEvidenceSection = /(^|\n)\s*#{1,3}\s*(evidence-based answer|evidence-based analysis|evidence-based expert analysis|evidence synthesis)\b/i.test(value) ||
                /\bevidence[- ]based\b/.test(lower);
            const hasUncertaintySection = /(^|\n)\s*#{1,3}\s*uncertainties?\s*&\s*missing information\b/i.test(value) ||
                /uncertaint|missing information|evidence gap|cannot fully confirm/i.test(lower);
            if (!hasMentalModel) reasons.push('Missing "Mental Model" section.');
            if (!hasEvidenceSection) reasons.push('Missing explicit evidence-based analysis section.');
            if (!hasUncertaintySection) reasons.push('Missing "Uncertainties & Missing Information" section.');
            if (instructionProfile?.decisionMode) {
                const hasOptions = /(^|\n)\s*#{1,3}\s*(options?\s*&\s*trade-?offs?|trade-?offs?|options?)\b/i.test(value);
                const hasRecommendation = /(^|\n)\s*#{1,3}\s*recommendation\b/i.test(value) || /\brecommend(?:ed|ation)?\b/i.test(lower);
                const hasRiskSection = /(^|\n)\s*#{1,3}\s*risks?\b/i.test(value) || /\brisk(s)?\b/i.test(lower);
                if (!hasOptions) reasons.push('Decision analysis is missing "Options & Trade-offs".');
                if (!hasRecommendation) reasons.push('Decision analysis is missing "Recommendation".');
                if (!hasRiskSection) reasons.push('Decision analysis is missing explicit risk section.');
            }
            return { passed: reasons.length === 0, reasons };
        }

        async runCoreStrictPostProcessing(
            query,
            responseText,
            instructionProfile = {},
            sources = [],
            contextSnippet = ''
        ) {
            let response = String(responseText || '').trim();
            if (!response) {
                return {
                    response,
                    citationCount: 0,
                    claimDiagnostics: this.buildClaimCitationDiagnostics('', sources),
                    meta: { attempted: false, passed: false, reasons: ['Response was empty.'] }
                };
            }

            if (typeof this.superBrainNormalizeCitationSyntax === 'function') {
                response = this.superBrainNormalizeCitationSyntax(response);
            }
            let citationCount = this.countCitations(response);
            let claimDiagnostics = this.buildClaimCitationDiagnostics(response, sources);
            let structureGate = this.evaluateCoreCognitiveStructure(response, instructionProfile);
            const sourceCount = Array.isArray(sources) ? sources.length : 0;
            const minCitationTarget = sourceCount >= 10 ? 4 : sourceCount >= 4 ? 2 : sourceCount > 0 ? 1 : 0;
            const needsRepair = (
                !structureGate.passed ||
                citationCount < minCitationTarget ||
                claimDiagnostics.needsRepair
            );
            if (!needsRepair) {
                return {
                    response,
                    citationCount,
                    claimDiagnostics,
                    meta: { attempted: false, passed: true, reasons: [] }
                };
            }

            const reasons = [...structureGate.reasons];
            if (citationCount < minCitationTarget) reasons.push(`Citation coverage is below target (${citationCount}/${minCitationTarget}).`);
            if (claimDiagnostics.needsRepair) reasons.push('Claim-level citation diagnostics indicate weak grounding.');
            const rewriteInstruction = [
                'STRICT COGNITIVE POST-PROCESSING GATE (MANDATORY REWRITE)',
                'Rewrite the answer into this required structure:',
                '1) Mental Model',
                '2) Evidence-Based Answer',
                '3) Uncertainties & Missing Information',
                'Rules:',
                '- Every factual claim must include citation format [Source: filename, page X, "brief relevant quote"].',
                '- Do not summarize only; show reasoning and evidence integration.',
                '- Do not treat prior conversation memory as evidence.',
                `- Minimum citation target: ${minCitationTarget}.`,
                `- Repair reasons: ${reasons.join(' | ') || 'N/A'}`
            ].join('\n');

            const repaired = await this.verifyAndRepairAnswer(
                query,
                `${response}\n\n${rewriteInstruction}`,
                instructionProfile,
                contextSnippet,
                claimDiagnostics
            );
            if (repaired?.trim()) {
                response = repaired.trim();
                if (typeof this.superBrainNormalizeCitationSyntax === 'function') {
                    response = this.superBrainNormalizeCitationSyntax(response);
                }
            }
            citationCount = this.countCitations(response);
            claimDiagnostics = this.buildClaimCitationDiagnostics(response, sources);
            structureGate = this.evaluateCoreCognitiveStructure(response, instructionProfile);
            return {
                response,
                citationCount,
                claimDiagnostics,
                meta: {
                    attempted: true,
                    passed: structureGate.passed && citationCount >= minCitationTarget && !claimDiagnostics.needsRepair,
                    reasons: structureGate.reasons
                }
            };
        }

        getSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
            const numDocs = corpusStats.numDocs || 0;
            const numChunks = corpusStats.numChunks || 0;
            const formatReq = instructionProfile.requestedFormat || 'structured prose';
            const stepReq = instructionProfile.wantsSteps ? 'Yes' : 'No';
            const wordLimit = instructionProfile.wordLimit ? `${instructionProfile.wordLimit} words` : 'No explicit limit';
            const sourceOnly = instructionProfile.strictSourceOnly ? 'Yes - strictly source-grounded.' : 'Ground all factual claims in provided sources.';
            return `You are a COGNITIVE SYNTHESIS ENGINE.

You are given:
1) Retrieved evidence chunks from uploaded documents.
2) Document-memory summaries generated from full uploaded files (outline, key concepts, salient sentences).
3) Optional temporary attachment memory for one-time analysis.

IMPORTANT ACCESS RULE:
- If context is provided, NEVER claim you cannot access the documents.
- Never mention "training cutoff" unless user explicitly asks about model knowledge limits.
- If evidence is missing, say: "Based on the available documents, I cannot fully confirm..."

Human-like synthesis mode (inspired by brain-mimicking LLM research):
- Working-memory loop: obey the current instruction contract precisely.
- Semantic-memory loop: use document-memory summaries to maintain long-range context.
- Retrieval loop: verify claims against cited chunks before finalizing.
- Planner loop: decompose complex queries into sub-questions before writing.
- Map-reduce loop: aggregate distributed evidence across long contexts.
- Verifier loop: self-check instruction compliance and citation completeness.

Corpus snapshot:
- Documents: ${numDocs}
- Chunks: ${numChunks}

Instruction contract:
- Output format: ${formatReq}
- Step-by-step required: ${stepReq}
- Length target: ${wordLimit}
- Source policy: ${sourceOnly}

MANDATORY CITATION FORMAT:
[Source: filename, page X, "brief relevant quote"]

MAXIMIZATION GOAL:
- Deliver complete, high-recall, high-precision synthesis across all provided sources.
- Behave like a "super-analyst" only through better retrieval + planning + verification.
- Never invent evidence, never claim hidden access, never skip citations for factual claims.

CONTEXT:
${context}

WORKING MEMORY FROM PRIOR TURNS:
${workingMemorySummary}
`;
        }

        formatDocumentMemories(documentMemories = []) {
            if (!documentMemories.length) return '';
            const blocks = documentMemories.slice(0, 10).map((doc, idx) => {
                const memory = doc.memory || {};
                const concepts = (memory.keyConcepts || []).slice(0, 10).join(', ') || 'N/A';
                const outline = (memory.outline || []).slice(0, 8).join(' | ') || 'N/A';
                const synopsis = memory.synopsis || (memory.salientSentences || []).slice(0, 3).join(' ');
                return `### Document Memory ${idx + 1}: ${doc.filename}
- Word count: ${memory.wordCount || 'N/A'}
- Reading time (min): ${memory.readingTimeMinutes || 'N/A'}
- Outline: ${outline}
- Key concepts: ${concepts}
- Synopsis: ${synopsis}`;
            });
            return `## DOCUMENT MEMORY BLOCKS (generated from full files)\n${blocks.join('\n\n')}`;
        }

        formatContext(chunks, maxChars = MAX_CONTEXT_CHARS) {
            if (!chunks || chunks.length === 0) {
                return { contextText: 'No relevant documents found in the corpus.', included: 0, omitted: 0 };
            }
            let totalChars = 0;
            const includedBlocks = [];
            let omitted = 0;
            for (const chunk of chunks) {
                const sectionLabel = chunk.section ? `, Section: ${chunk.section}` : '';
                const pageLabel = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const block = `### Evidence: ${chunk.filename} (${pageLabel}${sectionLabel})
${chunk.text}`;
                if (totalChars + block.length > maxChars) { omitted++; continue; }
                includedBlocks.push(block);
                totalChars += block.length;
            }
            if (includedBlocks.length === 0 && chunks.length > 0) {
                const fallback = chunks[0];
                includedBlocks.push(`### Evidence: ${fallback.filename} (Page ${fallback.page || 'N/A'})
${fallback.text.slice(0, Math.min(2500, fallback.text.length))}`);
                omitted = Math.max(0, chunks.length - 1);
            }
            return { contextText: includedBlocks.join('\n\n---\n\n'), included: includedBlocks.length, omitted };
        }

        looksLikeContextRefusal(responseText) {
            if (!responseText) return false;
            return REFUSAL_PATTERNS.some(pattern => pattern.test(responseText));
        }

        buildUserPrompt(query, instructionProfile) {
            const lines = [
                `User question:\n${query}`,
                '',
                'Please obey this response contract:',
                `- Format: ${instructionProfile.requestedFormat}`,
                `- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}`,
                `- Word limit: ${instructionProfile.wordLimit ? instructionProfile.wordLimit : 'no strict limit'}`,
                `- Source-only strictness: ${instructionProfile.strictSourceOnly ? 'strict' : 'grounded, with clear uncertainty if missing'}`
            ];
            return lines.join('\n');
        }

        async callCompletion(messages, overrides = {}) {
            const opts = { ...(overrides || {}) };
            const bypassCache = !!opts.bypass_cache || !!opts.bypassCache;
            const allowFallback = opts.allow_fallback !== false && opts.allowFallback !== false;
            delete opts.bypass_cache;
            delete opts.bypassCache;
            delete opts.allow_fallback;
            delete opts.allowFallback;

            const payload = {
                model: this.model,
                messages,
                temperature: 0.25,
                max_tokens: 2500,
                top_p: 0.9,
                ...opts
            };
            const requestedModel = String(payload.model || this.model || '');
            const useCache = !bypassCache && this.shouldUseCompletionCache(payload);
            const cacheKey = useCache ? this.buildCompletionCacheKey(messages, payload) : null;
            if (cacheKey) {
                const cached = this.getCachedCompletion(cacheKey);
                if (cached) {
                    this.recordCompletionTelemetry({
                        cacheHit: true,
                        requestedModel,
                        servedModel: cached.model || requestedModel
                    });
                    return cached.response;
                }
            }

            const chain = allowFallback ? this.buildModelFallbackChain(requestedModel) : [requestedModel];
            let lastError = null;
            for (let idx = 0; idx < chain.length; idx++) {
                const modelCandidate = chain[idx];
                try {
                    const responseText = await this.requestCompletion({ ...payload, model: modelCandidate });
                    if (cacheKey) this.setCachedCompletion(cacheKey, responseText, modelCandidate);
                    this.recordCompletionTelemetry({
                        cacheHit: false,
                        fallbackUsed: idx > 0,
                        requestedModel,
                        servedModel: modelCandidate
                    });
                    return responseText;
                } catch (error) {
                    lastError = error;
                    const canFallback = idx < chain.length - 1 && this.isFallbackEligibleError(error);
                    if (!canFallback) throw error;
                }
            }
            throw lastError || new Error('Completion failed with all fallback models.');
        }

        async synthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
            if (!this.apiKey) throw new Error('API key not configured. Please set your OpenAI API key in the Admin Panel.');
            const instructionProfile = this.buildInstructionProfile(query);
            const workingMemorySummary = this.getWorkingMemorySummary();
            const cognitivePlan = await this.buildCognitivePlan(query, instructionProfile, corpusStats, attachmentContext);
            const useMultiPass = this.shouldUseMultiPass(relevantChunks, attachmentContext, corpusStats, cognitivePlan);

            const contextSections = [];
            contextSections.push(this.formatPlanForContext(cognitivePlan));
            if (attachmentContext?.memory) {
                const m = attachmentContext.memory;
                contextSections.push(`## ATTACHMENT MEMORY (FULL FILE)
File: ${attachmentContext.name}
Word count: ${m.wordCount || 'N/A'}
Outline: ${(m.outline || []).slice(0, 10).join(' | ') || 'N/A'}
Key concepts: ${(m.keyConcepts || []).slice(0, 12).join(', ') || 'N/A'}
Synopsis: ${m.synopsis || (m.salientSentences || []).slice(0, 4).join(' ')}`);
            }
            if (attachmentContext?.digest) {
                contextSections.push(`## ATTACHMENT WIDE-COVERAGE DIGEST\n${attachmentContext.digest}`);
            }
            if (corpusStats.documentMemories && corpusStats.documentMemories.length > 0) {
                contextSections.push(this.formatDocumentMemories(corpusStats.documentMemories));
            }
            if (corpusStats.connectedConcepts && corpusStats.connectedConcepts.length > 0) {
                const conceptSummary = corpusStats.connectedConcepts.slice(0, 10)
                    .map(item => `- "${item.concept}" appears in ${item.docCount} documents`)
                    .join('\n');
                contextSections.push(`## CROSS-DOCUMENT CONCEPT BRIDGES\n${conceptSummary}`);
            }
            if (corpusStats.corpusDigest) contextSections.push(`## CORPUS DIGEST\n${corpusStats.corpusDigest}`);

            let mapNotes = [];
            const hasFullCorpusSweep = !!(corpusStats.fullCorpusSweep && Array.isArray(corpusStats.fullCorpusSweep.docSweeps));
            const shouldRunModelMapPass = useMultiPass && !hasFullCorpusSweep;
            if (shouldRunModelMapPass) {
                const modelMapPassCap = String(this.model || '').toLowerCase().includes('gpt-4.1') ? 3 : MAX_MAP_PASSES;
                const evidenceBatches = this.buildEvidenceBatches(relevantChunks, attachmentContext, MAP_PASS_CONTEXT_BUDGET, modelMapPassCap);
                if (evidenceBatches.length > 0) {
                    mapNotes = await this.runMapPhase(query, cognitivePlan, evidenceBatches);
                    if (mapNotes.length > 0) contextSections.push(this.formatMapNotes(mapNotes));
                }
            }

            const dynamicContextBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.58) : MAX_CONTEXT_CHARS;
            const formattedContext = this.formatContext(relevantChunks, dynamicContextBudget);
            contextSections.push(`## RETRIEVED EVIDENCE CHUNKS
Included chunks: ${formattedContext.included}
Omitted due to context budget: ${formattedContext.omitted}

${formattedContext.contextText}`);

            if (attachmentContext?.chunks && attachmentContext.chunks.length > 0) {
                const attachmentBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.24) : Math.floor(MAX_CONTEXT_CHARS * 0.35);
                const attachmentEvidence = this.formatContext(attachmentContext.chunks, attachmentBudget);
                contextSections.push(`## ATTACHMENT QUERY-SPECIFIC EVIDENCE
Included chunks: ${attachmentEvidence.included}
Omitted due to context budget: ${attachmentEvidence.omitted}

${attachmentEvidence.contextText}`);
            }

            const budgetedContext = this.applyContextBudget(contextSections, TPM_CONTEXT_TOKEN_BUDGET);
            const context = budgetedContext.context;
            const systemPrompt = this.getSystemPrompt(context, corpusStats, instructionProfile, workingMemorySummary);
            const userPrompt = this.buildUserPrompt(query, instructionProfile);
            let messages = [
                { role: 'system', content: systemPrompt },
                ...this.conversationHistory.slice(-10),
                { role: 'user', content: userPrompt }
            ];

            const estimatedPromptTokens = this.estimateMessagesTokens(messages);
            const finalMaxTokens = estimatedPromptTokens > 9000 ? 1100 :
                estimatedPromptTokens > 7500 ? 1400 :
                estimatedPromptTokens > 6000 ? 1700 : 2200;

            let assistantMessage = '';
            try {
                assistantMessage = await this.callCompletion(messages, { max_tokens: finalMaxTokens });
            } catch (error) {
                if (!this.isTpmLimitError(error)) throw error;

                const retryBudgetedContext = this.applyContextBudget(contextSections, TPM_RETRY_CONTEXT_TOKEN_BUDGET);
                const retrySystemPrompt = this.getSystemPrompt(retryBudgetedContext.context, corpusStats, instructionProfile, workingMemorySummary);
                messages = [
                    { role: 'system', content: retrySystemPrompt },
                    ...this.conversationHistory.slice(-6),
                    { role: 'user', content: userPrompt }
                ];
                assistantMessage = await this.callCompletion(messages, {
                    max_tokens: Math.min(1200, finalMaxTokens),
                    temperature: 0.2
                });
            }
            if ((relevantChunks.length > 0 || (attachmentContext?.chunks?.length || 0) > 0) && this.looksLikeContextRefusal(assistantMessage)) {
                const retryMessages = [
                    ...messages,
                    { role: 'assistant', content: assistantMessage },
                    { role: 'user', content: 'You incorrectly stated you cannot access documents. Re-answer using the provided evidence and document-memory blocks above. Do not mention training cutoff unless explicitly asked. Keep strict citations.' }
                ];
                assistantMessage = await this.callCompletion(retryMessages, { temperature: 0.15, max_tokens: Math.min(1200, finalMaxTokens) });
            }

            let sources = [...(relevantChunks || [])];
            if (attachmentContext?.chunks) {
                const attachmentSources = attachmentContext.chunks.map(chunk => ({
                    ...chunk,
                    source: attachmentContext.name,
                    filename: attachmentContext.name,
                    isTemporary: true
                }));
                sources = [...attachmentSources, ...sources];
            }

            const availableSourceCount = sources.length;
            let citationCount = this.countCitations(assistantMessage);
            const minimumCitationTarget = availableSourceCount >= 10 ? 4 : availableSourceCount >= 4 ? 2 : availableSourceCount > 0 ? 1 : 0;
            let claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            const strictRepairNeeded = (
                this.maybeViolatesOutputContract(assistantMessage, instructionProfile) ||
                (availableSourceCount > 0 && citationCount < minimumCitationTarget)
            );
            const softRepairNeeded = (
                claimDiagnostics.needsRepair &&
                (claimDiagnostics.citationCount === 0 || claimDiagnostics.citationPrecision < 0.42 || claimDiagnostics.claimSupportRatio < 0.32)
            );
            if (strictRepairNeeded || softRepairNeeded) {
                const verifierSnippet = [
                    this.formatPlanForContext(cognitivePlan),
                    mapNotes.length ? this.formatMapNotes(mapNotes.slice(0, 3)) : '',
                    `## EVIDENCE SNIPPET\n${formattedContext.contextText.slice(0, 9000)}`
                ].filter(Boolean).join('\n\n');
                assistantMessage = await this.verifyAndRepairAnswer(
                    query, assistantMessage, instructionProfile, verifierSnippet, claimDiagnostics
                );
                citationCount = this.countCitations(assistantMessage);
                claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            }

            let coreStrictPostProcessing = { attempted: false, passed: true, reasons: [] };
            if (!this.__skipCoreStrictPostProcessing) {
                const strictSnippet = [
                    this.formatPlanForContext(cognitivePlan),
                    mapNotes.length ? this.formatMapNotes(mapNotes.slice(0, 2)) : '',
                    `## EVIDENCE SNIPPET\n${formattedContext.contextText.slice(0, 9000)}`
                ].filter(Boolean).join('\n\n');
                const strictResult = await this.runCoreStrictPostProcessing(
                    query,
                    assistantMessage,
                    instructionProfile,
                    sources,
                    strictSnippet
                );
                assistantMessage = strictResult.response;
                citationCount = strictResult.citationCount;
                claimDiagnostics = strictResult.claimDiagnostics;
                coreStrictPostProcessing = strictResult.meta || coreStrictPostProcessing;
            }

            this.conversationHistory.push({ role: 'user', content: query }, { role: 'assistant', content: assistantMessage });
            this.saveChatHistory();
            this.rememberTurn(query, assistantMessage);

            return {
                response: assistantMessage,
                sources,
                meta: { instructionProfile, cognitivePlan, mapPassCount: mapNotes.length, citationCount, claimDiagnostics, coreStrictPostProcessing }
            };
        }
    }

    class QualityEvaluator {
        constructor() {
            this.history = this.loadList('quality_eval_history');
            this.benchmarkHistory = this.loadList('quality_benchmark_history');
            this.failureHistory = this.loadList('quality_failure_history');
        }
        loadList(key) {
            const saved = localStorage.getItem(key);
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }
        saveList(key, value, limit = 120) {
            const trimmed = (value || []).slice(-limit);
            localStorage.setItem(key, JSON.stringify(trimmed));
        }
        saveHistory() { this.saveList('quality_eval_history', this.history, 240); }
        saveBenchmarkHistory() { this.saveList('quality_benchmark_history', this.benchmarkHistory, 60); }
        saveFailureHistory() { this.saveList('quality_failure_history', this.failureHistory, 360); }
        countCitations(text) {
            return (String(text || '').match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }
        evaluateInstructionAdherence(response, instructionProfile = {}, claimDiagnostics = null) {
            const checks = [];
            const text = String(response || '');
            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                checks.push(trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.includes('```json'));
            } else if (instructionProfile.requestedFormat === 'table') {
                checks.push(/\|.+\|/.test(text));
            } else if (instructionProfile.requestedFormat === 'bullet list') {
                checks.push(/^\s*[-*]\s+/m.test(text) || /^\s*\d+\.\s+/m.test(text));
            }
            if (instructionProfile.wantsSteps) checks.push(/\bStep\s*1\b/i.test(text) || /^\s*1\.\s+/m.test(text));
            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                checks.push(words <= Math.ceil(instructionProfile.wordLimit * 1.25));
            }
            if (instructionProfile.strictSourceOnly) {
                checks.push(this.countCitations(text) > 0);
                if (claimDiagnostics) checks.push(claimDiagnostics.claimCitationCoverage >= CLAIM_CITATION_TARGET);
            }
            if (checks.length === 0) return 1;
            const passed = checks.filter(Boolean).length;
            return passed / checks.length;
        }
        evaluateDecisionQuality(query, response, claimDiagnostics = null) {
            const text = String(response || '');
            const lower = text.toLowerCase();
            const decisionLikeQuery = /\b(recommend|decision|should|trade-?off|options?|strategy|action)\b/i.test(String(query || ''));
            const checks = {
                hasMentalModel: /mental model/i.test(text),
                hasEvidenceReasoning: /evidence-based|evidence synthesis|because|therefore|trade-?off/i.test(lower),
                hasOptionsOrTradeoffs: /trade-?off|options?|pros|cons|alternative/i.test(lower),
                hasRecommendation: /recommend|recommended action|best option|decision/i.test(lower),
                hasRiskOrUncertainty: /risk|uncertaint|missing information|assumption/i.test(lower),
                hasActionability: /next steps|action plan|recommended action|^\s*\d+\.\s+/im.test(text),
                hasSupportSignal: claimDiagnostics ? (claimDiagnostics.claimSupportRatio || 0) >= 0.36 : true
            };
            const required = decisionLikeQuery
                ? ['hasMentalModel', 'hasEvidenceReasoning', 'hasOptionsOrTradeoffs', 'hasRecommendation', 'hasRiskOrUncertainty', 'hasActionability', 'hasSupportSignal']
                : ['hasMentalModel', 'hasEvidenceReasoning', 'hasRiskOrUncertainty', 'hasSupportSignal'];
            const passCount = required.filter(key => checks[key]).length;
            const score = required.length ? (passCount / required.length) : 1;
            return { score, checks, requiredChecks: required, decisionLikeQuery };
        }
        evaluateFailureRates(query, response, sources = [], diagnostics = {}, decisionQuality = null) {
            const totalClaims = Math.max(0, diagnostics.totalClaims || 0);
            const citedClaims = Math.max(0, diagnostics.citedClaims || 0);
            const supportedClaims = Math.max(0, diagnostics.supportedClaims || 0);
            const unsupportedClaimsRate = totalClaims ? (1 - (supportedClaims / totalClaims)) : 0;
            const uncitedClaimsRate = totalClaims ? (1 - (citedClaims / totalClaims)) : 0;
            const citationPrecision = Math.max(0, Math.min(1, diagnostics.citationPrecision || 0));
            const citationErrorRate = 1 - citationPrecision;
            const sourceCounts = new Map();
            for (const source of sources || []) {
                const name = String(source?.filename || 'unknown');
                sourceCounts.set(name, (sourceCounts.get(name) || 0) + 1);
            }
            const totalSourceRefs = Array.from(sourceCounts.values()).reduce((sum, value) => sum + value, 0);
            const dominantShare = totalSourceRefs > 0 ? (Math.max(...sourceCounts.values()) / totalSourceRefs) : 0;
            const broadQuery = /\b(overall|across|entire|comprehensive|compare|contrast|multi|strategy|decision|trade-?off)\b/i.test(String(query || ''));
            const sourceDominanceRisk = broadQuery ? dominantShare : 0;
            const missingDecisionReasoning = !!decisionQuality?.decisionLikeQuery && (decisionQuality.score < 0.58);
            const hallucinationRisk = (
                unsupportedClaimsRate > 0.58 ||
                (citationErrorRate > 0.7 && totalClaims >= 4) ||
                (diagnostics.citationCount === 0 && totalClaims >= 3)
            );
            return {
                unsupportedClaimsRate,
                uncitedClaimsRate,
                citationErrorRate,
                sourceDominanceRisk,
                missingDecisionReasoning,
                hallucinationRisk
            };
        }
        computeHumanBaselineDelta(metrics = {}) {
            return {
                overall: (metrics.overall || 0) - HUMAN_BASELINE_METRICS.overall,
                coverage: (metrics.coverage || 0) - HUMAN_BASELINE_METRICS.coverage,
                citationCoverage: (metrics.citationCoverage || 0) - HUMAN_BASELINE_METRICS.citationCoverage,
                citationPrecision: (metrics.citationPrecision || 0) - HUMAN_BASELINE_METRICS.citationPrecision,
                instructionAdherence: (metrics.instructionAdherence || 0) - HUMAN_BASELINE_METRICS.instructionAdherence,
                decisionQuality: (metrics.decisionQuality || 0) - HUMAN_BASELINE_METRICS.decisionQuality
            };
        }
        evaluateTurn(query, response, sources = [], instructionProfile = {}, claimDiagnostics = null) {
            const diagnostics = claimDiagnostics || {
                totalClaims: 0,
                citedClaims: this.countCitations(response),
                supportedClaims: sources.length > 0 ? 1 : 0,
                claimCitationCoverage: this.countCitations(response) > 0 ? 0.75 : 0,
                claimSupportRatio: sources.length > 0 ? 0.65 : 1,
                citationPrecision: this.countCitations(response) > 0 ? 0.7 : 0,
                citationCount: this.countCitations(response)
            };
            const coverage = Math.max(0, Math.min(1, diagnostics.claimSupportRatio || 0));
            const citationCoverage = Math.max(0, Math.min(1, diagnostics.claimCitationCoverage || 0));
            const citationPrecision = Math.max(0, Math.min(1, diagnostics.citationPrecision || 0));
            const instructionAdherence = Math.max(0, Math.min(1, this.evaluateInstructionAdherence(response, instructionProfile, diagnostics)));
            const decisionQuality = this.evaluateDecisionQuality(query, response, diagnostics);
            const decisionQualityScore = Math.max(0, Math.min(1, decisionQuality.score || 0));
            const overall = (
                coverage * 0.24 +
                citationCoverage * 0.16 +
                citationPrecision * 0.16 +
                instructionAdherence * 0.16 +
                decisionQualityScore * 0.28
            );
            const failures = this.evaluateFailureRates(query, response, sources, diagnostics, decisionQuality);
            const metrics = { coverage, citationCoverage, citationPrecision, instructionAdherence, decisionQuality: decisionQualityScore, overall };
            const baselineDelta = this.computeHumanBaselineDelta(metrics);
            const report = {
                timestamp: new Date().toISOString(),
                query: String(query || '').slice(0, 260),
                metrics,
                diagnostics,
                decisionQuality,
                failures,
                baselineDelta
            };
            this.history.push(report);
            this.saveHistory();
            this.failureHistory.push({
                timestamp: report.timestamp,
                query: report.query,
                failures
            });
            this.saveFailureHistory();
            return report;
        }
        getRecentSummary(limit = 8) {
            const recent = this.history.slice(-limit);
            if (recent.length === 0) return null;
            const sum = recent.reduce((acc, item) => {
                acc.coverage += item.metrics.coverage;
                acc.citationCoverage += item.metrics.citationCoverage;
                acc.citationPrecision += item.metrics.citationPrecision;
                acc.instructionAdherence += item.metrics.instructionAdherence;
                acc.decisionQuality += item.metrics.decisionQuality || 0;
                acc.overall += item.metrics.overall;
                return acc;
            }, { coverage: 0, citationCoverage: 0, citationPrecision: 0, instructionAdherence: 0, decisionQuality: 0, overall: 0 });
            const averages = {
                coverage: sum.coverage / recent.length,
                citationCoverage: sum.citationCoverage / recent.length,
                citationPrecision: sum.citationPrecision / recent.length,
                instructionAdherence: sum.instructionAdherence / recent.length,
                decisionQuality: sum.decisionQuality / recent.length,
                overall: sum.overall / recent.length
            };
            return {
                sampleSize: recent.length,
                averages,
                baselineDelta: this.computeHumanBaselineDelta(averages),
                failureSummary: this.getFailureRateSummary(limit),
                recent
            };
        }
        getFailureRateSummary(limit = 30) {
            const recent = this.failureHistory.slice(-limit);
            if (!recent.length) return null;
            const sum = recent.reduce((acc, item) => {
                const f = item.failures || {};
                acc.unsupportedClaimsRate += f.unsupportedClaimsRate || 0;
                acc.uncitedClaimsRate += f.uncitedClaimsRate || 0;
                acc.citationErrorRate += f.citationErrorRate || 0;
                acc.sourceDominanceRisk += f.sourceDominanceRisk || 0;
                acc.missingDecisionReasoning += f.missingDecisionReasoning ? 1 : 0;
                acc.hallucinationRisk += f.hallucinationRisk ? 1 : 0;
                return acc;
            }, {
                unsupportedClaimsRate: 0,
                uncitedClaimsRate: 0,
                citationErrorRate: 0,
                sourceDominanceRisk: 0,
                missingDecisionReasoning: 0,
                hallucinationRisk: 0
            });
            return {
                sampleSize: recent.length,
                averages: {
                    unsupportedClaimsRate: sum.unsupportedClaimsRate / recent.length,
                    uncitedClaimsRate: sum.uncitedClaimsRate / recent.length,
                    citationErrorRate: sum.citationErrorRate / recent.length,
                    sourceDominanceRisk: sum.sourceDominanceRisk / recent.length,
                    missingDecisionReasoningRate: sum.missingDecisionReasoning / recent.length,
                    hallucinationRiskRate: sum.hallucinationRisk / recent.length
                }
            };
        }
        buildBenchmarkTaskPack(documents = []) {
            const names = (documents || []).map(doc => doc.filename).filter(Boolean).slice(0, 5);
            const scopeHint = names.length
                ? `Focus cross-source reasoning across these corpus files when relevant: ${names.join(', ')}.`
                : 'Focus cross-source reasoning across all uploaded corpus files.';
            return BENCHMARK_TASKS.map(task => ({
                ...task,
                query: `${task.query}\n\n${scopeHint}`
            }));
        }
        async evaluateRecallCoverageForQuery(retriever, query, expectedMinDocs = 2) {
            if (!retriever || typeof retriever.retrieve !== 'function') return null;
            const retrieved = await retriever.retrieve(query, null, {
                intent: { broadCoverage: true, comparative: true }
            });
            const docs = new Set((retrieved || []).map(chunk => chunk.filename).filter(Boolean));
            const perDocCount = new Map();
            for (const chunk of (retrieved || [])) {
                const filename = String(chunk?.filename || 'unknown');
                perDocCount.set(filename, (perDocCount.get(filename) || 0) + 1);
            }
            const totalRefs = Array.from(perDocCount.values()).reduce((sum, n) => sum + n, 0);
            const dominantShare = totalRefs ? (Math.max(...perDocCount.values()) / totalRefs) : 0;
            const totalDocs = retriever.documents?.length || 0;
            const coveragePct = totalDocs ? ((docs.size / totalDocs) * 100) : 0;
            const pass = docs.size >= Math.min(expectedMinDocs, Math.max(1, totalDocs));
            return {
                query,
                retrievedChunks: (retrieved || []).length,
                distinctDocs: docs.size,
                totalDocs,
                coveragePct,
                dominantShare,
                pass
            };
        }
        async runRecallCoverageValidation(retriever, tasks = []) {
            const checks = [];
            for (const task of tasks) {
                try {
                    const check = await this.evaluateRecallCoverageForQuery(retriever, task.query, 2);
                    if (check) checks.push({ taskId: task.id, category: task.category, ...check });
                } catch (error) {
                    checks.push({
                        taskId: task.id,
                        category: task.category,
                        query: task.query,
                        error: String(error?.message || error)
                    });
                }
            }
            const valid = checks.filter(item => typeof item.pass === 'boolean');
            const passRate = valid.length ? (valid.filter(item => item.pass).length / valid.length) : 0;
            const avgCoveragePct = valid.length
                ? (valid.reduce((sum, item) => sum + (item.coveragePct || 0), 0) / valid.length)
                : 0;
            const avgDominantShare = valid.length
                ? (valid.reduce((sum, item) => sum + (item.dominantShare || 0), 0) / valid.length)
                : 0;
            return {
                checks,
                passRate,
                avgCoveragePct,
                avgDominantShare,
                sampleSize: valid.length
            };
        }
        async runBenchmarkSuite(executeTask, retriever, documents = []) {
            const tasks = this.buildBenchmarkTaskPack(documents);
            const recallValidation = await this.runRecallCoverageValidation(retriever, tasks);
            const taskReports = [];
            for (const task of tasks) {
                try {
                    const result = await executeTask(task);
                    const turnReport = this.evaluateTurn(
                        task.query,
                        result.response,
                        result.sources || [],
                        result.meta?.instructionProfile || {},
                        result.meta?.claimDiagnostics || null
                    );
                    taskReports.push({
                        taskId: task.id,
                        category: task.category,
                        query: task.query,
                        metrics: turnReport.metrics,
                        failures: turnReport.failures,
                        baselineDelta: turnReport.baselineDelta
                    });
                } catch (error) {
                    taskReports.push({
                        taskId: task.id,
                        category: task.category,
                        query: task.query,
                        error: String(error?.message || error)
                    });
                }
            }
            const valid = taskReports.filter(item => item.metrics);
            const avgMetrics = valid.length ? valid.reduce((acc, item) => {
                acc.coverage += item.metrics.coverage || 0;
                acc.citationCoverage += item.metrics.citationCoverage || 0;
                acc.citationPrecision += item.metrics.citationPrecision || 0;
                acc.instructionAdherence += item.metrics.instructionAdherence || 0;
                acc.decisionQuality += item.metrics.decisionQuality || 0;
                acc.overall += item.metrics.overall || 0;
                return acc;
            }, { coverage: 0, citationCoverage: 0, citationPrecision: 0, instructionAdherence: 0, decisionQuality: 0, overall: 0 }) : null;
            const averages = valid.length ? {
                coverage: avgMetrics.coverage / valid.length,
                citationCoverage: avgMetrics.citationCoverage / valid.length,
                citationPrecision: avgMetrics.citationPrecision / valid.length,
                instructionAdherence: avgMetrics.instructionAdherence / valid.length,
                decisionQuality: avgMetrics.decisionQuality / valid.length,
                overall: avgMetrics.overall / valid.length
            } : null;
            const failureSummary = this.getFailureRateSummary(Math.max(20, valid.length));
            const report = {
                timestamp: new Date().toISOString(),
                sampleSize: valid.length,
                tasks: taskReports,
                recallValidation,
                averages,
                baselineDelta: averages ? this.computeHumanBaselineDelta(averages) : null,
                failureSummary
            };
            this.benchmarkHistory.push(report);
            this.saveBenchmarkHistory();
            return report;
        }
        getBenchmarkSummary(limit = 5) {
            const recent = this.benchmarkHistory.slice(-limit);
            if (!recent.length) return null;
            const valid = recent.filter(item => item.averages);
            if (!valid.length) return null;
            const avg = valid.reduce((acc, item) => {
                acc.coverage += item.averages.coverage;
                acc.citationCoverage += item.averages.citationCoverage;
                acc.citationPrecision += item.averages.citationPrecision;
                acc.instructionAdherence += item.averages.instructionAdherence;
                acc.decisionQuality += item.averages.decisionQuality;
                acc.overall += item.averages.overall;
                acc.recallPassRate += item.recallValidation?.passRate || 0;
                return acc;
            }, { coverage: 0, citationCoverage: 0, citationPrecision: 0, instructionAdherence: 0, decisionQuality: 0, overall: 0, recallPassRate: 0 });
            const averages = {
                coverage: avg.coverage / valid.length,
                citationCoverage: avg.citationCoverage / valid.length,
                citationPrecision: avg.citationPrecision / valid.length,
                instructionAdherence: avg.instructionAdherence / valid.length,
                decisionQuality: avg.decisionQuality / valid.length,
                overall: avg.overall / valid.length,
                recallPassRate: avg.recallPassRate / valid.length
            };
            return {
                sampleSize: valid.length,
                averages,
                baselineDelta: this.computeHumanBaselineDelta(averages),
                recent
            };
        }
    }

    class UIController {
        constructor(db, processor, retriever, synthesizer, evaluator) {
            this.db = db;
            this.processor = processor;
            this.retriever = retriever;
            this.synthesizer = synthesizer;
            this.evaluator = evaluator;
            this.currentAttachment = null;
            this.defaultSynthesisText = 'Building mental model and synthesizing across documents...';
            this.initializeElements();
            this.bindEvents();
            this.loadCorpus();
            this.restoreChatHistory();
        }

        initializeElements() {
            this.chatMessages = document.getElementById('chatMessages');
            this.chatInput = document.getElementById('chatInput');
            this.sendBtn = document.getElementById('sendBtn');
            this.synthesisIndicator = document.getElementById('synthesisIndicator');
            this.synthesisIndicatorText = document.getElementById('synthesisIndicatorText');
            this.clearChatBtn = document.getElementById('clearChatBtn');
            this.chatAttachBtn = document.getElementById('chatAttachBtn');
            this.chatFileInput = document.getElementById('chatFileInput');
            this.attachmentPreview = document.getElementById('attachmentPreview');
            this.attachmentName = document.getElementById('attachmentName');
            this.attachmentMeta = document.getElementById('attachmentMeta');
            this.attachmentRemove = document.getElementById('attachmentRemove');
            this.corpusList = document.getElementById('corpusList');
            this.docCount = document.getElementById('docCount');
            this.chunkCount = document.getElementById('chunkCount');
            this.adminPanel = document.getElementById('adminPanel');
            this.adminClose = document.getElementById('adminClose');
            this.openAdminBtn = document.getElementById('openAdminBtn');
            this.uploadZone = document.getElementById('uploadZone');
            this.fileInput = document.getElementById('fileInput');
            this.apiKeyInput = document.getElementById('apiKeyInput');
            this.saveApiKeyBtn = document.getElementById('saveApiKey');
            this.modelSelect = document.getElementById('modelSelect');
            this.processingStatus = document.getElementById('processingStatus');
            this.processingText = document.getElementById('processingText');
            this.processingBarFill = document.getElementById('processingBarFill');
            this.rebuildIndexBtn = document.getElementById('rebuildIndex');
            this.clearCorpusBtn = document.getElementById('clearCorpus');
            this.clearChatAdminBtn = document.getElementById('clearChatAdmin');
            this.runEvalHarnessBtn = document.getElementById('runEvalHarness');
            this.citationModal = document.getElementById('citationModal');
            this.citationClose = document.getElementById('citationClose');
            this.citationSource = document.getElementById('citationSource');
            this.citationText = document.getElementById('citationText');
            this.toastContainer = document.getElementById('toastContainer');
            this.apiKeyInput.value = localStorage.getItem('openai_api_key') || '';
            this.modelSelect.value = localStorage.getItem('openai_model') || 'gpt-4.1';
        }

        bindEvents() {
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            this.chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            this.clearChatBtn.addEventListener('click', () => this.clearChatHistory());
            this.chatAttachBtn.addEventListener('click', () => this.chatFileInput.click());
            this.chatFileInput.addEventListener('change', (e) => this.handleChatAttachment(e));
            this.attachmentRemove.addEventListener('click', () => this.removeChatAttachment());
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyA') {
                    e.preventDefault();
                    this.toggleAdminPanel();
                }
            });
            this.openAdminBtn.addEventListener('click', () => this.toggleAdminPanel(true));
            this.adminClose.addEventListener('click', () => this.toggleAdminPanel(false));
            this.adminPanel.addEventListener('click', (e) => { if (e.target === this.adminPanel) this.toggleAdminPanel(false); });
            this.uploadZone.addEventListener('click', () => this.fileInput.click());
            this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));
            this.uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); this.uploadZone.classList.add('dragover'); });
            this.uploadZone.addEventListener('dragleave', () => this.uploadZone.classList.remove('dragover'));
            this.uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                this.uploadZone.classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            });
            this.saveApiKeyBtn.addEventListener('click', () => {
                const key = this.apiKeyInput.value.trim();
                if (key) {
                    this.synthesizer.setApiKey(key);
                    this.retriever.setEmbeddingApiKey(key);
                    this.showToast('API key saved successfully', 'success');
                } else {
                    this.showToast('Please enter a valid API key', 'error');
                }
            });
            this.modelSelect.addEventListener('change', () => {
                this.synthesizer.setModel(this.modelSelect.value);
                this.showToast(`Model changed to ${this.modelSelect.value}`, 'success');
            });
            this.rebuildIndexBtn.addEventListener('click', () => this.rebuildIndex());
            this.clearCorpusBtn.addEventListener('click', () => this.clearCorpus());
            this.clearChatAdminBtn.addEventListener('click', () => this.clearChatHistory());
            this.runEvalHarnessBtn.addEventListener('click', () => this.runEvaluationHarness());
            this.citationClose.addEventListener('click', () => this.citationModal.classList.remove('active'));
            this.citationModal.addEventListener('click', (e) => { if (e.target === this.citationModal) this.citationModal.classList.remove('active'); });
        }

        toggleAdminPanel(show = null) {
            if (show === null) this.adminPanel.classList.toggle('active');
            else this.adminPanel.classList.toggle('active', show);
        }

        async loadCorpus() {
            const documents = await this.db.getAllDocuments();
            this.retriever.updateCorpus(documents);
            this.updateCorpusUI(documents);
        }

        updateCorpusUI(documents) {
            const totalChunks = documents.reduce((sum, doc) => sum + (doc.chunks?.length || 0), 0);
            this.docCount.textContent = `${documents.length} documents`;
            this.chunkCount.textContent = `${totalChunks} chunks`;
            if (documents.length === 0) {
                this.corpusList.innerHTML = '<div class="corpus-empty">No documents uploaded yet.</div>';
                return;
            }
            this.corpusList.innerHTML = documents.map(doc => `
                <div class="corpus-item" data-id="${doc.id}">
                    <div style="min-width:0;">
                        <div class="corpus-item-name" title="${this.escapeHtml(doc.filename)}">${this.escapeHtml(doc.filename)}</div>
                        <div class="corpus-item-meta">${(doc.size / 1024).toFixed(1)} KB â€¢ ${doc.chunks?.length || 0} chunks</div>
                    </div>
                    <button class="corpus-item-delete" onclick="app.deleteDocument(${doc.id})" title="Delete">âœ•</button>
                </div>
            `).join('');
        }

        async handleFiles(files) {
            const fileArray = Array.from(files);
            if (fileArray.length === 0) return;
            this.processingStatus.classList.add('active');
            let processed = 0;
            const total = fileArray.length;
            for (const file of fileArray) {
                this.processingText.textContent = `Processing ${file.name}...`;
                this.processingBarFill.style.width = `${(processed / total) * 100}%`;
                try {
                    const document = await this.processor.processFile(file);
                    await this.db.addDocument(document);
                    processed++;
                    this.showToast(`Processed: ${file.name}`, 'success');
                } catch (error) {
                    this.showToast(`Failed: ${file.name} (${error.message})`, 'error');
                }
            }
            this.processingBarFill.style.width = '100%';
            this.processingText.textContent = `Completed! Processed ${processed} of ${total} files.`;
            setTimeout(() => {
                this.processingStatus.classList.remove('active');
                this.processingBarFill.style.width = '0%';
            }, 2000);
            await this.loadCorpus();
            this.fileInput.value = '';
        }

        async handleChatAttachment(event) {
            const file = event.target.files[0];
            if (!file) return;
            const ext = (file.name.split('.').pop() || '').toLowerCase();
            const supportedTypes = ['pdf', 'docx', 'txt', 'csv', 'xlsx', 'md'];
            const legacyTypes = ['doc', 'xls'];
            if (legacyTypes.includes(ext)) {
                this.showToast(`.${ext} is not supported in-browser. Convert to ${ext === 'doc' ? 'DOCX' : 'XLSX'} first.`, 'warning');
                this.chatFileInput.value = '';
                return;
            }
            if (!supportedTypes.includes(ext)) {
                this.showToast('Unsupported file type. Supported: PDF, DOCX, TXT, CSV, XLSX, MD', 'error');
                this.chatFileInput.value = '';
                return;
            }
            try {
                this.showToast('Processing attachment...', 'info');
                const result = await this.processor.processFile(file);
                const wordCount = result.memory?.wordCount || result.fullText.split(/\s+/).filter(Boolean).length;
                this.currentAttachment = { name: file.name, chunks: result.chunks, memory: result.memory, type: ext, wordCount };
                this.attachmentName.textContent = file.name;
                this.attachmentMeta.textContent = `${wordCount.toLocaleString()} words - Temporary analysis`;
                this.attachmentPreview.classList.add('active');
                this.showToast(`Attached: ${file.name}`, 'success');
            } catch (error) {
                this.showToast(`Failed to process attachment: ${error.message}`, 'error');
            }
            this.chatFileInput.value = '';
        }

        removeChatAttachment() {
            this.currentAttachment = null;
            this.attachmentPreview.classList.remove('active');
            this.chatFileInput.value = '';
        }

        async deleteDocument(id) {
            if (confirm('Delete this document?')) {
                await this.db.deleteDocument(id);
                await this.loadCorpus();
                this.showToast('Document deleted', 'success');
            }
        }

        async rebuildIndex() {
            this.showToast('Rebuilding index...', 'info');
            await this.loadCorpus();
            this.showToast('Index rebuilt successfully', 'success');
        }

        async clearCorpus() {
            if (confirm('Delete ALL documents? This cannot be undone.')) {
                await this.db.clearAll();
                await this.loadCorpus();
                this.showToast('All documents cleared', 'success');
            }
        }

        clearChatHistory() {
            if (confirm('Clear all chat history?')) {
                this.synthesizer.clearHistory();
                this.chatMessages.innerHTML = `
                    <div class="message system">
                        Chat history cleared. Upload documents and ask questions.
                    </div>`;
                this.showToast('Chat history cleared', 'success');
            }
        }

        restoreChatHistory() {
            const history = this.synthesizer.conversationHistory;
            if (history.length === 0) return;
            for (const msg of history) this.addMessage(msg.content, msg.role);
        }

        setSynthesisMessage(isBroadCoverage) {
            this.synthesisIndicatorText.textContent = isBroadCoverage
                ? 'Running deep coverage synthesis across long context...'
                : this.defaultSynthesisText;
        }

        buildCorpusStats(query, relevantChunks, intent = {}) {
            const relevantFilenames = new Set((relevantChunks || []).map(chunk => chunk.filename));
            const documentMemories = this.retriever.documents
                .filter(doc => relevantFilenames.has(doc.filename))
                .slice(0, 10)
                .map(doc => ({ filename: doc.filename, memory: doc.memory }));
            return {
                numDocs: this.retriever.documents.length,
                numChunks: this.retriever.allChunks.length,
                connectedConcepts: this.retriever.getTopConnectedConcepts(10),
                documentMemories,
                corpusDigest: intent?.broadCoverage ? this.retriever.buildCorpusDigest(query, relevantChunks, 16) : ''
            };
        }

        async executeEvaluationTask(task) {
            const query = String(task?.query || '').trim();
            if (!query) throw new Error('Benchmark task query is empty.');
            if (!this.synthesizer.apiKey) throw new Error('API key not configured for benchmark execution.');
            if (!this.retriever.allChunks.length) throw new Error('No corpus documents available for benchmark execution.');

            const historySnapshot = Array.isArray(this.synthesizer.conversationHistory)
                ? [...this.synthesizer.conversationHistory]
                : [];
            const memorySnapshot = Array.isArray(this.synthesizer.workingMemory)
                ? [...this.synthesizer.workingMemory]
                : [];

            try {
                const intent = this.retriever.detectQueryIntent(query);
                const relevantChunks = await this.retriever.retrieve(query, null, { intent: { ...intent, broadCoverage: true, comparative: true } });
                const corpusStats = this.buildCorpusStats(query, relevantChunks, { ...intent, broadCoverage: true });
                return await this.synthesizer.synthesize(query, relevantChunks, null, corpusStats);
            } finally {
                this.synthesizer.conversationHistory = historySnapshot.slice(-40);
                if (typeof this.synthesizer.saveChatHistory === 'function') this.synthesizer.saveChatHistory();
                this.synthesizer.workingMemory = memorySnapshot.slice(-18);
                if (typeof this.synthesizer.saveWorkingMemory === 'function') this.synthesizer.saveWorkingMemory();
            }
        }

        async sendMessage() {
            const query = this.chatInput.value.trim();
            if (!query) return;
            if (!this.synthesizer.apiKey) {
                this.showToast('Please configure your OpenAI API key in Admin Panel', 'error');
                this.toggleAdminPanel(true);
                return;
            }
            const hasCorpus = this.retriever.allChunks.length > 0;
            const hasAttachment = this.currentAttachment !== null;
            if (!hasCorpus && !hasAttachment) {
                this.showToast('Upload documents or attach a file first', 'warning');
                return;
            }

            let displayMessage = query;
            if (hasAttachment) {
                displayMessage = `ðŸ“Ž ${this.currentAttachment.name}\n${query}`;
            }

            this.addMessage(displayMessage, 'user');
            this.chatInput.value = '';
            this.sendBtn.disabled = true;
            const intent = this.retriever.detectQueryIntent(query);
            this.setSynthesisMessage(intent.broadCoverage);
            this.synthesisIndicator.classList.add('active');

            try {
                let relevantChunks = hasCorpus ? await this.retriever.retrieve(query, null, { intent }) : [];
                let attachmentContext = null;
                if (hasAttachment) {
                    const broadCoverage = intent.broadCoverage || (this.currentAttachment.wordCount >= LONG_DOC_WORD_THRESHOLD);
                    const attachmentChunks = await this.retriever.retrieveFromChunks(
                        query,
                        this.currentAttachment.chunks,
                        broadCoverage ? 20 : 12,
                        { intent: { ...intent, broadCoverage } }
                    );
                    attachmentContext = {
                        name: this.currentAttachment.name,
                        chunks: attachmentChunks,
                        memory: this.currentAttachment.memory,
                        digest: broadCoverage ? this.retriever.buildAttachmentDigest(query, this.currentAttachment.chunks, 16) : '',
                        isTemporary: true
                    };
                }

                const corpusStats = this.buildCorpusStats(query, relevantChunks, intent);

                const result = await this.synthesizer.synthesize(query, relevantChunks, attachmentContext, corpusStats);
                this.addMessage(result.response, 'assistant', result.sources);

                if (this.evaluator) {
                    const evaluation = this.evaluator.evaluateTurn(
                        query,
                        result.response,
                        result.sources,
                        result.meta?.instructionProfile || {},
                        result.meta?.claimDiagnostics || null
                    );
                    const scorePct = (evaluation.metrics.overall * 100).toFixed(1);
                    const toastType = evaluation.metrics.overall >= 0.82 ? 'success'
                        : evaluation.metrics.overall >= 0.65 ? 'info' : 'warning';
                    this.showToast(
                        `Eval ${scorePct}% (coverage ${(evaluation.metrics.coverage * 100).toFixed(0)}%, decision ${(evaluation.metrics.decisionQuality * 100).toFixed(0)}%, citations ${(evaluation.metrics.citationPrecision * 100).toFixed(0)}%)`,
                        toastType
                    );
                }
            } catch (error) {
                this.addMessage(`I encountered an error: ${error.message}. Check API key/model and retry.`, 'system');
            } finally {
                this.sendBtn.disabled = false;
                this.synthesisIndicator.classList.remove('active');
                this.setSynthesisMessage(false);
                this.removeChatAttachment();
            }
        }

        async runEvaluationHarness() {
            if (!this.evaluator) {
                this.showToast('Evaluator unavailable.', 'error');
                return;
            }
            if (!this.retriever.documents.length) {
                this.showToast('Upload corpus documents before running benchmark harness.', 'warning');
                return;
            }

            const rollingSummary = this.evaluator.getRecentSummary(12);
            this.synthesisIndicator.classList.add('active');
            this.synthesisIndicatorText.textContent = 'Running benchmark suite, recall/coverage validation, and failure-rate tracking...';

            try {
                let benchmarkReport = null;
                let recallOnlyReport = null;
                if (this.synthesizer.apiKey) {
                    benchmarkReport = await this.evaluator.runBenchmarkSuite(
                        (task) => this.executeEvaluationTask(task),
                        this.retriever,
                        this.retriever.documents
                    );
                } else {
                    const tasks = this.evaluator.buildBenchmarkTaskPack(this.retriever.documents);
                    recallOnlyReport = await this.evaluator.runRecallCoverageValidation(this.retriever, tasks);
                }

                const lines = [];
                lines.push('Benchmark Harness Results');
                lines.push('---');

                if (rollingSummary) {
                    const avg = rollingSummary.averages;
                    lines.push(`Live turns (${rollingSummary.sampleSize}): overall ${(avg.overall * 100).toFixed(1)}%, decision ${(avg.decisionQuality * 100).toFixed(1)}%, citation precision ${(avg.citationPrecision * 100).toFixed(1)}%.`);
                    if (rollingSummary.baselineDelta) {
                        lines.push(`Vs human baseline: overall ${(rollingSummary.baselineDelta.overall * 100).toFixed(1)} pts, decision ${(rollingSummary.baselineDelta.decisionQuality * 100).toFixed(1)} pts.`);
                    }
                } else {
                    lines.push('Live turns: no prior turn-evaluation history.');
                }

                if (benchmarkReport) {
                    const avg = benchmarkReport.averages || {};
                    const recall = benchmarkReport.recallValidation || {};
                    const fail = benchmarkReport.failureSummary?.averages || {};
                    lines.push(`Benchmark tasks executed: ${benchmarkReport.sampleSize}/${BENCHMARK_TASKS.length}.`);
                    lines.push(`Recall/coverage validation: pass ${(Number(recall.passRate || 0) * 100).toFixed(1)}%, avg corpus coverage ${Number(recall.avgCoveragePct || 0).toFixed(1)}%, dominant-source share ${(Number(recall.avgDominantShare || 0) * 100).toFixed(1)}%.`);
                    lines.push(`Expert-quality metrics: overall ${(Number(avg.overall || 0) * 100).toFixed(1)}%, decision ${(Number(avg.decisionQuality || 0) * 100).toFixed(1)}%, coverage ${(Number(avg.coverage || 0) * 100).toFixed(1)}%, citation precision ${(Number(avg.citationPrecision || 0) * 100).toFixed(1)}%.`);
                    if (benchmarkReport.baselineDelta) {
                        lines.push(`Against human baseline: overall ${(benchmarkReport.baselineDelta.overall * 100).toFixed(1)} pts, decision ${(benchmarkReport.baselineDelta.decisionQuality * 100).toFixed(1)} pts, coverage ${(benchmarkReport.baselineDelta.coverage * 100).toFixed(1)} pts.`);
                    }
                    lines.push(`Failure rates: unsupported claims ${(Number(fail.unsupportedClaimsRate || 0) * 100).toFixed(1)}%, uncited claims ${(Number(fail.uncitedClaimsRate || 0) * 100).toFixed(1)}%, hallucination risk ${(Number(fail.hallucinationRiskRate || 0) * 100).toFixed(1)}%, missing decision reasoning ${(Number(fail.missingDecisionReasoningRate || 0) * 100).toFixed(1)}%.`);
                } else if (recallOnlyReport) {
                    lines.push('Benchmark text generation skipped: configure API key to run full benchmark suite.');
                    lines.push(`Recall/coverage-only validation: pass ${(Number(recallOnlyReport.passRate || 0) * 100).toFixed(1)}%, avg corpus coverage ${Number(recallOnlyReport.avgCoveragePct || 0).toFixed(1)}%, dominant-source share ${(Number(recallOnlyReport.avgDominantShare || 0) * 100).toFixed(1)}%.`);
                }

                this.addMessage(lines.join(' '), 'system');
                this.showToast('Benchmark harness completed successfully.', 'info');
            } catch (error) {
                this.addMessage(`Benchmark harness error: ${error.message || String(error)}`, 'system');
                this.showToast(`Benchmark harness failed: ${error.message || error}`, 'error');
            } finally {
                this.synthesisIndicator.classList.remove('active');
                this.setSynthesisMessage(false);
            }
        }

        escapeHtml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        renderMarkdownLite(escapedText) {
            let text = escapedText
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            const lines = text.split('\n');
            let html = '';
            let inUl = false;
            let inOl = false;
            const closeLists = () => {
                if (inUl) { html += '</ul>'; inUl = false; }
                if (inOl) { html += '</ol>'; inOl = false; }
            };
            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) { closeLists(); continue; }
                const ulMatch = line.match(/^- (.+)$/);
                const olMatch = line.match(/^\d+\. (.+)$/);
                if (ulMatch) {
                    if (!inUl) { closeLists(); html += '<ul>'; inUl = true; }
                    html += `<li>${ulMatch[1]}</li>`;
                    continue;
                }
                if (olMatch) {
                    if (!inOl) { closeLists(); html += '<ol>'; inOl = true; }
                    html += `<li>${olMatch[1]}</li>`;
                    continue;
                }
                closeLists();
                html += `<p>${line}</p>`;
            }
            closeLists();
            return html || '<p></p>';
        }

        formatCitations(content, sources) {
            const citationRegex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citationTokens = [];
            let tokenized = content.replace(citationRegex, (match, filename, page, quote) => {
                const token = `__CITATION_${citationTokens.length}__`;
                citationTokens.push({
                    token,
                    filename: String(filename || '').trim(),
                    page: String(page || '').trim(),
                    quote: String(quote || '').trim()
                });
                return token;
            });
            tokenized = this.escapeHtml(tokenized);
            let rendered = this.renderMarkdownLite(tokenized);
            for (const citation of citationTokens) {
                const sourceInfo = `${citation.filename}, Page ${citation.page}`;
                const html = `<span class="citation" data-source="${this.escapeHtml(sourceInfo)}" data-text="${this.escapeHtml(citation.quote)}">${this.escapeHtml(citation.filename).slice(0, 22)}...</span>`;
                rendered = rendered.replace(citation.token, html);
            }
            return rendered;
        }

        addMessage(content, role, sources = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            let processedContent = this.renderMarkdownLite(this.escapeHtml(content));
            if (role === 'assistant') processedContent = this.formatCitations(content, sources);
            else if (role === 'system') processedContent = this.renderMarkdownLite(this.escapeHtml(content));
            messageDiv.innerHTML = processedContent;
            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            if (role === 'assistant') {
                messageDiv.querySelectorAll('.citation').forEach(citation => {
                    citation.addEventListener('click', () => {
                        const source = citation.dataset.source;
                        const text = citation.dataset.text;
                        this.showCitation(source, text);
                    });
                });
            }
        }

        showCitation(source, text) {
            this.citationSource.textContent = source;
            this.citationText.textContent = text;
            this.citationModal.classList.add('active');
        }

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            this.toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 4200);
        }
    }

    let app;

    async function initializeApp() {
        try {
            const db = new DocumentDatabase();
            await db.init();
            const processor = new DocumentProcessor();
            const retriever = new CognitiveRetriever();
            const synthesizer = new CognitiveSynthesizer();
            const evaluator = new QualityEvaluator();
            retriever.setEmbeddingApiKey(synthesizer.apiKey);
            app = new UIController(db, processor, retriever, synthesizer, evaluator);
            window.app = app;
            console.log('Cognitive Synthesis Engine initialized successfully');
        } catch (error) {
            console.error('Failed to initialize application:', error);
            alert('Failed to initialize the application. Please refresh the page.');
        }
    }

    document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

    <!-- Inline super-brain enhancer (self-contained; no external dependency). -->
    <script>
    (function inlineSuperBrainEnhancer() {
        'use strict';

        const PATCH_VERSION = '2026-02-11-inline-superbrain-v7';
        const FULL_SCAN_MIN_TOPK = 26;
        const FULL_SCAN_MAX_TOPK = 46;
        const MAX_CONCEPT_EXPANSION = 30;
        const MAX_MENTAL_MODEL_SOURCES = 36;
        const MIN_RICH_CORPUS_CITATIONS = 4;
        const MAX_RETRIEVAL_REFINEMENT_PASSES = 4;
        const RETRIEVAL_STABLE_CHUNK_DELTA = 3;
        const MAX_MODEL_REFINEMENT_PASSES = 3;
        const MODEL_GAP_THRESHOLD = 6;
        const MAX_GAP_REFINEMENT_QUERIES = 4;
        const MAX_ANALYSIS_REWRITE_ATTEMPTS = 2;
        const MIN_DECISION_REASONING_SIGNALS = 4;
        const MIN_ANALYSIS_REASONING_SIGNALS = 2;
        const MIN_HUMAN_COGNITION_STAGE_SIGNALS = 4;
        const MIN_HUMAN_COGNITION_STAGE_SIGNALS_DECISION = 5;
        const MAX_ADVERSARIAL_RETRIEVAL_PASSES = 3;
        const MAX_ADVERSARIAL_CHUNKS = 16;
        const MAX_PREDICTIVE_HYPOTHESES = 5;
        const MIN_CROSS_SOURCE_DOCS = 2;
        const FULL_CORPUS_DOC_ANCHORS_PER_DOC = 6;
        const FULL_CORPUS_DOC_TOP_RELEVANT = 3;
        const FULL_CORPUS_MAP_BLOCK_MAX_CHARS = 14000;
        const CONTRADICTION_BLOCK_MAX_CHARS = 2600;
        const CONTRADICTION_MAX_PAIRS = 6;

        const BRAIN_INSPIRED_PRIOR = [
            'Use latent task structure, not surface wording only.',
            'Link semantically related evidence across documents.',
            'Build and validate an explicit internal mental model before finalizing.',
            'Perform iterative verification against retrieved source evidence only.'
        ];

        function uniqueBy(items, keyFn) {
            const seen = new Set();
            const out = [];
            for (const item of items || []) {
                const key = keyFn(item);
                if (key === undefined || key === null) continue;
                if (seen.has(key)) continue;
                seen.add(key);
                out.push(item);
            }
            return out;
        }

        function normalizeTextLite(text) {
            return String(text || '')
                .toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function patchMethod(klass, methodName, wrapperFactory) {
            if (!klass || !klass.prototype) return false;
            const original = klass.prototype[methodName];
            if (typeof original !== 'function') return false;
            if (original.__inlineSuperBrainPatch === PATCH_VERSION) return true;
            const wrapped = wrapperFactory(original);
            if (typeof wrapped !== 'function') return false;
            wrapped.__inlineSuperBrainPatch = PATCH_VERSION;
            klass.prototype[methodName] = wrapped;
            return true;
        }

        function installRetrieverEnhancements(CognitiveRetriever) {
            if (!CognitiveRetriever || !CognitiveRetriever.prototype) return;

            if (typeof CognitiveRetriever.prototype.extractSemanticConcepts !== 'function') {
                CognitiveRetriever.prototype.extractSemanticConcepts = function extractSemanticConcepts(text) {
                    const source = String(text || '');
                    if (!source) return [];
                    const concepts = new Set();

                    const proper = source.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
                    for (const p of proper) {
                        const v = normalizeTextLite(p);
                        if (v.length >= 3) concepts.add(v);
                    }
                    const hyphenated = source.match(/\b[a-z]+(?:[-_][a-z0-9]+)+\b/gi) || [];
                    for (const h of hyphenated) {
                        const v = normalizeTextLite(h);
                        if (v.length >= 3) concepts.add(v);
                    }
                    const quoted = source.match(/"([^"]{3,80})"/g) || [];
                    for (const q of quoted) {
                        const v = normalizeTextLite(q.replace(/"/g, ''));
                        if (v.length >= 3) concepts.add(v);
                    }

                    const tokens = (typeof this.tokenize === 'function' ? this.tokenize(source) : normalizeTextLite(source).split(/\s+/).filter(Boolean));
                    const freq = new Map();
                    for (const token of tokens) {
                        if (token.length < 4) continue;
                        freq.set(token, (freq.get(token) || 0) + 1);
                    }
                    const top = Array.from(freq.entries())
                        .filter(([, c]) => c >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 16)
                        .map(([token]) => token);
                    for (const token of top) concepts.add(token);
                    return Array.from(concepts).slice(0, 24);
                };
            }

            if (typeof CognitiveRetriever.prototype.buildSemanticBridgeGraph !== 'function') {
                CognitiveRetriever.prototype.buildSemanticBridgeGraph = function buildSemanticBridgeGraph() {
                    this.semanticBridgeGraph = new Map();    // concept -> Map(concept, weight)
                    this.bridgeConceptToChunkIds = new Map(); // concept -> Set(chunkId)
                    this.chunkConcepts = new Map();          // chunkId -> concepts
                    this.chunkIdToDoc = new Map();           // chunkId -> filename

                    const addEdge = (a, b, w) => {
                        if (!a || !b || a === b) return;
                        if (!this.semanticBridgeGraph.has(a)) this.semanticBridgeGraph.set(a, new Map());
                        const neighbors = this.semanticBridgeGraph.get(a);
                        neighbors.set(b, (neighbors.get(b) || 0) + w);
                    };

                    for (const chunk of this.allChunks || []) {
                        const concepts = this.extractSemanticConcepts(chunk.text).slice(0, 18);
                        this.chunkConcepts.set(chunk.id, concepts);
                        this.chunkIdToDoc.set(chunk.id, chunk.filename);

                        for (const concept of concepts) {
                            if (!this.bridgeConceptToChunkIds.has(concept)) this.bridgeConceptToChunkIds.set(concept, new Set());
                            this.bridgeConceptToChunkIds.get(concept).add(chunk.id);
                        }

                        for (let i = 0; i < concepts.length; i++) {
                            for (let j = i + 1; j < concepts.length; j++) {
                                const dist = Math.abs(i - j) + 1;
                                const w = 1 / dist;
                                addEdge(concepts[i], concepts[j], w);
                                addEdge(concepts[j], concepts[i], w);
                            }
                        }
                    }
                };
            }

            if (typeof CognitiveRetriever.prototype.getPerDocumentAnchors !== 'function') {
                CognitiveRetriever.prototype.getPerDocumentAnchors = function getPerDocumentAnchors(query, intent = {}) {
                    const anchors = [];
                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);

                    for (const doc of this.documents || []) {
                        const docChunks = (doc.chunks || [])
                            .map(ch => this.chunkLookup.get(ch.id) || ch)
                            .filter(Boolean);
                        if (!docChunks.length) continue;

                        const scored = docChunks.map(chunk => ({
                            ...chunk,
                            score: this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts)
                        })).sort((a, b) => b.score - a.score);

                        anchors.push(...scored.slice(0, intent.broadCoverage ? 2 : 1));

                        const ordered = docChunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                        const spread = this.pickEvenlyDistributed(ordered, intent.broadCoverage ? 2 : 1);
                        anchors.push(...spread);
                    }

                    return uniqueBy(anchors, item => item.id);
                };
            }

            if (typeof CognitiveRetriever.prototype.expandImplicitLinks !== 'function') {
                CognitiveRetriever.prototype.expandImplicitLinks = function expandImplicitLinks(seedChunks, query, limit = MAX_CONCEPT_EXPANSION) {
                    if (!seedChunks?.length || !this.semanticBridgeGraph?.size || !this.bridgeConceptToChunkIds?.size) return [];

                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);
                    const seedIds = new Set(seedChunks.map(c => c.id));

                    const conceptWeights = new Map();
                    for (const chunk of seedChunks) {
                        const concepts = this.chunkConcepts.get(chunk.id) || this.extractSemanticConcepts(chunk.text);
                        const base = (chunk.score || 0.15) + 0.2;
                        for (const concept of concepts) {
                            conceptWeights.set(concept, (conceptWeights.get(concept) || 0) + base);
                        }
                    }

                    const candidateConcepts = new Map();
                    const topSeedConcepts = Array.from(conceptWeights.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 16);
                    for (const [concept, w] of topSeedConcepts) {
                        candidateConcepts.set(concept, Math.max(candidateConcepts.get(concept) || 0, w));
                        const neighbors = this.semanticBridgeGraph.get(concept);
                        if (!neighbors) continue;
                        const topNeighbors = Array.from(neighbors.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        for (const [neighbor, edgeWeight] of topNeighbors) {
                            const score = (w * 0.65) + (edgeWeight * 0.35);
                            candidateConcepts.set(neighbor, Math.max(candidateConcepts.get(neighbor) || 0, score));
                        }
                    }

                    const candidates = [];
                    for (const [concept, bridgeWeight] of candidateConcepts.entries()) {
                        const chunkIds = this.bridgeConceptToChunkIds.get(concept);
                        if (!chunkIds) continue;
                        for (const chunkId of chunkIds) {
                            if (seedIds.has(chunkId)) continue;
                            const chunk = this.chunkLookup.get(chunkId);
                            if (!chunk) continue;
                            const lexical = this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts);
                            const score = (lexical * 0.74) + (Math.min(bridgeWeight, 5) * 0.08);
                            candidates.push({ ...chunk, score, bridgeConcept: concept });
                        }
                    }

                    return uniqueBy(candidates.sort((a, b) => b.score - a.score), item => item.id).slice(0, limit);
                };
            }

            if (typeof CognitiveRetriever.prototype.buildActivationReport !== 'function') {
                CognitiveRetriever.prototype.buildActivationReport = function buildActivationReport(query, selectedChunks) {
                    const totalDocs = this.documents?.length || 0;
                    const totalChunks = this.allChunks?.length || 0;
                    const activatedDocs = new Set((selectedChunks || []).map(ch => ch.filename));
                    const conceptDocCount = new Map();
                    for (const [concept, ids] of (this.bridgeConceptToChunkIds || new Map()).entries()) {
                        const docs = new Set();
                        for (const id of ids) {
                            const d = this.chunkIdToDoc?.get(id);
                            if (d) docs.add(d);
                        }
                        if (docs.size > 1) conceptDocCount.set(concept, docs.size);
                    }
                    const bridgeConcepts = Array.from(conceptDocCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                        .map(([concept, docs]) => ({ concept, docs }));
                    return {
                        query,
                        totalDocuments: totalDocs,
                        totalChunks,
                        activatedDocuments: activatedDocs.size,
                        activatedChunks: (selectedChunks || []).length,
                        activationCoveragePct: totalDocs ? Math.round((activatedDocs.size / totalDocs) * 100) : 0,
                        bridgeConcepts
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.buildFullCorpusDocumentSweep !== 'function') {
                CognitiveRetriever.prototype.buildFullCorpusDocumentSweep = function buildFullCorpusDocumentSweep(query, options = {}) {
                    const docs = this.documents || [];
                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);
                    const perDocMaxChunks = options.perDocMaxChunks || FULL_CORPUS_DOC_ANCHORS_PER_DOC;
                    const perDocTopRelevant = options.perDocTopRelevant || FULL_CORPUS_DOC_TOP_RELEVANT;
                    const docSweeps = [];

                    for (const doc of docs) {
                        const docChunks = (doc.chunks || [])
                            .map(ch => this.chunkLookup.get(ch.id) || ch)
                            .filter(Boolean);

                        if (!docChunks.length) {
                            docSweeps.push({
                                filename: doc.filename,
                                totalChunks: 0,
                                selectedChunks: [],
                                averageScore: 0,
                                keyConcepts: (doc.memory?.keyConcepts || []).slice(0, 12)
                            });
                            continue;
                        }

                        const scored = docChunks.map(chunk => ({
                            ...chunk,
                            score: this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts)
                        })).sort((a, b) => b.score - a.score);

                        const ordered = docChunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                        const spreadCount = Math.max(2, Math.min(5, Math.ceil(docChunks.length / 12)));
                        const spread = this.pickEvenlyDistributed(ordered, spreadCount);
                        const boundary = [ordered[0], ordered[ordered.length - 1]].filter(Boolean);

                        const selected = uniqueBy(
                            [...scored.slice(0, perDocTopRelevant), ...spread, ...boundary],
                            item => item.id
                        ).slice(0, perDocMaxChunks);

                        const avgScore = selected.length
                            ? (selected.reduce((sum, chunk) => sum + (chunk.score || 0), 0) / selected.length)
                            : 0;

                        docSweeps.push({
                            filename: doc.filename,
                            totalChunks: docChunks.length,
                            selectedChunks: selected,
                            averageScore: avgScore,
                            keyConcepts: (doc.memory?.keyConcepts || []).slice(0, 12)
                        });
                    }

                    const conceptDocs = new Map();
                    for (const docSweep of docSweeps) {
                        const concepts = docSweep.keyConcepts || [];
                        for (const conceptRaw of concepts) {
                            const concept = normalizeTextLite(conceptRaw);
                            if (!concept) continue;
                            if (!conceptDocs.has(concept)) conceptDocs.set(concept, new Set());
                            conceptDocs.get(concept).add(docSweep.filename);
                        }
                    }

                    const crossConcepts = Array.from(conceptDocs.entries())
                        .filter(([, files]) => files.size > 1)
                        .sort((a, b) => b[1].size - a[1].size)
                        .slice(0, 20)
                        .map(([concept, files]) => ({
                            concept,
                            docs: files.size,
                            files: Array.from(files).slice(0, 8)
                        }));

                    const totalSelectedChunks = docSweeps.reduce((sum, docSweep) => sum + (docSweep.selectedChunks?.length || 0), 0);
                    return {
                        query,
                        totalDocuments: docs.length,
                        totalChunks: this.allChunks?.length || 0,
                        totalSelectedChunks,
                        docSweeps,
                        crossConcepts
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainResolveQueryFromSession !== 'function') {
                CognitiveRetriever.prototype.superBrainResolveQueryFromSession = function superBrainResolveQueryFromSession(query) {
                    const raw = String(query || '').trim();
                    if (!raw) return raw;
                    const hasReference = /\b(it|this|that|those|these|they|them|previous|same one|compare it|what about)\b/i.test(raw);
                    if (!hasReference) return raw;
                    const history = (typeof window !== 'undefined' && window.app?.synthesizer?.conversationHistory)
                        ? window.app.synthesizer.conversationHistory
                        : [];
                    if (!Array.isArray(history) || history.length === 0) return raw;
                    const recentUser = history.slice().reverse().find(item => item?.role === 'user' && String(item?.content || '').trim());
                    if (!recentUser) return raw;
                    const hint = String(recentUser.content || '').replace(/\s+/g, ' ').trim().slice(0, 240);
                    if (!hint) return raw;
                    return `${raw}\n\n[Continuity hint from prior user turn: ${hint}]`;
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildIntentGraph !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildIntentGraph = function superBrainBuildIntentGraph(query) {
                    const normalized = String(query || '').replace(/\s+/g, ' ').trim();
                    const entities = this.extractEntities(normalized).slice(0, 20);
                    const concepts = this.extractConcepts(normalized).slice(0, 24);
                    const constraintPhrases = (normalized.match(/\b(must|cannot|only|at least|at most|required|unless|except|without)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    const relationPhrases = (normalized.match(/\b(cause|impact|depends on|related to|trade[- ]?off|compare|versus|vs)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    const unknownSignals = (normalized.match(/\b(uncertain|unknown|missing|need|evidence|prove|validate)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    return {
                        raw: normalized,
                        entities,
                        concepts,
                        constraints: constraintPhrases,
                        relations: relationPhrases,
                        unknowns: unknownSignals
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildPredictiveModel !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildPredictiveModel = function superBrainBuildPredictiveModel(query, intentGraph = null, intent = {}) {
                    const graph = intentGraph || this.superBrainBuildIntentGraph(query);
                    const raw = String(query || '').replace(/\s+/g, ' ').trim();
                    const hypotheses = [];
                    const pushHypothesis = (type, statement, confidence = 0.5) => {
                        const cleaned = String(statement || '').replace(/\s+/g, ' ').trim();
                        if (!cleaned) return;
                        hypotheses.push({ type, statement: cleaned, confidence });
                    };

                    pushHypothesis('baseline_rule', `Primary rule likely governs: ${raw}`, 0.58);
                    if (graph.constraints?.length) {
                        pushHypothesis('constraint', `Constraints likely narrow options: ${graph.constraints.slice(0, 2).join('; ')}`, 0.63);
                    }
                    if (graph.relations?.length || intent.comparative) {
                        pushHypothesis('tradeoff', 'Competing factors likely require weighing trade-offs rather than applying a single rule.', 0.66);
                    }
                    if (/\b(late|deadline|exception|override|appeal|special case)\b/i.test(raw)) {
                        pushHypothesis('exception', 'General policy likely has context-specific exception clauses that may supersede default restrictions.', 0.72);
                    }
                    if (/\b(policy|manual|guideline|rule|regulation|procedure)\b/i.test(raw)) {
                        pushHypothesis('hierarchy', 'When sources conflict, more specific/authoritative policy text should outweigh generic guidance.', 0.76);
                    }

                    const weightingPriors = {
                        authority: 'Prefer official, policy-grade, and source-of-record documents over summaries.',
                        recency: 'Prefer newer versions where temporal conflict exists.',
                        contextualRelevance: 'Prefer clauses that match the exact scenario and constraints from the query.'
                    };
                    const anticipatedConclusion = hypotheses.length
                        ? hypotheses.slice(0, 2).map(item => item.statement).join(' ')
                        : `Likely requires balancing baseline rules against scenario-specific exceptions for: ${raw}`;

                    return {
                        query: raw,
                        anticipatedConclusion,
                        hypotheses: uniqueBy(hypotheses, item => `${item.type}:${item.statement}`).slice(0, MAX_PREDICTIVE_HYPOTHESES),
                        expectedEvidenceNeeds: [
                            'baseline rule text',
                            'exception/override clauses',
                            'conflict resolution precedence statements',
                            'implementation/action constraints'
                        ],
                        weightingPriors
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildProbeQueries !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildProbeQueries = function superBrainBuildProbeQueries(query, intentGraph = null, intent = {}, predictiveModel = null) {
                    const graph = intentGraph || this.superBrainBuildIntentGraph(query);
                    const predictive = predictiveModel || this.superBrainBuildPredictiveModel(query, graph, intent);
                    const probes = [];
                    const push = (value) => {
                        const cleaned = String(value || '').replace(/\s+/g, ' ').trim();
                        if (!cleaned) return;
                        probes.push(cleaned);
                    };
                    push(`${query} semantic evidence relationships constraints`);
                    if (graph.entities.length) push(`${query} ${graph.entities.slice(0, 4).join(' ')} evidence across documents`);
                    if (graph.concepts.length) push(`${query} ${graph.concepts.slice(0, 5).join(' ')} implicit links`);
                    if (graph.constraints.length) push(`${query} constraints exceptions conflicts`);
                    if (graph.relations.length || intent.comparative) push(`${query} compare trade-offs and dependencies`);
                    if (intent.timeline) push(`${query} chronology sequence and milestones`);
                    if (graph.unknowns.length) push(`${query} missing evidence validation`);
                    if (predictive?.hypotheses?.length) {
                        for (const hypothesis of predictive.hypotheses.slice(0, 3)) {
                            push(`${query} validate hypothesis: ${hypothesis.statement}`);
                        }
                    }
                    push(`${query} specific clause that overrides general rule`);
                    return uniqueBy(probes, item => normalizeTextLite(item)).slice(0, MAX_RETRIEVAL_REFINEMENT_PASSES * 2);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainDeepScanAugment !== 'function') {
                CognitiveRetriever.prototype.superBrainDeepScanAugment = function superBrainDeepScanAugment(query, selectedChunks = [], targetTopK = FULL_SCAN_MIN_TOPK) {
                    const out = Array.isArray(selectedChunks) ? selectedChunks.slice() : [];
                    const seen = new Set(out.map(item => item.id));
                    const docNames = uniqueBy(out.map(item => item.filename).filter(Boolean), item => item);
                    if (!docNames.length) return out;
                    const qTokens = this.tokenize(query);

                    for (const filename of docNames) {
                        const docChunks = (this.allChunks || [])
                            .filter(item => item.filename === filename)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));
                        if (docChunks.length < 4) continue;

                        const midIdx = Math.floor(docChunks.length / 2);
                        const lateIdx = Math.floor(docChunks.length * 0.8);
                        const deepCandidates = [docChunks[midIdx], docChunks[lateIdx], docChunks[docChunks.length - 1]]
                            .filter(Boolean)
                            .map(chunk => ({
                                ...chunk,
                                score: this.calculateRelevanceScore(chunk, query, qTokens, this.extractEntities(query), this.extractConcepts(query))
                            }))
                            .sort((a, b) => (b.score || 0) - (a.score || 0));

                        for (const candidate of deepCandidates) {
                            if (out.length >= targetTopK) break;
                            if (!candidate?.id || seen.has(candidate.id)) continue;
                            out.push(candidate);
                            seen.add(candidate.id);
                        }
                        if (out.length >= targetTopK) break;
                    }

                    return out.slice(0, targetTopK);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainRunRetrievalRefinement !== 'function') {
                CognitiveRetriever.prototype.superBrainRunRetrievalRefinement = async function superBrainRunRetrievalRefinement(query, seedChunks = [], topK = FULL_SCAN_MIN_TOPK, options = {}, intent = {}, originalRetrieve = null) {
                    if (typeof originalRetrieve !== 'function') {
                        return {
                            chunks: seedChunks || [],
                            passes: 1,
                            stabilized: true,
                            intentGraph: this.superBrainBuildIntentGraph(query),
                            predictiveModel: this.superBrainBuildPredictiveModel(query, this.superBrainBuildIntentGraph(query), intent)
                        };
                    }

                    const intentGraph = this.superBrainBuildIntentGraph(query);
                    const predictiveModel = this.superBrainBuildPredictiveModel(query, intentGraph, intent);
                    const probes = this.superBrainBuildProbeQueries(query, intentGraph, intent, predictiveModel);
                    let merged = Array.isArray(seedChunks) ? seedChunks.slice() : [];
                    let passes = 1;
                    let stableHits = 0;
                    let prevChunkCount = merged.length;
                    let prevDocCount = new Set(merged.map(item => item.filename)).size;

                    for (const probe of probes) {
                        if (passes >= MAX_RETRIEVAL_REFINEMENT_PASSES) break;
                        let probeResults = [];
                        try {
                            probeResults = await originalRetrieve.call(
                                this,
                                probe,
                                Math.max(FULL_SCAN_MIN_TOPK, Math.ceil(topK * 0.8)),
                                { ...options, intent: { ...intent, broadCoverage: true } }
                            );
                        } catch {
                            probeResults = [];
                        }
                        const anchors = this.getPerDocumentAnchors(probe, { ...intent, broadCoverage: true });
                        const links = this.expandImplicitLinks(probeResults, probe, Math.max(10, Math.floor(MAX_CONCEPT_EXPANSION * 0.8)));
                        const mergedProbe = this.mergeUniqueChunks(
                            this.mergeUniqueChunks(probeResults || [], anchors || [], Math.max(topK * 2, 96)),
                            links || [],
                            Math.max(topK * 3, 128)
                        );
                        merged = this.mergeUniqueChunks(merged, mergedProbe, Math.max(topK * 4, 180));

                        const chunkCount = merged.length;
                        const docCount = new Set(merged.map(item => item.filename)).size;
                        const chunkDelta = chunkCount - prevChunkCount;
                        const docDelta = docCount - prevDocCount;
                        if (docDelta <= 0 && chunkDelta <= RETRIEVAL_STABLE_CHUNK_DELTA) stableHits += 1;
                        else stableHits = 0;
                        prevChunkCount = chunkCount;
                        prevDocCount = docCount;
                        passes += 1;
                        if (stableHits >= 1) break;
                    }

                    return {
                        chunks: merged,
                        passes,
                        stabilized: stableHits >= 1,
                        intentGraph,
                        predictiveModel
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainContradictionSignalScore !== 'function') {
                CognitiveRetriever.prototype.superBrainContradictionSignalScore = function superBrainContradictionSignalScore(text) {
                    const value = String(text || '').toLowerCase();
                    if (!value) return 0;
                    const patterns = [
                        /\bhowever\b/g,
                        /\bbut\b/g,
                        /\bexcept\b/g,
                        /\bunless\b/g,
                        /\balthough\b/g,
                        /\bdespite\b/g,
                        /\blimit(?:ation|ed|s)?\b/g,
                        /\bconstraint(?:s)?\b/g,
                        /\brisk(?:s)?\b/g,
                        /\bcounter(?:example|evidence)?\b/g,
                        /\bcontradict(?:s|ion|ory)?\b/g,
                        /\bfail(?:ure|s|ed|ing)?\b/g
                    ];
                    let score = 0;
                    for (const pattern of patterns) {
                        const matches = value.match(pattern);
                        if (matches?.length) score += Math.min(2, matches.length) * 0.5;
                    }
                    return Math.min(6, score);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildAdversarialQueries !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildAdversarialQueries = function superBrainBuildAdversarialQueries(query, seedChunks = [], intentGraph = null, predictiveModel = null) {
                    const graph = intentGraph || this.superBrainBuildIntentGraph(query);
                    const predictive = predictiveModel || this.superBrainBuildPredictiveModel(query, graph, {});
                    const probes = [];
                    const push = (value) => {
                        const cleaned = String(value || '').replace(/\s+/g, ' ').trim();
                        if (!cleaned) return;
                        probes.push(cleaned);
                    };
                    push(`${query} contradictory evidence limitations exceptions`);
                    push(`${query} counterexamples boundary conditions`);
                    push(`${query} risks unintended consequences failure modes`);
                    if (graph.constraints?.length) {
                        push(`${query} constraints violated edge cases`);
                    }
                    if (graph.relations?.length) {
                        push(`${query} alternative causal explanation contradictory evidence`);
                    }
                    const seedConcepts = uniqueBy(
                        (seedChunks || []).flatMap(chunk => this.extractSemanticConcepts(chunk?.text || '')),
                        item => normalizeTextLite(item)
                    ).slice(0, 6);
                    if (seedConcepts.length) {
                        push(`${query} ${seedConcepts.join(' ')} contradictions exceptions`);
                    }
                    if (predictive?.anticipatedConclusion) {
                        push(`${query} evidence that challenges this expectation: ${predictive.anticipatedConclusion}`);
                    }
                    return uniqueBy(probes, item => normalizeTextLite(item)).slice(0, MAX_ADVERSARIAL_RETRIEVAL_PASSES + 2);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainRunAdversarialRetrieval !== 'function') {
                CognitiveRetriever.prototype.superBrainRunAdversarialRetrieval = async function superBrainRunAdversarialRetrieval(
                    query,
                    seedChunks = [],
                    options = {},
                    intent = {},
                    originalRetrieve = null
                ) {
                    if (typeof originalRetrieve !== 'function') {
                        return { chunks: [], passes: 0, probes: [] };
                    }
                    const intentGraph = this.superBrainBuildIntentGraph(query);
                    const predictiveModel = options?.predictiveModel || this.superBrainBuildPredictiveModel(query, intentGraph, intent);
                    const probes = this.superBrainBuildAdversarialQueries(query, seedChunks, intentGraph, predictiveModel);
                    let passes = 0;
                    let aggregated = [];

                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);

                    for (const probe of probes) {
                        if (passes >= MAX_ADVERSARIAL_RETRIEVAL_PASSES) break;
                        passes += 1;

                        let retrieved = [];
                        try {
                            retrieved = await originalRetrieve.call(
                                this,
                                probe,
                                Math.max(FULL_SCAN_MIN_TOPK, 18),
                                { ...options, intent: { ...intent, broadCoverage: true, comparative: true } }
                            );
                        } catch {
                            retrieved = [];
                        }

                        const anchors = this.getPerDocumentAnchors(probe, { ...intent, broadCoverage: true, comparative: true });
                        const mergedProbe = this.mergeUniqueChunks(retrieved || [], anchors || [], 96);
                        const scoredProbe = (mergedProbe || []).map(chunk => {
                            const lexical = chunk?.score || this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts);
                            const contradictionSignal = this.superBrainContradictionSignalScore(chunk?.text || '');
                            const score = lexical * 0.72 + Math.min(5, contradictionSignal) * 0.09;
                            return { ...chunk, score, adversarialSignal: contradictionSignal, adversarialProbe: probe };
                        }).sort((a, b) => (b.score || 0) - (a.score || 0));

                        aggregated = this.mergeUniqueChunks(aggregated, scoredProbe, 220);
                    }

                    const prioritized = uniqueBy(
                        aggregated
                            .filter(item => (item?.adversarialSignal || 0) > 0)
                            .sort((a, b) => ((b.adversarialSignal || 0) - (a.adversarialSignal || 0)) || ((b.score || 0) - (a.score || 0))),
                        item => item?.id
                    );
                    const selected = prioritized.length
                        ? prioritized.slice(0, MAX_ADVERSARIAL_CHUNKS)
                        : uniqueBy(aggregated.sort((a, b) => (b.score || 0) - (a.score || 0)), item => item?.id).slice(0, Math.min(MAX_ADVERSARIAL_CHUNKS, 8));

                    return {
                        chunks: selected,
                        passes,
                        probes
                    };
                };
            }
        }

        function installSynthEnhancements(CognitiveSynthesizer) {
            if (!CognitiveSynthesizer || !CognitiveSynthesizer.prototype) return;

            if (typeof CognitiveSynthesizer.prototype.superBrainTokenize !== 'function') {
                CognitiveSynthesizer.prototype.superBrainTokenize = function superBrainTokenize(text) {
                    return normalizeTextLite(text).split(/\s+/).filter(t => t.length > 2 && !SUPER_BRAIN_STOP_WORDS.has(t));
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainFormatModelBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainFormatModelBlock = function superBrainFormatModelBlock(model) {
                    const relLines = (model.relationships || []).map(item => {
                        if (typeof item === 'string') return `- ${item}`;
                        const stmt = item?.statement || `${item?.subject || ''} ${item?.predicate || ''} ${item?.object || ''}`.trim();
                        return stmt ? `- ${stmt}` : null;
                    }).filter(Boolean);
                    return [
                        '## PRE-BUILT MENTAL MODEL (STRICT SOURCE-GROUNDED)',
                        `- Entities: ${(model.entities || []).join(', ') || 'N/A'}`,
                        `- Concepts: ${(model.concepts || []).join(', ') || 'N/A'}`,
                        '- Relationships:',
                        ...(relLines.length ? relLines : ['- N/A']),
                        '- Constraints:',
                        ...((model.constraints || []).length ? model.constraints.map(x => `- ${x}`) : ['- N/A']),
                        '- Assumptions:',
                        ...((model.assumptions || []).length ? model.assumptions.map(x => `- ${x}`) : ['- N/A']),
                        '- Evidence gaps:',
                        ...((model.gaps || []).length ? model.gaps.map(x => `- ${x}`) : ['- N/A'])
                    ].join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildMentalModel !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildMentalModel = async function superBrainBuildMentalModel(query, sources = [], activationReport = null) {
                    const selected = (sources || []).slice(0, MAX_MENTAL_MODEL_SOURCES);
                    const corpusText = selected.map(s => String(s.text || '')).join('\n');
                    const entities = Array.from(new Set(
                        (corpusText.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [])
                            .map(x => normalizeTextLite(x))
                            .filter(Boolean)
                    )).slice(0, 16);
                    const tokenFreq = new Map();
                    for (const token of this.superBrainTokenize(corpusText)) {
                        tokenFreq.set(token, (tokenFreq.get(token) || 0) + 1);
                    }
                    const concepts = Array.from(tokenFreq.entries())
                        .filter(([, c]) => c >= 3)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 18)
                        .map(([token]) => token);
                    const sentences = corpusText.split(/(?<=[.!?])\s+/);
                    const relationships = sentences
                        .filter(s => /\b(causes?|leads to|results? in|depends on|requires?|enables?|prevents?|increases?|decreases?)\b/i.test(s))
                        .slice(0, 10)
                        .map(s => ({ statement: s.trim().slice(0, 240) }));
                    const constraints = sentences
                        .filter(s => /\b(must|required|cannot|only|at least|at most|limit|constraint)\b/i.test(s))
                        .slice(0, 10)
                        .map(s => s.trim().slice(0, 220));
                    const assumptions = sentences
                        .filter(s => /\b(assume|assuming|likely|may|might|unclear)\b/i.test(s))
                        .slice(0, 8)
                        .map(s => s.trim().slice(0, 220));
                    const queryTokens = this.superBrainTokenize(query);
                    const evidenceTokenSet = new Set(this.superBrainTokenize(corpusText));
                    const gaps = queryTokens
                        .filter(t => !evidenceTokenSet.has(t))
                        .slice(0, 10)
                        .map(t => `Insufficient direct evidence for concept: "${t}"`);

                    const heuristic = { entities, concepts, relationships, constraints, assumptions, gaps };
                    if (!this.apiKey || selected.length === 0) return heuristic;

                    const digest = selected.map((s, i) => {
                        const page = s.page ? `page ${s.page}` : 'page N/A';
                        return `${i + 1}. [${s.filename}, ${page}] ${String(s.text || '').replace(/\s+/g, ' ').slice(0, 280)}`;
                    }).join('\n');
                    const activationLine = activationReport
                        ? `Activated documents: ${activationReport.activatedDocuments}/${activationReport.totalDocuments}; activated chunks: ${activationReport.activatedChunks}/${activationReport.totalChunks}.`
                        : '';

                    const messages = [
                        {
                            role: 'system',
                            content: 'You are an internal cognition module for strict RAG. Return ONLY valid JSON with keys: entities, concepts, relationships, constraints, assumptions, gaps. Use only provided evidence.'
                        },
                        {
                            role: 'user',
                            content: `Question: ${query}\n${activationLine}\nEvidence digest:\n${digest}`
                        }
                    ];
                    try {
                        const raw = await this.callCompletion(messages, { temperature: 0.1, max_tokens: 900, top_p: 0.9 });
                        const parsed = this.safeJsonParse(raw);
                        if (!parsed || typeof parsed !== 'object') return heuristic;
                        return {
                            entities: Array.isArray(parsed.entities) ? parsed.entities.slice(0, 16) : heuristic.entities,
                            concepts: Array.isArray(parsed.concepts) ? parsed.concepts.slice(0, 20) : heuristic.concepts,
                            relationships: Array.isArray(parsed.relationships) ? parsed.relationships.slice(0, 12) : heuristic.relationships,
                            constraints: Array.isArray(parsed.constraints) ? parsed.constraints.slice(0, 10) : heuristic.constraints,
                            assumptions: Array.isArray(parsed.assumptions) ? parsed.assumptions.slice(0, 10) : heuristic.assumptions,
                            gaps: Array.isArray(parsed.gaps) ? parsed.gaps.slice(0, 10) : heuristic.gaps
                        };
                    } catch {
                        return heuristic;
                    }
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBestSentence !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBestSentence = function superBrainBestSentence(text, queryTokens = []) {
                    const sentences = String(text || '')
                        .split(/(?<=[.!?])\s+/)
                        .map(s => s.trim())
                        .filter(Boolean);
                    if (!sentences.length) return String(text || '').slice(0, 220);
                    if (!queryTokens.length) return sentences[0].slice(0, 220);
                    let best = sentences[0];
                    let bestScore = -1;
                    for (const sentence of sentences) {
                        const lower = sentence.toLowerCase();
                        const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                        if (score > bestScore) {
                            best = sentence;
                            bestScore = score;
                        }
                    }
                    return best.slice(0, 240);
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildFullCorpusMapBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildFullCorpusMapBlock = function superBrainBuildFullCorpusMapBlock(query, sweep, maxChars = FULL_CORPUS_MAP_BLOCK_MAX_CHARS) {
                    if (!sweep || !Array.isArray(sweep.docSweeps) || sweep.docSweeps.length === 0) return '';
                    const queryTokens = this.superBrainTokenize(query);
                    const lines = [];
                    lines.push('## FULL-CORPUS DOCUMENT MAP SWEEP (DOCUMENT-BY-DOCUMENT)');
                    lines.push(`Documents swept: ${sweep.totalDocuments || sweep.docSweeps.length}`);
                    lines.push(`Total corpus chunks: ${sweep.totalChunks || 0}`);
                    lines.push(`Selected sweep anchors: ${sweep.totalSelectedChunks || 0}`);
                    lines.push('');

                    let charCount = lines.join('\n').length;
                    const remainingBudget = Math.max(2400, maxChars - charCount);
                    const perDocBudget = Math.max(120, Math.floor(remainingBudget / Math.max(1, sweep.docSweeps.length)));
                    const pushLine = (line) => {
                        lines.push(line);
                        charCount += line.length + 1;
                    };

                    for (let i = 0; i < sweep.docSweeps.length; i++) {
                        const doc = sweep.docSweeps[i];
                        const primary = (doc.selectedChunks || [])[0];
                        if (!primary) {
                            pushLine(`- DOC ${i + 1}: ${doc.filename} â€” no anchor chunks available.`);
                            continue;
                        }

                        const primarySentence = this.superBrainBestSentence(primary.text, queryTokens)
                            .replace(/\s+/g, ' ')
                            .trim()
                            .slice(0, Math.max(80, perDocBudget - 100));
                        const primaryQuote = primarySentence.slice(0, 110).replace(/"/g, '\'');
                        const primaryPage = primary.page || 'N/A';
                        pushLine(`- DOC ${i + 1}: ${doc.filename} -> ${primarySentence} [Source: ${doc.filename}, page ${primaryPage}, "${primaryQuote}"]`);

                        if (charCount > maxChars) {
                            pushLine('- Additional per-document evidence lines truncated for prompt budget safety; sweep execution still covered all documents.');
                            break;
                        }
                    }

                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildFullCorpusReduceBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildFullCorpusReduceBlock = function superBrainBuildFullCorpusReduceBlock(sweep) {
                    if (!sweep || !Array.isArray(sweep.docSweeps) || sweep.docSweeps.length === 0) return '';
                    const lines = [];
                    lines.push('## FULL-CORPUS REDUCE SYNTHESIS');
                    const crossConcepts = Array.isArray(sweep.crossConcepts) ? sweep.crossConcepts.slice(0, 14) : [];
                    if (crossConcepts.length) {
                        lines.push('- Cross-document concept bridges:');
                        for (const item of crossConcepts) {
                            lines.push(`- "${item.concept}" appears in ${item.docs} documents (${(item.files || []).join(', ')})`);
                        }
                    } else {
                        lines.push('- No strong repeated bridge concepts detected across multiple documents.');
                    }

                    const topDocs = sweep.docSweeps
                        .slice()
                        .sort((a, b) => (b.averageScore || 0) - (a.averageScore || 0))
                        .slice(0, 10);
                    if (topDocs.length) {
                        lines.push('- Highest query-aligned documents in full sweep:');
                        for (const doc of topDocs) {
                            lines.push(`- ${doc.filename} (avg anchor relevance ${(doc.averageScore || 0).toFixed(3)})`);
                        }
                    }
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildAdversarialEvidenceBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildAdversarialEvidenceBlock = function superBrainBuildAdversarialEvidenceBlock(query, adversarialState = null, maxItems = 8) {
                    const adversarialChunks = Array.isArray(adversarialState?.chunks)
                        ? adversarialState.chunks
                        : (Array.isArray(adversarialState) ? adversarialState : []);
                    if (!adversarialChunks.length) return '';
                    const queryTokens = this.superBrainTokenize(query);
                    const lines = [
                        '## ADVERSARIAL RETRIEVAL (DEVIL\'S ADVOCATE)',
                        '- Secondary retrieval pass explicitly searched for disconfirming evidence, exceptions, and limitations.',
                        `- Adversarial retrieval passes: ${adversarialState?.passes || 1}`
                    ];
                    let added = 0;
                    for (const chunk of adversarialChunks.slice(0, Math.max(3, maxItems))) {
                        const sentence = this.superBrainBestSentence(chunk.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        if (!sentence) continue;
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        lines.push(`- ${sentence.slice(0, 220)} [Source: ${chunk.filename || 'Unknown'}, page ${chunk.page || 'N/A'}, "${quote || 'relevant quote'}"]`);
                        added += 1;
                        if (added >= maxItems) break;
                    }
                    lines.push('- Required final-answer line: "While the primary evidence suggests X, the corpus also contains evidence that contradicts/modifies this conclusion: [Citation]."');
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildPerspectiveEvidenceBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildPerspectiveEvidenceBlock = function superBrainBuildPerspectiveEvidenceBlock(
                    query,
                    sources = [],
                    instructionProfile = {}
                ) {
                    const perspectiveMode = !!instructionProfile?.perspectiveMode || /\b(stakeholder|policy|should we|implement|impact|conflict|trade-?off|goals?)\b/i.test(String(query || ''));
                    if (!perspectiveMode) return '';

                    const candidates = [
                        { name: 'Operations', regex: /\b(operation|process|workflow|timeline|resource|capacity|implementation)\b/i },
                        { name: 'Risk/Compliance', regex: /\b(risk|compliance|regulation|legal|safety|policy|governance)\b/i },
                        { name: 'Financial', regex: /\b(cost|budget|expense|roi|price|funding|financial)\b/i },
                        { name: 'User/Stakeholder', regex: /\b(user|customer|student|patient|employee|stakeholder|experience)\b/i }
                    ];
                    const queryTokens = this.superBrainTokenize(query);
                    const lines = ['## PERSPECTIVE EVIDENCE MAP'];
                    const usedSources = new Set();
                    let perspectiveCount = 0;

                    for (const candidate of candidates) {
                        let chosen = null;
                        for (const source of (sources || [])) {
                            if (!source?.text || usedSources.has(source.id)) continue;
                            if (!candidate.regex.test(String(source.text))) continue;
                            chosen = source;
                            break;
                        }
                        if (!chosen) continue;
                        usedSources.add(chosen.id);
                        const sentence = this.superBrainBestSentence(chosen.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        if (!sentence) continue;
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        lines.push(`- From Perspective ${candidate.name}, the corpus highlights: ${sentence.slice(0, 220)} [Source: ${chosen.filename || 'Unknown'}, page ${chosen.page || 'N/A'}, "${quote || 'relevant quote'}"]`);
                        perspectiveCount += 1;
                        if (perspectiveCount >= 3) break;
                    }

                    if (perspectiveCount < 2) {
                        const fallback = uniqueBy(
                            (sources || []).filter(item => item?.text).slice(0, 6),
                            item => item?.id || `${item?.filename || 'unknown'}:${item?.index || 0}`
                        );
                        for (let i = 0; i < fallback.length && perspectiveCount < 2; i++) {
                            const source = fallback[i];
                            const label = perspectiveCount === 0 ? 'A' : 'B';
                            const sentence = this.superBrainBestSentence(source.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                            if (!sentence) continue;
                            const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                            lines.push(`- From Perspective ${label}, the corpus highlights: ${sentence.slice(0, 220)} [Source: ${source.filename || 'Unknown'}, page ${source.page || 'N/A'}, "${quote || 'relevant quote'}"]`);
                            perspectiveCount += 1;
                        }
                    }

                    if (perspectiveCount < 2) return '';
                    lines.push('- Use these perspectives to analyze conflicts in goals before final recommendation.');
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainEvidenceHierarchyWeight !== 'function') {
                CognitiveSynthesizer.prototype.superBrainEvidenceHierarchyWeight = function superBrainEvidenceHierarchyWeight(source, queryTokens = []) {
                    const filename = String(source?.filename || '').toLowerCase();
                    const text = String(source?.text || '');
                    const textLower = text.toLowerCase();
                    let authority = 0.45;
                    if (/\b(policy|manual|regulation|official|handbook|governance|guideline|o?fr)\b/.test(filename)) authority = 0.9;
                    else if (/\b(procedure|protocol|standard|framework)\b/.test(filename)) authority = 0.78;
                    else if (/\b(faq|summary|notes|announcement|memo|blog)\b/.test(filename)) authority = 0.56;

                    const yearMatches = filename.match(/\b(19|20)\d{2}\b/g) || text.match(/\b(19|20)\d{2}\b/g) || [];
                    const years = yearMatches.map(y => parseInt(y, 10)).filter(Number.isFinite);
                    const latestYear = years.length ? Math.max(...years) : null;
                    const nowYear = new Date().getFullYear();
                    let recency = 0.58;
                    if (latestYear) {
                        const delta = Math.max(0, nowYear - latestYear);
                        recency = Math.max(0.35, 1 - (delta / 14));
                    }

                    let relevance = 0.4;
                    if (queryTokens.length) {
                        const overlap = queryTokens.filter(token => textLower.includes(token)).length;
                        relevance = Math.min(1, (overlap / Math.max(1, queryTokens.length)) + 0.18);
                    }
                    const weighted = (authority * 0.42) + (recency * 0.24) + (relevance * 0.34);
                    return { authority, recency, relevance, weighted, latestYear };
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildPredictiveResolutionBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildPredictiveResolutionBlock = function superBrainBuildPredictiveResolutionBlock(
                    query,
                    predictiveModel = null,
                    sources = []
                ) {
                    if (!predictiveModel) return '';
                    const queryTokens = this.superBrainTokenize(query);
                    const hypotheses = Array.isArray(predictiveModel.hypotheses) ? predictiveModel.hypotheses : [];
                    const selectedSources = (sources || []).slice(0, 26);
                    const support = [];
                    const contradiction = [];
                    for (const source of selectedSources) {
                        const sentence = this.superBrainBestSentence(source?.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        if (!sentence) continue;
                        const lower = sentence.toLowerCase();
                        const contradictionSignal = /\b(however|but|except|unless|despite|contradict|override|supersede|limit)\b/.test(lower);
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        const line = `${sentence.slice(0, 220)} [Source: ${source.filename || 'Unknown'}, page ${source.page || 'N/A'}, "${quote || 'relevant quote'}"]`;
                        if (contradictionSignal) contradiction.push(line);
                        else support.push(line);
                    }

                    const lines = [
                        '## Predictive Model (Pre-Evidence Expectation)',
                        `- Anticipated conclusion: ${predictiveModel.anticipatedConclusion || 'N/A'}`,
                        '- Hypotheses:'
                    ];
                    if (hypotheses.length) {
                        for (const item of hypotheses.slice(0, MAX_PREDICTIVE_HYPOTHESES)) {
                            lines.push(`- (${item.type}) ${item.statement}`);
                        }
                    } else {
                        lines.push('- No explicit predictive hypotheses were generated.');
                    }
                    lines.push('', '## Prediction Errors, Tension Detection & Resolution');
                    if (support.length) {
                        lines.push('- Evidence that supports the predictive model:');
                        lines.push(...support.slice(0, 3).map(item => `- ${item}`));
                    }
                    if (contradiction.length) {
                        lines.push('- Prediction errors / disconfirming evidence:');
                        lines.push(...contradiction.slice(0, 3).map(item => `- ${item}`));
                    } else {
                        lines.push('- No major prediction errors detected in current evidence sample.');
                    }
                    lines.push('- Tension resolution rule: when baseline and exception conflict, apply contextual hierarchy (specific authoritative clause + scenario match + recency) to determine which evidence wins.');
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildContextualHierarchyBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildContextualHierarchyBlock = function superBrainBuildContextualHierarchyBlock(query, sources = []) {
                    const selected = uniqueBy(
                        (sources || []).filter(item => item?.text),
                        item => item?.id || `${item?.filename || 'unknown'}:${item?.index || 0}:${item?.page || 'na'}`
                    ).slice(0, 24);
                    if (!selected.length) return '';
                    const queryTokens = this.superBrainTokenize(query);
                    const ranked = selected.map(source => {
                        const weight = this.superBrainEvidenceHierarchyWeight(source, queryTokens);
                        return { source, ...weight };
                    }).sort((a, b) => b.weighted - a.weighted);
                    const winner = ranked[0];
                    const challenger = ranked[1];

                    const lines = ['## Contextual Hierarchy (Evidence Weighting)'];
                    lines.push('- Weighting dimensions: Authority (42%), Recency (24%), Contextual Relevance (34%).');
                    lines.push('- Top weighted evidence:');
                    for (const item of ranked.slice(0, 4)) {
                        lines.push(`- ${item.source.filename || 'Unknown'} -> score ${item.weighted.toFixed(2)} (authority ${item.authority.toFixed(2)}, recency ${item.recency.toFixed(2)}, relevance ${item.relevance.toFixed(2)})`);
                    }
                    if (winner) {
                        const sentence = this.superBrainBestSentence(winner.source.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        lines.push(`- Winning context source: ${winner.source.filename || 'Unknown'} [Source: ${winner.source.filename || 'Unknown'}, page ${winner.source.page || 'N/A'}, "${quote || 'relevant quote'}"]`);
                    }
                    if (winner && challenger) {
                        const why = winner.weighted >= challenger.weighted
                            ? `Evidence from ${winner.source.filename || 'top source'} wins over ${challenger.source.filename || 'secondary source'} due to higher weighted hierarchy score and better scenario fit.`
                            : `Evidence tension remains unresolved; additional authoritative material is required.`;
                        lines.push(`- Conflict resolution: ${why}`);
                    }
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainTokenOverlap !== 'function') {
                CognitiveSynthesizer.prototype.superBrainTokenOverlap = function superBrainTokenOverlap(tokensA = [], tokensB = []) {
                    if (!tokensA.length || !tokensB.length) return [];
                    const setB = new Set(tokensB);
                    const overlap = [];
                    for (const token of tokensA) {
                        if (setB.has(token)) overlap.push(token);
                    }
                    return Array.from(new Set(overlap));
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildContradictionBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildContradictionBlock = function superBrainBuildContradictionBlock(query, sources = [], maxPairs = CONTRADICTION_MAX_PAIRS, maxChars = CONTRADICTION_BLOCK_MAX_CHARS) {
                    const selected = (sources || []).slice(0, 180);
                    if (!selected.length) return '';

                    const restrictiveRegex = /\b(must|required|shall|cannot|can't|prohibited|not allowed|only|ineligible|restricted)\b/i;
                    const permissiveRegex = /\b(may|can|allowed|eligible|unless|either|or|option)\b/i;
                    const policyLikeRegex = /\b(policy|enrol|enroll|require|limit|program|course|admission|completion|eligible|ineligible)\b/i;

                    const restrictive = [];
                    const permissive = [];

                    for (const source of selected) {
                        const text = String(source.text || '');
                        if (!text) continue;
                        const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
                        for (const sentenceRaw of sentences) {
                            const sentence = sentenceRaw.replace(/\s+/g, ' ').trim();
                            if (sentence.length < 40 || sentence.length > 330) continue;
                            if (!policyLikeRegex.test(sentence)) continue;
                            const tokens = this.superBrainTokenize(sentence).slice(0, 28);
                            if (tokens.length < 5) continue;
                            const item = {
                                sentence,
                                tokens,
                                filename: source.filename || 'Unknown',
                                page: source.page || 'N/A'
                            };
                            if (restrictiveRegex.test(sentence)) restrictive.push(item);
                            if (permissiveRegex.test(sentence)) permissive.push(item);
                        }
                    }

                    if (!restrictive.length || !permissive.length) return '## CONTRADICTION CHECK\n- No high-signal policy contradictions detected in sampled evidence.';

                    const pairs = [];
                    const restrictHead = restrictive.slice(0, 90);
                    const permissiveHead = permissive.slice(0, 90);
                    for (const a of restrictHead) {
                        for (const b of permissiveHead) {
                            if (a.sentence === b.sentence) continue;
                            const overlap = this.superBrainTokenOverlap(a.tokens, b.tokens);
                            if (overlap.length < 4) continue;
                            const score = overlap.length + (a.filename !== b.filename ? 0.6 : 0);
                            pairs.push({ a, b, overlap, score });
                        }
                    }

                    const ordered = pairs.sort((x, y) => y.score - x.score);
                    const unique = [];
                    const seenIssues = new Set();
                    for (const pair of ordered) {
                        const issueKey = pair.overlap.slice(0, 4).join('|');
                        if (!issueKey || seenIssues.has(issueKey)) continue;
                        seenIssues.add(issueKey);
                        unique.push(pair);
                        if (unique.length >= maxPairs) break;
                    }

                    if (!unique.length) return '## CONTRADICTION CHECK\n- No high-signal policy contradictions detected in sampled evidence.';

                    const lines = ['## CONTRADICTION CHECK (CROSS-SOURCE TENSION TEST)'];
                    for (let i = 0; i < unique.length; i++) {
                        const pair = unique[i];
                        const issue = pair.overlap.slice(0, 5).join(', ');
                        const aQuote = pair.a.sentence.slice(0, 120).replace(/"/g, '\'');
                        const bQuote = pair.b.sentence.slice(0, 120).replace(/"/g, '\'');
                        lines.push(`- Potential tension ${i + 1} on: ${issue}`);
                        lines.push(`  - Restrictive evidence: ${pair.a.sentence.slice(0, 220)} [Source: ${pair.a.filename}, page ${pair.a.page}, "${aQuote}"]`);
                        lines.push(`  - Permissive/conditional evidence: ${pair.b.sentence.slice(0, 220)} [Source: ${pair.b.filename}, page ${pair.b.page}, "${bQuote}"]`);
                        lines.push('  - Resolution guidance: Treat as scope-dependent; verify whether condition/exceptions narrow applicability.');
                    }

                    let block = lines.join('\n');
                    if (block.length > maxChars) {
                        block = `${block.slice(0, maxChars - 120)}\n- Additional contradiction checks truncated for prompt budget safety.`;
                    }
                    return block;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainNormalizeCitationSyntax !== 'function') {
                CognitiveSynthesizer.prototype.superBrainNormalizeCitationSyntax = function superBrainNormalizeCitationSyntax(text) {
                    let out = String(text || '');
                    if (!out) return out;
                    out = out.replace(/\[(source)\s*:/gi, '[Source:');
                    out = out.replace(/\(Source:\s*([^)]+)\)/gi, '[Source: $1]');

                    // [Source: file, "quote"] -> [Source: file, page N/A, "quote"]
                    out = out.replace(/\[Source:\s*([^,\]\n]+)\s*,\s*"([^"]+)"\]/gi, '[Source: $1, page N/A, "$2"]');

                    // [Source: file, page X] -> include placeholder quote for clickable citation rendering.
                    out = out.replace(/\[Source:\s*([^,\]\n]+)\s*,\s*(?:page\s*)?([^,\]\n]+)\s*\]/gi, '[Source: $1, page $2, "citation excerpt unavailable"]');
                    return out;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainHasMalformedCitationPatterns !== 'function') {
                CognitiveSynthesizer.prototype.superBrainHasMalformedCitationPatterns = function superBrainHasMalformedCitationPatterns(text) {
                    const value = String(text || '');
                    if (!value) return false;
                    if (/\bCitations?:\s*\n/i.test(value) && !/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(value)) {
                        return true;
                    }
                    if (/\b[A-Za-z0-9._ -]+\.(?:pdf|docx|md)\s*\.\.\./i.test(value)) return true;
                    if (/\[Source:\s*[^\]]*$/m.test(value)) return true;
                    return false;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainExtractDistinctCitedDocs !== 'function') {
                CognitiveSynthesizer.prototype.superBrainExtractDistinctCitedDocs = function superBrainExtractDistinctCitedDocs(text) {
                    const value = String(text || '');
                    if (!value) return [];
                    let citations = [];
                    if (typeof this.extractCitations === 'function') {
                        citations = this.extractCitations(value) || [];
                    } else {
                        const regex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
                        let match;
                        while ((match = regex.exec(value)) !== null) {
                            citations.push({ filename: String(match[1] || '').trim() });
                        }
                    }
                    return uniqueBy(
                        citations.map(item => String(item?.filename || '').trim()).filter(Boolean),
                        item => normalizeTextLite(item)
                    );
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainEvaluateCognitiveDepth !== 'function') {
                CognitiveSynthesizer.prototype.superBrainEvaluateCognitiveDepth = function superBrainEvaluateCognitiveDepth(
                    query,
                    responseText,
                    instructionProfile = {},
                    diagnostics = null,
                    sources = [],
                    activationReport = {}
                ) {
                    const text = String(responseText || '');
                    const lower = text.toLowerCase();
                    const nonEmptyLines = text.split('\n').map(line => line.trim()).filter(Boolean);
                    const firstLine = nonEmptyLines[0] || '';
                    const firstParagraph = text.trim().slice(0, 260);
                    const broadOrDecision = !!instructionProfile?.decisionMode || /\b(overall|across|entire|comprehensive|compare|contrast|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                    const sourceDocCount = new Set((sources || []).map(item => item?.filename).filter(Boolean)).size;
                    const citedDocs = this.superBrainExtractDistinctCitedDocs(text);
                    const reasoningSignals = (lower.match(/\b(because|therefore|however|whereas|if|then|trade-?off|constraint|depends on|due to|implies|consequently|in turn)\b/g) || []).length;
                    const optionBulletSignals = (text.match(/^\s*(?:[-*]|\d+\.)\s+(?:option|approach|alternative|path|strategy)\b/gi) || []).length;
                    const optionLabelSignals = (text.match(/\boption\s*(?:1|2|3|a|b|c)\b/gi) || []).length;
                    const hasExecutiveSummarySection = /(^|\n)\s*#{1,3}\s*executive summary\b/i.test(text);
                    const hasDecisionFirst = /\bdecision\s*:/i.test(firstLine) || /^\s*##\s*executive summary\b/i.test(firstLine) || /\bdecision\s*:/i.test(firstParagraph);
                    const hasReasoningPathSection = /(^|\n)\s*#{1,3}\s*reasoning path\b/i.test(text) || /\breasoning path\s*:/i.test(lower);
                    const hasActionableStepsSection = /(^|\n)\s*#{1,3}\s*actionable steps\b/i.test(text) || /(^|\n)\s*#{1,3}\s*next steps\b/i.test(text);
                    const hasPredictiveModelSection = /(^|\n)\s*#{1,3}\s*predictive model\b/i.test(text);
                    const hasTensionResolutionSection = /(^|\n)\s*#{1,3}\s*(prediction errors?|tension detection|tension resolution)\b/i.test(text) || /\bprediction error\b/i.test(lower);
                    const hasContextHierarchySection = /(^|\n)\s*#{1,3}\s*contextual hierarchy\b/i.test(text) || /\bweighting dimensions\b/i.test(lower) || /\bauthority\b.*\brecency\b.*\brelevance\b/i.test(lower);
                    const listStyleDocNarration = /\b(doc(?:ument)?\s*[a-z0-9]+\s+says|doc(?:ument)?\s*[a-z0-9]+\s+states)\b/i.test(text);
                    const hasMentalModelSection = /(^|\n)\s*#{1,3}\s*mental model\b/i.test(text) || /\bmental model\b/i.test(lower);
                    const hasHumanLoopSection = /(^|\n)\s*#{1,3}\s*human cognitive processing loop\b/i.test(text);
                    const hasEvidenceSection = /(^|\n)\s*#{1,3}\s*(evidence-based expert analysis|evidence synthesis|evidence-based answer|evidence-based analysis)\b/i.test(text) || /\bevidence[- ]based\b/i.test(lower);
                    const hasFrameworkSection = /(^|\n)\s*#{1,3}\s*(analytical framework|pros\s*\/\s*cons|pros and cons|stakeholder analysis|causal chain|strengths?\s*\/\s*weaknesses?|swot)\b/i.test(text) ||
                        (/\bpros\b/i.test(lower) && /\bcons\b/i.test(lower));
                    const hasExplicitFactsSection = /(^|\n)\s*#{1,3}\s*(explicit(?:ly)? stated facts|explicit facts)\b/i.test(text) || /\bFact:\b/.test(text);
                    const hasInferredImplicationsSection = /(^|\n)\s*#{1,3}\s*(inferred implications|inferences?)\b/i.test(text) || /\bInference:\b/.test(text);
                    const hasFactInferenceDistinction = hasExplicitFactsSection && hasInferredImplicationsSection;
                    const hasUncertaintySection = /(^|\n)\s*#{1,3}\s*uncertainties?\s*&\s*missing information\b/i.test(text) || /uncertaint|missing information|evidence gap|cannot fully confirm/i.test(lower);
                    const minReasoningSignals = instructionProfile?.decisionMode ? MIN_DECISION_REASONING_SIGNALS : MIN_ANALYSIS_REASONING_SIGNALS;
                    const hasReasoningDepth = reasoningSignals >= minReasoningSignals;
                    const hasCitationCoverage = diagnostics ? (diagnostics.claimCitationCoverage || 0) >= Math.max(0.5, CLAIM_CITATION_TARGET - 0.03) : true;
                    const hasCitationPrecision = diagnostics ? (diagnostics.citationPrecision || 0) >= Math.max(0.45, CITATION_PRECISION_TARGET - 0.03) : true;
                    const crossSourceExpected = broadOrDecision && sourceDocCount >= MIN_CROSS_SOURCE_DOCS;
                    const crossSourceSatisfied = !crossSourceExpected || citedDocs.length >= Math.min(MIN_CROSS_SOURCE_DOCS, sourceDocCount);
                    const perspectiveMode = !!instructionProfile?.perspectiveMode || /\b(stakeholder|policy|should we|implement|impact|conflict|trade-?off|goals?)\b/i.test(String(query || ''));
                    const adversarialMode = !!instructionProfile?.adversarialMode || broadOrDecision;
                    const perspectiveMentions = (text.match(/\bfrom perspective\s+[a-z0-9]/gi) || []).length;
                    const hasPerspectiveSection = /(^|\n)\s*#{1,3}\s*(perspective analysis|stakeholder perspectives?|multi-?perspective)\b/i.test(text) || perspectiveMentions >= 2;
                    const hasAdversarialLine = /while the primary evidence suggests/i.test(lower) &&
                        /(contradicts|modifies|limits|exceptions?)/i.test(lower) &&
                        /while the primary evidence suggests[\s\S]{0,300}\[Source:/i.test(text);
                    const orderedSections = [
                        'executive summary',
                        'predictive model',
                        'prediction errors',
                        'contextual hierarchy',
                        'mental model',
                        'human cognitive processing loop',
                        'analytical framework',
                        'explicitly stated facts',
                        'inferred implications',
                        'evidence-based expert analysis'
                    ];
                    const sectionPositions = orderedSections.map(section => lower.indexOf(section));
                    let cohesiveOrder = true;
                    for (let i = 1; i < sectionPositions.length; i++) {
                        if (sectionPositions[i - 1] >= 0 && sectionPositions[i] >= 0 && sectionPositions[i] < sectionPositions[i - 1]) {
                            cohesiveOrder = false;
                            break;
                        }
                    }
                    const stageChecks = {
                        hasAttentionFilter: /\b(attention|salien|prioriti|signal-to-noise|noise filtering|filtering)\b/i.test(lower),
                        hasPerceptionInterpretation: /\b(perception|interpret|contextual|context interpretation|sensemaking|meaning)\b/i.test(lower),
                        hasDualProcess: /\b(system\s*1|system\s*2|fast thinking|slow thinking|heuristic|analytical pass|deliberate)\b/i.test(lower),
                        hasDecisionStep: /\b(decision|recommend|choose|option|trade-?off)\b/i.test(lower),
                        hasActionStep: /\b(action|next steps?|execution|implement|rollout|operational plan)\b/i.test(lower),
                        hasFeedbackLoop: /\b(feedback loop|monitor|measure|telemetry|iteration|reassess|update model|refine)\b/i.test(lower),
                        hasBiasCheck: /\b(bias|heuristic risk|confirmation bias|availability bias|debias|counter-bias)\b/i.test(lower)
                    };
                    const stageSignalCount = Object.values(stageChecks).filter(Boolean).length;
                    const minStageSignals = instructionProfile?.decisionMode
                        ? MIN_HUMAN_COGNITION_STAGE_SIGNALS_DECISION
                        : MIN_HUMAN_COGNITION_STAGE_SIGNALS;
                    const requiredStages = instructionProfile?.decisionMode
                        ? ['hasAttentionFilter', 'hasPerceptionInterpretation', 'hasDecisionStep', 'hasActionStep', 'hasFeedbackLoop']
                        : ['hasAttentionFilter', 'hasPerceptionInterpretation', 'hasActionStep', 'hasFeedbackLoop'];
                    const missingRequiredStages = requiredStages.filter(key => !stageChecks[key]);
                    const stageLabels = {
                        hasAttentionFilter: 'attention filtering',
                        hasPerceptionInterpretation: 'perception and interpretation',
                        hasDualProcess: 'dual-process reasoning',
                        hasDecisionStep: 'decision stage',
                        hasActionStep: 'action stage',
                        hasFeedbackLoop: 'feedback loop',
                        hasBiasCheck: 'bias/heuristic check'
                    };

                    const reasons = [];
                    if (!hasExecutiveSummarySection) reasons.push('Missing "Executive Summary" section.');
                    if (!hasDecisionFirst) reasons.push('Output must start with a definitive decision before supporting detail.');
                    if (!hasReasoningPathSection) reasons.push('Missing explicit "Reasoning Path" section.');
                    if (!hasActionableStepsSection) reasons.push('Missing explicit actionable steps / next steps section.');
                    if (!hasPredictiveModelSection) reasons.push('Missing "Predictive Model" section.');
                    if (!hasTensionResolutionSection) reasons.push('Missing prediction-error/tension-resolution section.');
                    if (!hasContextHierarchySection) reasons.push('Missing contextual hierarchy weighting (authority/recency/relevance) section.');
                    if (listStyleDocNarration) reasons.push('Response uses list-style document narration ("Doc A says..."), which violates synthesis rule.');
                    if (!hasMentalModelSection) reasons.push('Missing explicit "Mental Model" section.');
                    if (!hasHumanLoopSection) reasons.push('Missing "Human Cognitive Processing Loop" section.');
                    if (!hasEvidenceSection) reasons.push('Missing explicit evidence-based analysis section.');
                    if (!hasFrameworkSection) reasons.push('Missing a structured analytical framework (Pros/Cons, Stakeholder Analysis, Causal Chain, or Strength/Weakness).');
                    if (!hasFactInferenceDistinction) reasons.push('Missing explicit distinction between "Explicitly Stated Facts" and "Inferred Implications".');
                    if (!hasUncertaintySection) reasons.push('Missing "Uncertainties & Missing Information" section.');
                    if (!hasReasoningDepth) reasons.push('Reasoning depth is weak (insufficient causal/trade-off signals).');
                    if (!hasCitationCoverage) reasons.push('Claim citation coverage is below required threshold.');
                    if (!hasCitationPrecision) reasons.push('Citation precision is below required threshold.');
                    if (!crossSourceSatisfied) reasons.push('Cross-source reasoning is weak (insufficient distinct cited documents).');
                    if (!cohesiveOrder) reasons.push('Output is not organized as a cohesive analyst brief (section order is inconsistent).');
                    if (adversarialMode && !hasAdversarialLine) reasons.push('Missing required adversarial statement ("While the primary evidence suggests X ... contradicts/modifies ...").');
                    if (perspectiveMode && !hasPerspectiveSection) reasons.push('Perspective-taking is missing (need at least two stakeholder viewpoints).');
                    if (stageSignalCount < minStageSignals) {
                        reasons.push(`Human cognitive cycle is incomplete (${stageSignalCount}/${minStageSignals} stage signals).`);
                    }
                    if (missingRequiredStages.length) {
                        reasons.push(`Missing required cognitive stages: ${missingRequiredStages.map(key => stageLabels[key] || key).join(', ')}.`);
                    }
                    if (instructionProfile?.decisionMode && !stageChecks.hasDualProcess) {
                        reasons.push('Decision analysis must include dual-process reasoning (fast hypothesis + slow analytical validation).');
                    }
                    if (!stageChecks.hasBiasCheck) {
                        reasons.push('Missing heuristic/bias risk check and mitigation.');
                    }

                    const decisionChecks = {
                        hasOptionsTradeoffs: /(^|\n)\s*#{1,3}\s*(options?\s*&\s*trade-?offs?|trade-?offs?|options?)\b/i.test(text) || /trade-?off|option|alternative|pros|cons/i.test(lower),
                        hasRecommendation: /(^|\n)\s*#{1,3}\s*recommendation\b/i.test(text) || /\brecommend(?:ed|ation)?\b/i.test(lower),
                        hasRisks: /(^|\n)\s*#{1,3}\s*risks?\b/i.test(text) || /\brisk(s)?\b/i.test(lower),
                        hasMultipleOptions: optionBulletSignals >= 2 || optionLabelSignals >= 2
                    };
                    if (instructionProfile?.decisionMode) {
                        if (!decisionChecks.hasOptionsTradeoffs) reasons.push('Decision output missing "Options & Trade-offs".');
                        if (!decisionChecks.hasRecommendation) reasons.push('Decision output missing explicit recommendation.');
                        if (!decisionChecks.hasRisks) reasons.push('Decision output missing explicit risk analysis.');
                        if (!decisionChecks.hasMultipleOptions) reasons.push('Decision output does not compare multiple concrete options.');
                    }

                    return {
                        passed: reasons.length === 0,
                        reasons,
                        broadOrDecision,
                        sourceDocCount,
                        citedDocCount: citedDocs.length,
                        citedDocs: citedDocs.slice(0, 8),
                        hasExecutiveSummarySection,
                        hasDecisionFirst,
                        hasReasoningPathSection,
                        hasActionableStepsSection,
                        hasPredictiveModelSection,
                        hasTensionResolutionSection,
                        hasContextHierarchySection,
                        listStyleDocNarration,
                        reasoningSignals,
                        minReasoningSignals,
                        hasFrameworkSection,
                        hasFactInferenceDistinction,
                        perspectiveMode,
                        hasPerspectiveSection,
                        perspectiveMentions,
                        adversarialMode,
                        hasAdversarialLine,
                        cohesiveOrder,
                        crossSourceExpected,
                        crossSourceSatisfied,
                        stageChecks,
                        stageSignalCount,
                        minStageSignals,
                        missingRequiredStages,
                        stageLabels,
                        decisionChecks,
                        activationCoverage: activationReport?.activationCoveragePct || 0
                    };
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildAnalyticalRewriteInstruction !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildAnalyticalRewriteInstruction = function superBrainBuildAnalyticalRewriteInstruction(
                    query,
                    instructionProfile = {},
                    depthGate = null,
                    sources = []
                ) {
                    const sourceDocCount = new Set((sources || []).map(item => item?.filename).filter(Boolean)).size;
                    const decisionMode = !!instructionProfile?.decisionMode;
                    const perspectiveMode = !!instructionProfile?.perspectiveMode;
                    const adversarialMode = !!instructionProfile?.adversarialMode || decisionMode;
                    const minCitations = sourceDocCount >= 10 ? MIN_RICH_CORPUS_CITATIONS : (sourceDocCount >= 4 ? 2 : (sourceDocCount > 0 ? 1 : 0));
                    const lines = [
                        'ANALYSIS-DEPTH REWRITE GATE (MANDATORY)',
                        `Question: ${query}`,
                        'Do NOT summarize. Produce a cohesive analyst brief that separates evidence from inference and then reasons to a decision/action.',
                        '',
                        'Mandatory output scaffold:',
                        '## Executive Summary',
                        'Decision: <definitive answer>',
                        'Reasoning Path: <why this conclusion wins>',
                        'Actionable Steps: <what to do next>',
                        '## Predictive Model',
                        '## Prediction Errors, Tension Detection & Resolution',
                        '## Contextual Hierarchy',
                        '## Mental Model',
                        '## Human Cognitive Processing Loop',
                        '## Analytical Framework',
                        '## Explicitly Stated Facts',
                        '## Inferred Implications',
                        '## Evidence-Based Expert Analysis'
                    ];
                    lines.push('- In "Human Cognitive Processing Loop", explicitly include:');
                    lines.push('  1) Evidence Intake (sensation proxy from retrieved documents)');
                    lines.push('  2) Attention Filtering (signal vs noise)');
                    lines.push('  3) Perception & Context Interpretation');
                    lines.push('  4) Dual-process reasoning (System 1 hypothesis + System 2 analytical verification)');
                    lines.push('  5) Decision & Action path');
                    lines.push('  6) Feedback Loop (what to monitor and how model updates)');
                    lines.push('  7) Heuristic/Bias risk check and mitigation');
                    if (decisionMode) {
                        lines.push('## Options & Trade-offs');
                        lines.push('## Recommendation');
                        lines.push('## Risks');
                    }
                    if (perspectiveMode) lines.push('## Perspective Analysis');
                    lines.push('## Uncertainties & Missing Information');
                    lines.push('');
                    lines.push(`Minimum citation target for this rewrite: ${minCitations} citations in exact format [Source: filename, page X, "brief relevant quote"].`);
                    if (sourceDocCount >= MIN_CROSS_SOURCE_DOCS) {
                        lines.push(`Cross-source rule: cite at least ${Math.min(MIN_CROSS_SOURCE_DOCS, sourceDocCount)} distinct source documents when giving broad or decision conclusions.`);
                    }
                    if (decisionMode) {
                        lines.push('Decision rule: compare at least two concrete options with source-grounded trade-offs before recommending.');
                    }
                    lines.push('Coherence rule: keep section order exactly as scaffolded to produce one cohesive analyst brief (do not mix sections).');
                    lines.push('Framework rule: use one structured framework explicitly (Pros/Cons, Stakeholder Analysis, Causal Chain, or Strength/Weakness).');
                    lines.push('Fact-vs-inference rule: every inference must be linked to cited explicit facts.');
                    if (perspectiveMode) {
                        lines.push('Perspective rule: include at least two viewpoints with "From Perspective A..." and "From Perspective B..." plus citations.');
                    }
                    if (adversarialMode) {
                        lines.push('Adversarial rule: include this exact pattern with citation: "While the primary evidence suggests X, the corpus also contains evidence that contradicts/modifies this conclusion: [Citation]."');
                    }
                    const reasons = Array.isArray(depthGate?.reasons) ? depthGate.reasons.filter(Boolean) : [];
                    if (reasons.length) {
                        lines.push('');
                        lines.push('Fix these issues explicitly:');
                        for (const reason of reasons.slice(0, 8)) lines.push(`- ${reason}`);
                    }
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildGapDrivenQueries !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildGapDrivenQueries = function superBrainBuildGapDrivenQueries(query, model = null) {
                    const out = [];
                    const push = (value) => {
                        const cleaned = String(value || '').replace(/\s+/g, ' ').trim();
                        if (cleaned) out.push(cleaned);
                    };
                    push(`${query} cross-source supporting evidence`);
                    push(`${query} constraints exceptions conflicts`);
                    const gaps = Array.isArray(model?.gaps) ? model.gaps : [];
                    for (const gapRaw of gaps.slice(0, MAX_GAP_REFINEMENT_QUERIES)) {
                        const gap = String(gapRaw || '')
                            .replace(/^Insufficient direct evidence for concept:\s*/i, '')
                            .replace(/"/g, '')
                            .trim();
                        if (!gap) continue;
                        push(`${query} ${gap} validating evidence`);
                    }
                    return uniqueBy(out, item => normalizeTextLite(item)).slice(0, MAX_GAP_REFINEMENT_QUERIES + 2);
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainAssessEvidenceCompleteness !== 'function') {
                CognitiveSynthesizer.prototype.superBrainAssessEvidenceCompleteness = function superBrainAssessEvidenceCompleteness(
                    query,
                    sources = [],
                    model = null,
                    activationReport = {},
                    instructionProfile = {}
                ) {
                    const deduped = uniqueBy(
                        sources || [],
                        item => item?.id || `${item?.filename || 'unknown'}:${item?.index || 0}:${item?.page || 'na'}`
                    );
                    const sourceCount = deduped.length;
                    const docCount = new Set(deduped.map(item => item.filename).filter(Boolean)).size;
                    const totalDocs = activationReport.totalDocuments || docCount;
                    const broadOrDecision = !!instructionProfile?.decisionMode || /\b(overall|across|entire|comprehensive|compare|contrast|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                    const requiredDocs = broadOrDecision ? (totalDocs >= 7 ? 3 : Math.min(totalDocs, MIN_CROSS_SOURCE_DOCS)) : 1;
                    const activationCoverage = activationReport.activationCoveragePct || 0;
                    const gapCount = Array.isArray(model?.gaps) ? model.gaps.length : 0;

                    const reasons = [];
                    if (sourceCount === 0) reasons.push('No retrievable evidence was found for the question.');
                    if (requiredDocs > 1 && docCount < requiredDocs) {
                        reasons.push(`Cross-source coverage is insufficient (${docCount}/${requiredDocs} required documents).`);
                    }
                    if (broadOrDecision && totalDocs >= 5 && activationCoverage > 0 && activationCoverage < 22) {
                        reasons.push(`Activation coverage remains low for a broad query (${activationCoverage}%).`);
                    }
                    if (gapCount >= MODEL_GAP_THRESHOLD && docCount < Math.max(2, requiredDocs)) {
                        reasons.push('Mental model still has unresolved high-priority evidence gaps.');
                    }

                    const requestedDocuments = [];
                    if (sourceCount === 0) {
                        requestedDocuments.push(`Primary source documents directly addressing: "${query}"`);
                    }
                    if (requiredDocs > 1 && docCount < requiredDocs) {
                        requestedDocuments.push(`Additional relevant sources from at least ${requiredDocs} distinct documents are needed.`);
                    }
                    for (const gapRaw of (model?.gaps || []).slice(0, 5)) {
                        requestedDocuments.push(`Source material that explicitly covers: ${String(gapRaw).replace(/^Insufficient direct evidence for concept:\s*/i, '').replace(/"/g, '').trim()}`);
                    }

                    return {
                        needsMoreEvidence: reasons.length > 0,
                        sourceCount,
                        docCount,
                        totalDocs,
                        requiredDocs,
                        activationCoverage,
                        reasons: uniqueBy(reasons, item => item),
                        requestedDocuments: uniqueBy(requestedDocuments.filter(Boolean), item => item).slice(0, 8)
                    };
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildMissingEvidenceResponse !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildMissingEvidenceResponse = function superBrainBuildMissingEvidenceResponse(query, completeness, sources = [], model = null) {
                    const queryTokens = this.superBrainTokenize(query);
                    const evidenceLines = (sources || []).slice(0, 4).map(source => {
                        const sentence = this.superBrainBestSentence(source.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        if (!sentence) return null;
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        return `- ${sentence.slice(0, 210)} [Source: ${source.filename || 'Unknown'}, page ${source.page || 'N/A'}, "${quote || 'relevant quote'}"]`;
                    }).filter(Boolean);

                    const lines = [
                        '## Executive Summary',
                        'Decision: A definitive expert conclusion is deferred because required evidence is incomplete.',
                        'Reasoning Path: Current retrieval does not meet cross-source sufficiency and evidence-completeness thresholds for this query.',
                        'Actionable Steps: Provide the missing documents/data listed below, then rerun synthesis for a fully grounded answer.',
                        '',
                        '## Mental Model',
                        '- Status: Incomplete for a reliable expert conclusion.',
                        `- Query focus: ${query}`,
                        `- Current entities: ${(model?.entities || []).slice(0, 8).join(', ') || 'N/A'}`,
                        `- Current concepts: ${(model?.concepts || []).slice(0, 10).join(', ') || 'N/A'}`,
                        '',
                        '## Evidence-Based Status',
                        `- Source chunks reviewed: ${completeness?.sourceCount || 0}`,
                        `- Distinct documents covered: ${completeness?.docCount || 0}/${completeness?.requiredDocs || 1} required`,
                        completeness?.activationCoverage ? `- Activation coverage: ${completeness.activationCoverage}%` : '- Activation coverage: N/A'
                    ];

                    if (evidenceLines.length) {
                        lines.push('- Current grounded evidence:');
                        lines.push(...evidenceLines);
                    } else {
                        lines.push('- No citable evidence is currently available for this question.');
                    }

                    lines.push('', '## Explicitly Stated Facts (Available)');
                    if (evidenceLines.length) {
                        lines.push('- The evidence bullets above are directly supported by cited excerpts.');
                    } else {
                        lines.push('- No explicit facts can be asserted yet with citation confidence.');
                    }
                    lines.push('', '## Inferred Implications (Provisional)');
                    lines.push('- Any downstream implications are provisional until additional source material is provided.');

                    lines.push('', '## Human Cognitive Processing Loop Status');
                    lines.push('- Evidence intake (sensation proxy): limited by available retrieved documents.');
                    lines.push('- Attention filtering: partial; key signals identified but completeness is below threshold.');
                    lines.push('- Perception/interpretation: provisional and cannot be finalized.');
                    lines.push('- Dual-process reasoning (System1/System2): halted due to unresolved evidence gaps.');
                    lines.push('- Decision/action: deferred until required sources are provided.');
                    lines.push('- Feedback loop: upload requested documents, then rerun to update the model and recommendation.');
                    lines.push('- Bias/heuristic guard: withholding conclusion to avoid availability/confirmation bias from incomplete evidence.');

                    lines.push('', '## Uncertainties & Missing Information');
                    for (const reason of (completeness?.reasons || [])) lines.push(`- ${reason}`);
                    if (!completeness?.reasons?.length) lines.push('- Evidence is insufficient to produce a high-confidence answer.');
                    if (Array.isArray(model?.gaps) && model.gaps.length) {
                        lines.push('- Open evidence gaps:');
                        for (const gap of model.gaps.slice(0, 6)) lines.push(`- ${gap}`);
                    }

                    lines.push('', '## Required Documents/Data');
                    const requested = completeness?.requestedDocuments || [];
                    if (requested.length) {
                        requested.forEach((item, idx) => lines.push(`${idx + 1}. ${item}`));
                    } else {
                        lines.push('1. Additional source documents that directly answer unresolved parts of the question.');
                    }
                    lines.push('');
                    lines.push('Please provide the missing documents/data so I can complete a fully grounded, cross-source expert answer with precise citations.');
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainRunModelRefinementLoop !== 'function') {
                CognitiveSynthesizer.prototype.superBrainRunModelRefinementLoop = async function superBrainRunModelRefinementLoop(
                    query,
                    relevantChunks = [],
                    attachmentContext = null,
                    localStats = {},
                    instructionProfile = {}
                ) {
                    const retriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                    const broadOrDecision = !!instructionProfile?.decisionMode || /\b(overall|across|entire|comprehensive|compare|contrast|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                    let chunks = uniqueBy(relevantChunks || [], item => item.id || `${item.filename}:${item.index || 0}`);
                    let passes = 1;
                    let stableHits = 0;
                    let previousGapCount = null;
                    let model = null;
                    let completeness = null;

                    for (let cycle = 0; cycle < MAX_MODEL_REFINEMENT_PASSES; cycle++) {
                        passes = cycle + 1;
                        const sourcesForModel = uniqueBy(
                            [
                                ...(attachmentContext?.chunks || []).map(item => ({ ...item, filename: attachmentContext?.name || item.filename || 'attachment' })),
                                ...chunks
                            ],
                            item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                        ).slice(0, MAX_MENTAL_MODEL_SOURCES * 2);

                        model = await this.superBrainBuildMentalModel(query, sourcesForModel, localStats.activationReport || null);
                        completeness = this.superBrainAssessEvidenceCompleteness(
                            query,
                            sourcesForModel,
                            model,
                            localStats.activationReport || {},
                            instructionProfile
                        );

                        const gapCount = Array.isArray(model?.gaps) ? model.gaps.length : 0;
                        const gapDelta = previousGapCount === null ? null : Math.abs(gapCount - previousGapCount);
                        if (gapDelta !== null && gapDelta <= 1) stableHits += 1;
                        else stableHits = 0;
                        previousGapCount = gapCount;

                        const shouldRetrieveAgain = completeness.needsMoreEvidence &&
                            broadOrDecision &&
                            retriever &&
                            typeof retriever.retrieve === 'function' &&
                            stableHits < 1;
                        if (!shouldRetrieveAgain) break;

                        const gapQueries = this.superBrainBuildGapDrivenQueries(query, model);
                        if (!gapQueries.length) break;
                        const expanded = [];
                        for (const gapQuery of gapQueries.slice(0, MAX_GAP_REFINEMENT_QUERIES)) {
                            try {
                                const retrieved = await retriever.retrieve(gapQuery, null, {
                                    intent: {
                                        ...(typeof retriever.detectQueryIntent === 'function' ? retriever.detectQueryIntent(gapQuery) : {}),
                                        broadCoverage: true,
                                        comparative: true
                                    }
                                });
                                expanded.push(...(retrieved || []));
                            } catch {
                                // keep loop resilient on transient retrieval failures
                            }
                        }
                        if (!expanded.length) break;
                        const merged = uniqueBy([...chunks, ...expanded], item => item.id || `${item.filename}:${item.index || 0}`);
                        if (merged.length <= chunks.length + 1) {
                            stableHits += 1;
                            if (stableHits >= 1) break;
                        }
                        chunks = merged;
                    }

                    return {
                        chunks,
                        model,
                        completeness,
                        passes,
                        stabilized: stableHits >= 1
                    };
                };
            }
        }

        function tryInstall() {
            if (typeof CognitiveRetriever !== 'function' || typeof CognitiveSynthesizer !== 'function') return false;

            installRetrieverEnhancements(CognitiveRetriever);
            installSynthEnhancements(CognitiveSynthesizer);

            patchMethod(CognitiveRetriever, 'updateCorpus', (original) => function patchedUpdateCorpus(documents) {
                const result = original.call(this, documents);
                if (typeof this.buildSemanticBridgeGraph === 'function') this.buildSemanticBridgeGraph();
                return result;
            });

            patchMethod(CognitiveRetriever, 'retrieve', (original) => async function patchedRetrieve(query, topK = null, options = {}) {
                if (!this.allChunks?.length) return [];
                const retrievalQuery = this.superBrainResolveQueryFromSession(query);
                const baseIntent = options.intent || this.detectQueryIntent(query);
                const intent = { ...baseIntent, broadCoverage: true };
                const intentGraph = this.superBrainBuildIntentGraph(retrievalQuery);
                const predictiveModel = this.superBrainBuildPredictiveModel(retrievalQuery, intentGraph, intent);
                const corpusSize = this.allChunks.length;
                const targetTopK = topK ?? (corpusSize <= 80 ? FULL_SCAN_MIN_TOPK : Math.min(FULL_SCAN_MAX_TOPK, Math.ceil(corpusSize * 0.09)));

                const base = await original.call(this, retrievalQuery, Math.max(targetTopK, FULL_SCAN_MIN_TOPK), { ...options, intent, predictiveModel });
                const anchors = this.getPerDocumentAnchors(retrievalQuery, intent);
                let merged = this.mergeUniqueChunks(base, anchors, Math.max(targetTopK * 2, 90));
                const bridges = this.expandImplicitLinks(merged, retrievalQuery, MAX_CONCEPT_EXPANSION);
                merged = this.mergeUniqueChunks(merged, bridges, Math.max(targetTopK * 3, 120));

                const refinement = await this.superBrainRunRetrievalRefinement(
                    retrievalQuery,
                    merged,
                    targetTopK,
                    { ...options, predictiveModel },
                    intent,
                    original
                );
                merged = refinement.chunks;
                const effectivePredictiveModel = refinement?.predictiveModel || predictiveModel;
                const adversarial = await this.superBrainRunAdversarialRetrieval(
                    retrievalQuery,
                    merged,
                    { ...options, predictiveModel: effectivePredictiveModel },
                    intent,
                    original
                );
                const adversarialChunks = Array.isArray(adversarial?.chunks) ? adversarial.chunks : [];
                if (adversarialChunks.length) {
                    merged = this.mergeUniqueChunks(merged, adversarialChunks, Math.max(targetTopK * 4, 200));
                }

                let ranked = merged;
                if (this.shouldUseSemanticRerank(intent, merged, targetTopK)) {
                    const sem = await this.semanticRerank(retrievalQuery, merged, targetTopK, intent);
                    if (sem?.length) ranked = sem;
                } else {
                    ranked = merged.slice().sort((a, b) => (b.score || 0) - (a.score || 0));
                    ranked = this.diversifyResults(ranked, targetTopK);
                }

                // Guarantee broad document spread where possible.
                let out = [];
                const seenDocs = new Set();
                const desiredDocSpread = Math.min(this.documents.length, Math.max(1, Math.ceil(targetTopK * 0.7)));
                for (const chunk of ranked) {
                    if (out.length >= targetTopK) break;
                    if (seenDocs.size < desiredDocSpread && seenDocs.has(chunk.filename)) continue;
                    out.push(chunk);
                    seenDocs.add(chunk.filename);
                }
                if (out.length < targetTopK) {
                    for (const chunk of ranked) {
                        if (out.length >= targetTopK) break;
                        if (!out.some(x => x.id === chunk.id)) out.push(chunk);
                    }
                }

                out = this.superBrainDeepScanAugment(retrievalQuery, out, targetTopK);
                const broadQuestion = intent.broadCoverage || intent.comparative || intent.timeline ||
                    /\b(overall|across|entire|comprehensive|strategy|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                const requiredDocs = broadQuestion
                    ? (this.documents.length >= 7 ? 3 : Math.min(this.documents.length, MIN_CROSS_SOURCE_DOCS))
                    : 1;
                const currentDocs = new Set(out.map(item => item.filename).filter(Boolean));
                if (broadQuestion && this.documents.length >= MIN_CROSS_SOURCE_DOCS && currentDocs.size < requiredDocs) {
                    const crossAnchors = this.getPerDocumentAnchors(`${retrievalQuery} cross-source corroboration`, intent);
                    for (const anchor of crossAnchors) {
                        if (out.length >= targetTopK) break;
                        if (!anchor?.id || out.some(item => item.id === anchor.id)) continue;
                        if (currentDocs.size < requiredDocs && currentDocs.has(anchor.filename)) continue;
                        out.push(anchor);
                        if (anchor.filename) currentDocs.add(anchor.filename);
                    }
                }
                if (broadQuestion && adversarialChunks.length) {
                    for (const chunk of adversarialChunks) {
                        if (!chunk?.id || out.some(item => item.id === chunk.id)) continue;
                        if (out.length < targetTopK) {
                            out.push(chunk);
                        } else {
                            out[out.length - 1] = chunk;
                        }
                        if (out.length >= targetTopK) break;
                    }
                }

                this.lastActivationReport = this.buildActivationReport(query, out);
                this.lastActivationReport.retrievalPasses = refinement.passes || 1;
                this.lastActivationReport.retrievalStabilized = !!refinement.stabilized;
                this.lastActivationReport.requiredCrossSourceDocs = broadQuestion ? requiredDocs : 1;
                this.lastActivationReport.currentCrossSourceDocs = new Set(out.map(item => item.filename)).size;
                this.lastActivationReport.adversarialPasses = adversarial?.passes || 0;
                this.lastActivationReport.adversarialChunks = adversarialChunks.length;
                this.lastActivationReport.predictiveModel = effectivePredictiveModel;
                this.lastPredictiveModel = effectivePredictiveModel;
                this.lastAdversarialRetrieval = {
                    query,
                    passes: adversarial?.passes || 0,
                    probes: adversarial?.probes || [],
                    chunks: adversarialChunks.slice(0, MAX_ADVERSARIAL_CHUNKS)
                };
                try {
                    this.lastFullCorpusSweep = this.buildFullCorpusDocumentSweep(query, {
                        perDocMaxChunks: FULL_CORPUS_DOC_ANCHORS_PER_DOC,
                        perDocTopRelevant: FULL_CORPUS_DOC_TOP_RELEVANT
                    });
                } catch {
                    this.lastFullCorpusSweep = null;
                }
                return out.slice(0, targetTopK);
            });

            patchMethod(CognitiveSynthesizer, 'buildUserPrompt', (original) => function patchedBuildUserPrompt(query, instructionProfile = {}) {
                const base = original.call(this, query, instructionProfile);
                const format = instructionProfile?.requestedFormat || 'structured prose';
                const decisionMode = !!instructionProfile?.decisionMode;
                const perspectiveMode = !!instructionProfile?.perspectiveMode;
                const adversarialMode = !!instructionProfile?.adversarialMode || decisionMode;
                if (!decisionMode && !['structured prose', 'bullet list'].includes(format)) {
                    return base;
                }
                const sections = [
                    'Mandatory cognitive scaffold for this answer:',
                    '1) Executive Summary (Decision first, then Reasoning Path, then Actionable Steps)',
                    '2) Predictive Model (pre-evidence expectation)',
                    '3) Prediction Errors, Tension Detection & Resolution',
                    '4) Contextual Hierarchy (authority, recency, contextual relevance; explicitly state which source wins and why)',
                    '5) Mental Model',
                    '6) Human Cognitive Processing Loop (Evidence intake -> Attention filtering -> Perception/interpretation -> System1/System2 reasoning -> Decision/action -> Feedback loop -> Bias check)',
                    '7) Analytical Framework (Pros/Cons, Stakeholder Analysis, Causal Chain, or Strength/Weakness)',
                    '8) Explicitly Stated Facts',
                    '9) Inferred Implications',
                    '10) Evidence-Based Expert Analysis'
                ];
                if (decisionMode) {
                    sections.push('11) Options & Trade-offs (at least 2 options)');
                    sections.push('12) Recommendation');
                    sections.push('13) Risks');
                }
                if (perspectiveMode) {
                    sections.push(`${decisionMode ? '14' : '11'}) Perspective Analysis (at least two viewpoints)`);
                }
                sections.push(`${decisionMode ? (perspectiveMode ? '15' : '14') : (perspectiveMode ? '12' : '11')}) Uncertainties & Missing Information`);
                if (adversarialMode) {
                    sections.push('Include explicit adversarial sentence: "While the primary evidence suggests X, the corpus also contains evidence that contradicts/modifies this conclusion: [Citation]."');
                }
                sections.push('Synthesis rule: do NOT write "Doc A says X, Doc B says Y". Every conclusion sentence must integrate multiple evidence points.');
                sections.push('Do not output a summary-only response.');
                const scaffold = sections.join('\n');
                return `${base}\n\n${scaffold}`;
            });

            patchMethod(CognitiveSynthesizer, 'buildInstructionProfile', (original) => function patchedBuildInstructionProfile(query) {
                const profile = original.call(this, query);
                const decisionMode = /\b(recommend|recommendation|decision|should|best approach|manage|strategy|trade-?off|pros|cons|options?|what should|how to handle|policy approach)\b/i.test(String(query || ''));
                const perspectiveMode = /\b(stakeholder|policy|should we|implement|impact on|conflict|conflicting goals|audience|department|team|user group)\b/i.test(String(query || ''));
                const frameworkMode = /\b(framework|pros|cons|analysis|evaluate|assess|compare|trade-?off|root cause|causal|swot|strength|weakness)\b/i.test(String(query || '')) || decisionMode;
                const adversarialMode = /\b(decision|recommend|policy|should|trade-?off|compare|risk|exception|counter)\b/i.test(String(query || '')) || decisionMode;
                return {
                    ...profile,
                    strictSourceOnly: true,
                    freshPassRequired: true,
                    requireUncertaintySection: true,
                    executiveSummaryRequired: true,
                    predictiveCodingMode: true,
                    system2AnalyticalMode: true,
                    decisionMode,
                    perspectiveMode,
                    frameworkMode,
                    adversarialMode,
                    factInferenceMode: true
                };
            });

            patchMethod(CognitiveSynthesizer, 'getWorkingMemorySummary', () => function patchedWorkingMemorySummary() {
                const recent = Array.isArray(this.workingMemory) ? this.workingMemory.slice(-6) : [];
                if (!recent.length) {
                    return 'No prior conversational memory yet. Use this note only for dialogue continuity, not as factual evidence.';
                }
                const lines = recent.map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`);
                return [
                    'Conversation memory (continuity-only; not factual evidence):',
                    ...lines
                ].join('\n');
            });

            patchMethod(CognitiveSynthesizer, 'getSystemPrompt', (original) => function patchedSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
                const base = original.call(
                    this,
                    context,
                    corpusStats,
                    instructionProfile,
                    workingMemorySummary
                );
                const activation = corpusStats.activationReport || {};
                const conceptBridgeSummary = (activation.bridgeConcepts || []).slice(0, 8)
                    .map(x => `"${x.concept}" (${x.docs} docs)`)
                    .join(', ');
                const decisionRules = instructionProfile?.decisionMode ? [
                    '',
                    'DECISION-QUALITY MODE:',
                    '- Build a decision framework, not a summary.',
                    '- Include sections: Executive Summary, Predictive Model, Prediction Errors/Tension Resolution, Contextual Hierarchy, Problem Framing, Human Cognitive Processing Loop, Analytical Framework, Explicitly Stated Facts, Inferred Implications, Evidence Synthesis, Options & Trade-offs, Recommendation, Risks, Uncertainties.',
                    '- For each option, provide source-grounded pros/cons with citations.'
                ].join('\n') : '';
                const superRules = [
                    'STRICT EVIDENCE-GROUNDED RAG POLICY (MANDATORY)',
                    '- Use only retrieved source evidence for this request.',
                    '- Do NOT use prior chat memory as evidence.',
                    '- Prior-turn memory is allowed only for conversational continuity (co-reference, follow-up scope, user preferences).',
                    '- Do not produce summary-only output; produce expert analysis, trade-offs, decisions, and actionable recommendations.',
                    '- Follow this cognitive loop: Interpret intent -> Retrieve corpus-wide semantically -> Build mental model -> Reason -> Refine if gaps remain.',
                    '- Human cognition emulation loop (mandatory in answer): Evidence Intake -> Attention Filtering -> Perception/Interpretation -> Dual-process reasoning (System1 + System2) -> Decision/Action -> Feedback Loop -> Bias check.',
                    '- Use concise chain-of-thought style decomposition via explicit sectioned reasoning, grounded only in cited evidence.',
                    '- Predictive coding mandate: start with a "Predictive Model" hypothesis BEFORE evidence synthesis, then explicitly compute prediction errors and resolve tension.',
                    '- Deep scan policy: do not assume early document sections are sufficient; include mid/late evidence when relevant.',
                    '- Hard response scaffold for prose answers: Executive Summary (Decision first) -> Predictive Model -> Prediction Errors/Tension Resolution -> Contextual Hierarchy -> Mental Model -> Human Cognitive Processing Loop -> Analytical Framework -> Explicitly Stated Facts -> Inferred Implications -> Evidence-Based Expert Analysis -> (Options & Trade-offs -> Recommendation -> Risks for decision queries) -> Uncertainties & Missing Information.',
                    '- Executive summary mandate: first section must start with a definitive decision, followed by reasoning path and actionable steps.',
                    '- Synthesis rule: do not produce "Doc A says..., Doc B says..." style narration; each conclusion sentence must integrate multiple evidence points.',
                    '- Use one explicit analytical framework (Pros/Cons, Stakeholder Analysis, Causal Chain, or Strength/Weakness) as the logic skeleton.',
                    '- Explicitly separate direct evidence from inference using section labels: "Explicitly Stated Facts" and "Inferred Implications".',
                    '- Run adversarial synthesis: include the sentence "While the primary evidence suggests X, the corpus also contains evidence that contradicts/modifies this conclusion: [Citation]."',
                    '- If perspective or stakeholder conflict is relevant, include at least two explicit viewpoints: "From Perspective A..." and "From Perspective B..."',
                    '- For broad/decision queries, conclusions must be supported by multiple sources when available; do not rely on one dominant document.',
                    '- Build and apply a mental model before answering:',
                    '  1) key entities + concepts',
                    '  2) cross-source relationships',
                    '  3) constraints + assumptions',
                    '  4) gaps + uncertainties',
                    '- Every factual statement must carry a citation in exact format:',
                    '  [Source: filename, page X, "brief relevant quote"]',
                    '- Include a final section titled: "Uncertainties & Missing Information".',
                    '',
                    'Cognition priors inspired by:',
                    '- Toyota Frontier Research (human-like event understanding): https://global.toyota/en/mobility/frontier-research/43225436.html',
                    '- Nature: https://www.nature.com/articles/s41586-025-09215-4',
                    '- Neural Networks: https://pure.eur.nl/files/154436763/1-s2.0-S0925231224007240-main.pdf',
                    ...BRAIN_INSPIRED_PRIOR.map(item => `- ${item}`),
                    '',
                    'FULL-CORPUS ACTIVATION REPORT:',
                    `- Activated docs: ${activation.activatedDocuments || 0}/${activation.totalDocuments || 0}`,
                    `- Activated chunks: ${activation.activatedChunks || 0}/${activation.totalChunks || 0}`,
                    `- Coverage: ${activation.activationCoveragePct || 0}%`,
                    `- Retrieval passes: ${activation.retrievalPasses || 1} (stabilized: ${activation.retrievalStabilized ? 'yes' : 'no'})`,
                    `- Bridge concepts: ${conceptBridgeSummary || 'N/A'}`
                ].join('\n') + decisionRules;

                const contradictionBlock = String(corpusStats.superBrainContradictionBlock || '').slice(0, CONTRADICTION_BLOCK_MAX_CHARS);

                return [
                    base,
                    superRules,
                    corpusStats.superBrainPredictiveBlock || '',
                    corpusStats.superBrainHierarchyBlock || '',
                    corpusStats.superBrainMentalModelBlock || '',
                    corpusStats.superBrainPerspectiveBlock || '',
                    corpusStats.superBrainAdversarialBlock || '',
                    contradictionBlock,
                    corpusStats.fullCorpusMapSweepBlock || '',
                    corpusStats.fullCorpusReduceSweepBlock || ''
                ].filter(Boolean).join('\n\n');
            });

            patchMethod(CognitiveSynthesizer, 'synthesize', (original) => async function patchedSynthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
                const localStats = { ...(corpusStats || {}) };
                const requestProfile = typeof this.buildInstructionProfile === 'function'
                    ? this.buildInstructionProfile(query)
                    : {};
                if (!localStats.activationReport) {
                    const totalDocs = localStats.numDocs || new Set((relevantChunks || []).map(c => c.filename)).size;
                    const activatedDocs = new Set((relevantChunks || []).map(c => c.filename)).size;
                    localStats.activationReport = {
                        query,
                        totalDocuments: totalDocs,
                        totalChunks: localStats.numChunks || (relevantChunks || []).length,
                        activatedDocuments: activatedDocs,
                        activatedChunks: (relevantChunks || []).length,
                        activationCoveragePct: totalDocs ? Math.round((activatedDocs / totalDocs) * 100) : 100,
                        bridgeConcepts: (localStats.connectedConcepts || []).slice(0, 10).map(item => ({ concept: item.concept, docs: item.docCount }))
                    };
                }

                let fullCorpusSweep = localStats.fullCorpusSweep || null;
                if (!fullCorpusSweep) {
                    const appRetriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                    fullCorpusSweep = appRetriever?.lastFullCorpusSweep || null;
                }

                const refinement = await this.superBrainRunModelRefinementLoop(
                    query,
                    relevantChunks || [],
                    attachmentContext,
                    localStats,
                    requestProfile
                );
                const refinedChunks = Array.isArray(refinement?.chunks) && refinement.chunks.length
                    ? refinement.chunks
                    : (relevantChunks || []);
                localStats.superBrainRefinement = {
                    passes: refinement?.passes || 1,
                    stabilized: !!refinement?.stabilized
                };
                const appRetriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                if (appRetriever?.lastActivationReport) {
                    localStats.activationReport = { ...appRetriever.lastActivationReport };
                }
                let predictiveModel = localStats.superBrainPredictiveModel || null;
                if (!predictiveModel && appRetriever?.lastPredictiveModel) {
                    predictiveModel = appRetriever.lastPredictiveModel;
                }
                let adversarialRetrieval = localStats.superBrainAdversarialRetrieval || null;
                if (!adversarialRetrieval && appRetriever?.lastAdversarialRetrieval) {
                    adversarialRetrieval = appRetriever.lastAdversarialRetrieval;
                }
                if (!fullCorpusSweep && appRetriever?.lastFullCorpusSweep) {
                    fullCorpusSweep = appRetriever.lastFullCorpusSweep;
                }
                if (fullCorpusSweep) {
                    localStats.fullCorpusSweep = fullCorpusSweep;
                    localStats.fullCorpusMapSweepBlock = this.superBrainBuildFullCorpusMapBlock(query, fullCorpusSweep);
                    localStats.fullCorpusReduceSweepBlock = this.superBrainBuildFullCorpusReduceBlock(fullCorpusSweep);
                }

                const flatSources = [
                    ...(attachmentContext?.chunks || []).map(c => ({ ...c, filename: attachmentContext?.name || c.filename || 'attachment' })),
                    ...refinedChunks,
                    ...((fullCorpusSweep?.docSweeps || []).flatMap(doc => doc.selectedChunks || []))
                ];
                const dedupedSources = uniqueBy(
                    flatSources,
                    item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                ).slice(0, MAX_MENTAL_MODEL_SOURCES * 3);

                if (!adversarialRetrieval && dedupedSources.length) {
                    adversarialRetrieval = {
                        query,
                        passes: 0,
                        probes: [],
                        chunks: dedupedSources.slice(0, Math.min(MAX_ADVERSARIAL_CHUNKS, 8))
                    };
                }
                if (!predictiveModel) {
                    predictiveModel = {
                        query,
                        anticipatedConclusion: `Likely requires balancing baseline rules with context-specific exceptions for: ${query}`,
                        hypotheses: [],
                        expectedEvidenceNeeds: [],
                        weightingPriors: {}
                    };
                }
                localStats.superBrainPredictiveModel = predictiveModel;
                localStats.superBrainAdversarialRetrieval = adversarialRetrieval;
                localStats.superBrainContradictionBlock = this.superBrainBuildContradictionBlock(query, dedupedSources);
                localStats.superBrainAdversarialBlock = this.superBrainBuildAdversarialEvidenceBlock(query, adversarialRetrieval);
                localStats.superBrainPerspectiveBlock = this.superBrainBuildPerspectiveEvidenceBlock(query, dedupedSources, requestProfile);
                localStats.superBrainPredictiveBlock = this.superBrainBuildPredictiveResolutionBlock(query, predictiveModel, dedupedSources);
                localStats.superBrainHierarchyBlock = this.superBrainBuildContextualHierarchyBlock(query, dedupedSources);
                const mentalModel = refinement?.model || await this.superBrainBuildMentalModel(query, dedupedSources, localStats.activationReport);
                localStats.superBrainMentalModel = mentalModel;
                localStats.superBrainMentalModelBlock = this.superBrainFormatModelBlock(mentalModel);
                localStats.superBrainPreSynthesisCompleteness = refinement?.completeness || null;

                // Keep conversational memory for human continuity while enforcing
                // strict source-only evidence for factual content.
                let result;
                const prevSkipFlag = !!this.__skipCoreStrictPostProcessing;
                this.__skipCoreStrictPostProcessing = true;
                try {
                    result = await original.call(this, query, refinedChunks, attachmentContext, localStats);
                } finally {
                    this.__skipCoreStrictPostProcessing = prevSkipFlag;
                }

                if (!result || typeof result.response !== 'string') return result;

                const sources = Array.isArray(result.sources) ? result.sources : [];
                const diagnosticSources = uniqueBy(
                    [...sources, ...((fullCorpusSweep?.docSweeps || []).flatMap(doc => doc.selectedChunks || []))],
                    item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                );

                result.response = this.superBrainNormalizeCitationSyntax(result.response);
                let citationCount = this.countCitations(result.response);
                let needsUncertaintySection = !/uncertaint|missing information|evidence gap|cannot fully confirm/i.test(result.response);
                let malformedCitationSignals = this.superBrainHasMalformedCitationPatterns(result.response);
                const minCitationTarget = diagnosticSources.length >= 10 ? MIN_RICH_CORPUS_CITATIONS : (diagnosticSources.length >= 4 ? 2 : (diagnosticSources.length > 0 ? 1 : 0));
                let diagnostics = this.buildClaimCitationDiagnostics(result.response, diagnosticSources);
                const profileForChecks = result.meta?.instructionProfile || requestProfile;
                let depthGate = this.superBrainEvaluateCognitiveDepth(
                    query,
                    result.response,
                    profileForChecks,
                    diagnostics,
                    diagnosticSources,
                    localStats.activationReport || {}
                );
                const extraRepairNeeded = (
                    citationCount < minCitationTarget ||
                    needsUncertaintySection ||
                    diagnostics?.needsRepair ||
                    malformedCitationSignals ||
                    !depthGate.passed
                );

                if (extraRepairNeeded) {
                    const snippet = this.formatContext(diagnosticSources || [], 12000).contextText;
                    const repairInstruction = [
                        'REPAIR REQUIREMENTS:',
                        '1) Maintain strict source grounding.',
                        '2) Increase claim-level citations where factual statements are made.',
                        '3) Structure output as:',
                        '   - Executive Summary (Decision first, Reasoning Path, Actionable Steps)',
                        '   - Predictive Model',
                        '   - Prediction Errors, Tension Detection & Resolution',
                        '   - Contextual Hierarchy',
                        '   - Mental Model',
                        '   - Human Cognitive Processing Loop (evidence intake, attention filtering, perception/interpretation, System1/System2 reasoning, decision/action, feedback loop, bias check)',
                        '   - Analytical Framework',
                        '   - Explicitly Stated Facts',
                        '   - Inferred Implications',
                        '   - Evidence-Based Expert Analysis',
                        '   - Uncertainties & Missing Information',
                        '4) Do not summarize only; provide reasoning, trade-offs, perspective analysis, and recommended action when the question asks for decisions.',
                        '5) Include adversarial sentence with citation: "While the primary evidence suggests X, the corpus also contains evidence that contradicts/modifies this conclusion: [Citation]."',
                        '6) Avoid list-style narration like "Doc A says...". Integrate multiple evidence points per conclusion sentence.',
                        '7) Use prior chat memory only for continuity; do not treat it as factual evidence or hidden knowledge.',
                        '8) Normalize all citations to exact format [Source: filename, page X, "brief relevant quote"].',
                        `9) Fix cognitive-depth gate failures: ${(depthGate?.reasons || []).slice(0, 6).join(' | ') || 'None detected'}.`
                    ].join('\n');
                    const repaired = await this.verifyAndRepairAnswer(
                        query,
                        `${result.response}\n\n${repairInstruction}`,
                        result.meta?.instructionProfile || this.buildInstructionProfile(query),
                        `## EVIDENCE\n${snippet}`,
                        diagnostics
                    );
                    if (repaired?.trim()) {
                        result.response = this.superBrainNormalizeCitationSyntax(repaired.trim());
                        citationCount = this.countCitations(result.response);
                        needsUncertaintySection = !/uncertaint|missing information|evidence gap|cannot fully confirm/i.test(result.response);
                        malformedCitationSignals = this.superBrainHasMalformedCitationPatterns(result.response);
                        diagnostics = this.buildClaimCitationDiagnostics(result.response, diagnosticSources);
                        depthGate = this.superBrainEvaluateCognitiveDepth(
                            query,
                            result.response,
                            profileForChecks,
                            diagnostics,
                            diagnosticSources,
                            localStats.activationReport || {}
                        );
                    }
                }

                let depthRepairAttempts = 0;
                while (!depthGate.passed && depthRepairAttempts < MAX_ANALYSIS_REWRITE_ATTEMPTS) {
                    const snippet = this.formatContext(diagnosticSources || [], 13000).contextText;
                    const rewriteInstruction = this.superBrainBuildAnalyticalRewriteInstruction(
                        query,
                        profileForChecks,
                        depthGate,
                        diagnosticSources
                    );
                    const repaired = await this.verifyAndRepairAnswer(
                        query,
                        `${result.response}\n\n${rewriteInstruction}`,
                        profileForChecks,
                        `## EVIDENCE\n${snippet}`,
                        diagnostics
                    );
                    if (!repaired?.trim()) break;
                    result.response = this.superBrainNormalizeCitationSyntax(repaired.trim());
                    citationCount = this.countCitations(result.response);
                    needsUncertaintySection = !/uncertaint|missing information|evidence gap|cannot fully confirm/i.test(result.response);
                    malformedCitationSignals = this.superBrainHasMalformedCitationPatterns(result.response);
                    diagnostics = this.buildClaimCitationDiagnostics(result.response, diagnosticSources);
                    depthGate = this.superBrainEvaluateCognitiveDepth(
                        query,
                        result.response,
                        profileForChecks,
                        diagnostics,
                        diagnosticSources,
                        localStats.activationReport || {}
                    );
                    depthRepairAttempts += 1;
                }

                const completeness = this.superBrainAssessEvidenceCompleteness(
                    query,
                    diagnosticSources,
                    mentalModel,
                    localStats.activationReport || {},
                    profileForChecks
                );
                const severeGapRisk = Array.isArray(mentalModel?.gaps) && mentalModel.gaps.length >= MODEL_GAP_THRESHOLD;
                const shouldRequestMoreEvidence = completeness.needsMoreEvidence && (
                    diagnosticSources.length === 0 ||
                    completeness.docCount < completeness.requiredDocs ||
                    (severeGapRisk && completeness.docCount < Math.max(2, completeness.requiredDocs))
                );
                if (shouldRequestMoreEvidence) {
                    result.response = this.superBrainBuildMissingEvidenceResponse(
                        query,
                        completeness,
                        diagnosticSources,
                        mentalModel
                    );
                }

                result.meta = {
                    ...(result.meta || {}),
                    superBrain: {
                        patchVersion: PATCH_VERSION,
                        activationReport: localStats.activationReport,
                        mentalModel,
                        contradictionBlockIncluded: !!localStats.superBrainContradictionBlock,
                        fullCorpusSweepDocs: fullCorpusSweep?.totalDocuments || 0,
                        fullCorpusSweepAnchors: fullCorpusSweep?.totalSelectedChunks || 0,
                        refinement: localStats.superBrainRefinement,
                        evidenceCompleteness: completeness,
                        cognitiveDepthGate: depthGate,
                        cognitiveDepthRepairs: depthRepairAttempts,
                        adversarialRetrieval: {
                            passes: localStats.superBrainAdversarialRetrieval?.passes || 0,
                            probes: localStats.superBrainAdversarialRetrieval?.probes || [],
                            chunks: localStats.superBrainAdversarialRetrieval?.chunks?.length || 0
                        },
                        predictiveModel: localStats.superBrainPredictiveModel || null,
                        hierarchyBlockIncluded: !!localStats.superBrainHierarchyBlock,
                        perspectiveMode: !!requestProfile?.perspectiveMode
                    }
                };
                return result;
            });

            if (typeof UIController === 'function') {
                patchMethod(UIController, 'setSynthesisMessage', () => function patchedSetSynthesisMessage() {
                    if (this?.synthesisIndicatorText) {
                        this.synthesisIndicatorText.textContent = 'Running full-corpus document-by-document map-reduce sweep, linking concepts, and building mental model...';
                    }
                });
            }

            try {
                console.log(`[Inline Super-Brain Enhancer] applied (${PATCH_VERSION})`);
            } catch {}
            return true;
        }

        function boot(attempt = 0) {
            const ok = tryInstall();
            if (ok) return;
            if (attempt > 120) {
                try { console.warn('[Inline Super-Brain Enhancer] classes not found; patch not applied.'); } catch {}
                return;
            }
            setTimeout(() => boot(attempt + 1), 50);
        }

        boot();
    })();
    </script>
</body>
</html>
