<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UofT Cognitive Synthesis Engine - Super-Brain Strict RAG</title>
    <style>
        :root {
            --primary: #002A5C;
            --primary-light: #003d82;
            --secondary: #FFE498;
            --accent: #008BB0;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .brain-badge {
            background: var(--secondary);
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            border-radius: 999px;
            padding: 0.25rem 0.7rem;
        }

        .header-btn {
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: white;
            padding: 0.5rem 0.85rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .main-container {
            flex: 1;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            display: flex;
            gap: 1rem;
        }

        .chat-section {
            flex: 1;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            padding: 1rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.16);
        }

        .chat-header h2 {
            font-size: 1rem;
            margin-bottom: 0.2rem;
        }

        .chat-header p {
            font-size: 0.78rem;
            opacity: 0.9;
        }

        .chat-messages {
            flex: 1;
            min-height: 420px;
            max-height: calc(100vh - 320px);
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .message {
            max-width: 88%;
            border-radius: 12px;
            padding: 0.85rem 1rem;
            line-height: 1.55;
            font-size: 0.94rem;
        }

        .message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            align-self: flex-start;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .message.system {
            align-self: center;
            max-width: 100%;
            background: #fff7d6;
            border: 1px solid #f6df9b;
            color: #4d3b00;
            font-size: 0.86rem;
        }

        .message.assistant p { margin-bottom: 0.55rem; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant ul, .message.assistant ol { margin: 0.4rem 0 0.7rem 1.25rem; }
        .message.assistant code {
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            padding: 0.05rem 0.3rem;
            font-size: 0.9em;
        }

        .chat-input-container {
            border-top: 1px solid var(--border);
            background: #f9fbfd;
            padding: 0.9rem 1rem;
        }

        .attachment-preview {
            display: none;
            align-items: center;
            gap: 0.75rem;
            background: #eff9ff;
            border: 1px solid #cbeeff;
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            margin-bottom: 0.75rem;
        }

        .attachment-preview.active { display: flex; }
        .attachment-preview-name { font-size: 0.9rem; font-weight: 600; }
        .attachment-preview-meta { font-size: 0.76rem; color: var(--text-muted); }
        .attachment-preview-remove {
            margin-left: auto;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 0.6rem;
        }

        .attach-btn {
            width: 42px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            color: var(--text-muted);
            cursor: pointer;
        }

        .chat-input {
            flex: 1;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.94rem;
            resize: none;
            font-family: inherit;
            min-height: 48px;
        }

        .send-btn {
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.1rem;
            font-weight: 600;
            color: white;
            background: var(--primary);
            cursor: pointer;
        }

        .send-btn:disabled { opacity: 0.65; cursor: not-allowed; }

        .synthesis-indicator {
            display: none;
            margin: 0.8rem 1rem 0;
            padding: 0.7rem 0.9rem;
            border-radius: 8px;
            background: #eaf7fb;
            color: #0b5d72;
            font-size: 0.85rem;
            align-items: center;
            gap: 0.55rem;
        }
        .synthesis-indicator.active { display: flex; }
        .pulse {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--accent);
            animation: pulse 1.4s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.25); opacity: 0.55; }
        }

        .citation {
            display: inline-flex;
            align-items: center;
            background: var(--accent);
            color: white;
            border-radius: 5px;
            padding: 0.12rem 0.45rem;
            font-size: 0.73rem;
            margin: 0 0.1rem;
            cursor: pointer;
        }

        .attachment-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            opacity: 0.9;
            background: rgba(255,255,255,0.16);
            border-radius: 4px;
            padding: 0.2rem 0.45rem;
            margin-bottom: 0.4rem;
        }

        .corpus-sidebar {
            width: 320px;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .corpus-header {
            border-bottom: 1px solid var(--border);
            padding: 0.9rem 1rem;
            background: #f8fafc;
        }

        .corpus-header h3 {
            font-size: 0.98rem;
            margin-bottom: 0.6rem;
        }

        .corpus-stats {
            display: flex;
            gap: 0.9rem;
            font-size: 0.79rem;
            color: var(--text-muted);
        }

        .corpus-list {
            flex: 1;
            overflow-y: auto;
            max-height: 360px;
            padding: 0.65rem;
        }

        .corpus-item {
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #f8fafc;
            padding: 0.65rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .corpus-item-name {
            font-size: 0.85rem;
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 190px;
        }
        .corpus-item-meta { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.15rem; }
        .corpus-item-delete {
            border: none;
            background: transparent;
            color: #8f9bab;
            cursor: pointer;
            font-size: 1rem;
        }

        .corpus-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
            padding: 1.3rem 0.7rem;
        }

        .admin-panel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1.2rem;
            z-index: 1000;
        }

        .admin-panel.active { display: flex; }
        .admin-content {
            width: 100%;
            max-width: 860px;
            max-height: 92vh;
            background: white;
            border-radius: 14px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .admin-header {
            background: var(--primary);
            color: white;
            padding: 1rem 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .admin-body {
            padding: 1rem 1.2rem;
            overflow-y: auto;
        }

        .api-section {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            background: #f8fafc;
        }

        .api-input-group { display: flex; gap: 0.55rem; }
        .api-input {
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.65rem 0.75rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 0.85rem;
        }

        .api-save-btn {
            border: none;
            border-radius: 6px;
            background: var(--success);
            color: white;
            padding: 0.65rem 0.95rem;
            font-weight: 600;
            cursor: pointer;
        }

        .model-section {
            margin-top: 0.85rem;
            border: 1px solid #cceaf3;
            background: #eff9fc;
            border-radius: 8px;
            padding: 0.85rem;
        }

        .model-select {
            width: 100%;
            margin-top: 0.45rem;
            padding: 0.55rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: white;
        }

        .upload-zone {
            margin-top: 1rem;
            border: 2px dashed var(--border);
            border-radius: 12px;
            background: #f8fafc;
            text-align: center;
            padding: 2rem 1rem;
            cursor: pointer;
        }
        .upload-zone.dragover {
            border-color: var(--accent);
            background: #f0fbff;
        }

        .processing-status {
            margin-top: 0.9rem;
            display: none;
            border: 1px solid #cdebf3;
            background: #edf9fd;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.85rem;
        }
        .processing-status.active { display: block; }
        .processing-bar {
            margin-top: 0.55rem;
            height: 6px;
            background: #dce9ef;
            border-radius: 4px;
            overflow: hidden;
        }
        .processing-bar-fill {
            height: 100%;
            width: 0;
            background: var(--accent);
            transition: width 0.2s;
        }

        .admin-actions {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
        }
        .admin-action-btn {
            border: 1px solid var(--border);
            border-radius: 7px;
            background: white;
            padding: 0.58rem 0.8rem;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .admin-action-btn.danger {
            border-color: #f4a7ad;
            color: #bd2430;
            background: #fff7f8;
        }

        .citation-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.45);
            z-index: 1002;
            padding: 1rem;
        }
        .citation-modal.active { display: flex; }
        .citation-content {
            width: 100%;
            max-width: 620px;
            max-height: 76vh;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .citation-header {
            background: var(--accent);
            color: white;
            padding: 0.9rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .citation-body {
            padding: 1rem;
            overflow-y: auto;
        }
        .citation-source {
            color: var(--text-muted);
            font-size: 0.82rem;
            margin-bottom: 0.8rem;
        }
        .citation-text {
            border-left: 3px solid var(--accent);
            background: #f8fafc;
            border-radius: 6px;
            padding: 0.85rem;
            line-height: 1.62;
        }

        .toast-container {
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            z-index: 1003;
            display: flex;
            flex-direction: column;
            gap: 0.55rem;
        }
        .toast {
            background: white;
            border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.18);
            padding: 0.7rem 0.85rem;
            max-width: 360px;
            font-size: 0.84rem;
            border-left: 4px solid var(--accent);
        }
        .toast.success { border-left-color: var(--success); }
        .toast.warning { border-left-color: var(--warning); }
        .toast.error { border-left-color: var(--error); }

        .keyboard-hint {
            position: fixed;
            left: 1rem;
            bottom: 1rem;
            background: white;
            border-radius: 6px;
            padding: 0.45rem 0.6rem;
            color: var(--text-muted);
            font-size: 0.73rem;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
        }
        .keyboard-hint kbd {
            border: 1px solid var(--border);
            border-radius: 4px;
            background: #f8fafc;
            padding: 0.08rem 0.32rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        @media (max-width: 980px) {
            .main-container { flex-direction: column; }
            .corpus-sidebar { width: 100%; }
            .chat-messages { max-height: 50vh; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>UofT Cognitive Synthesis Engine</h1>
        <div style="display:flex;align-items:center;gap:.75rem;">
            <span class="brain-badge">Brain-Aligned Strict RAG</span>
            <button class="header-btn" id="openAdminBtn" title="Open Admin Panel (Ctrl+Shift+A)">Admin Panel</button>
        </div>
    </header>

    <div class="main-container">
        <section class="chat-section">
            <div class="chat-header">
                <div>
                    <h2>Knowledge Synthesis Interface</h2>
                    <p>Strict source-grounded, full-corpus, concept-linked reasoning</p>
                </div>
                <button class="header-btn" id="clearChatBtn" style="font-size:.8rem;padding:.42rem .7rem;">Clear Chat</button>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    Welcome! This engine performs strict RAG synthesis with:
                    full-corpus activation, concept-bridge retrieval, mental-model planning, and claim-level citations.
                    <br><br>
                    Open <strong>Admin Panel</strong> (Ctrl+Shift+A) to upload documents and set your API key.
                </div>
            </div>

            <div class="synthesis-indicator" id="synthesisIndicator">
                <div class="pulse"></div>
                <span id="synthesisIndicatorText">Activating full corpus and building mental model...</span>
            </div>

            <div class="chat-input-container">
                <div class="attachment-preview" id="attachmentPreview">
                    <div>
                        <div class="attachment-preview-name" id="attachmentName">attachment.pdf</div>
                        <div class="attachment-preview-meta" id="attachmentMeta">Temporary one-turn analysis</div>
                    </div>
                    <button class="attachment-preview-remove" id="attachmentRemove" title="Remove attachment">âœ•</button>
                </div>

                <input type="file" id="chatFileInput" accept=".pdf,.docx,.txt,.csv,.xlsx,.md" style="display:none;">
                <div class="chat-input-wrapper">
                    <button class="attach-btn" id="chatAttachBtn" title="Attach file">ðŸ“Ž</button>
                    <textarea class="chat-input" id="chatInput" placeholder="Ask a question..." rows="2"></textarea>
                    <button class="send-btn" id="sendBtn">Send</button>
                </div>
            </div>
        </section>

        <aside class="corpus-sidebar">
            <div class="corpus-header">
                <h3>Document Corpus</h3>
                <div class="corpus-stats">
                    <span id="docCount">0 documents</span>
                    <span id="chunkCount">0 chunks</span>
                </div>
            </div>
            <div class="corpus-list" id="corpusList">
                <div class="corpus-empty">No documents yet. Open Admin Panel to upload files.</div>
            </div>
        </aside>
    </div>

    <div class="admin-panel" id="adminPanel">
        <div class="admin-content">
            <div class="admin-header">
                <h2 style="font-size:1.08rem;">Admin Panel</h2>
                <button class="header-btn" id="adminClose">Close</button>
            </div>

            <div class="admin-body">
                <div class="api-section">
                    <h4 style="margin-bottom:.6rem;">OpenAI API Key</h4>
                    <div class="api-input-group">
                        <input type="password" class="api-input" id="apiKeyInput" placeholder="sk-...">
                        <button class="api-save-btn" id="saveApiKey">Save Key</button>
                    </div>

                    <div class="model-section">
                        <h4 style="font-size:.9rem;color:#0d667d;">Model Selection</h4>
                        <select class="model-select" id="modelSelect">
                            <option value="gpt-4.1">GPT-4.1 (Best synthesis quality)</option>
                            <option value="gpt-4o">GPT-4o (Balanced)</option>
                            <option value="gpt-4o-mini">GPT-4o mini (Faster)</option>
                        </select>
                        <p style="margin-top:.45rem;color:#516377;font-size:.76rem;">
                            Strict RAG mode enforces source-grounded reasoning, continuity-safe context use, and citations.
                        </p>
                    </div>
                </div>

                <div class="upload-zone" id="uploadZone">
                    <h3 style="font-size:1rem;margin-bottom:.35rem;">Drag & Drop Documents</h3>
                    <p style="color:#627487;font-size:.85rem;">
                        Click to upload permanent corpus files (PDF, DOCX, XLSX, TXT, CSV, MD)
                    </p>
                    <input type="file" id="fileInput" multiple accept=".pdf,.docx,.xlsx,.txt,.csv,.md" style="display:none;">
                </div>

                <div class="processing-status" id="processingStatus">
                    <div id="processingText">Processing...</div>
                    <div class="processing-bar"><div class="processing-bar-fill" id="processingBarFill"></div></div>
                </div>

                <div class="admin-actions">
                    <button class="admin-action-btn" id="rebuildIndex">Rebuild Index</button>
                    <button class="admin-action-btn danger" id="clearCorpus">Clear All Documents</button>
                    <button class="admin-action-btn" id="clearChatAdmin">Clear Chat History</button>
                    <button class="admin-action-btn" id="runEvalHarness">Run Eval Harness</button>
                </div>
            </div>
        </div>
    </div>

    <div class="citation-modal" id="citationModal">
        <div class="citation-content">
            <div class="citation-header">
                <h3 style="font-size:.98rem;">Source Citation</h3>
                <button class="header-btn" id="citationClose">Close</button>
            </div>
            <div class="citation-body">
                <div class="citation-source" id="citationSource"></div>
                <div class="citation-text" id="citationText"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>
    <div class="keyboard-hint"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>A</kbd> Admin Panel</div>

    <script>
    const DB_NAME = 'CognitiveSynthesisDB';
    const DB_VERSION = 2;
    const STORE_NAME = 'documents';

    const LONG_DOC_WORD_THRESHOLD = 12000;
    const MAX_CONTEXT_CHARS = 90000;
    const RETRIEVAL_LOW_SCORE_THRESHOLD = 0.18;
    const MULTIPASS_CHUNK_THRESHOLD = 16;
    const MULTIPASS_CONTEXT_CHAR_THRESHOLD = 70000;
    const MAP_PASS_CONTEXT_BUDGET = 15000;
    const MAX_MAP_PASSES = 7;
    const EMBEDDING_MODEL = 'text-embedding-3-small';
    const EMBEDDING_RERANK_CANDIDATE_LIMIT = 160;
    const EMBEDDING_BATCH_SIZE = 24;
    const CLAIM_CITATION_TARGET = 0.55;
    const CLAIM_SUPPORT_TARGET = 0.45;
    const CITATION_PRECISION_TARGET = 0.5;
    const TPM_CONTEXT_TOKEN_BUDGET = 9500;
    const TPM_RETRY_CONTEXT_TOKEN_BUDGET = 7200;
    const MAP_PHASE_MAX_TOKENS = 420;

    const REFUSAL_PATTERNS = [
        /cannot\s+(?:directly\s+)?access/i,
        /outside of (?:the )?provided excerpts/i,
        /training cut[- ]?off/i,
        /cannot review documents outside/i,
        /i do not have access to your document/i
    ];

    class DocumentDatabase {
        constructor() {
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    this.db = request.result;
                    resolve(this.db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('filename', 'filename', { unique: false });
                        store.createIndex('type', 'type', { unique: false });
                    }
                };
            });
        }

        async addDocument(doc) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.add(doc);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getAllDocuments() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async deleteDocument(id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async clearAll() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }

    class DocumentProcessor {
        constructor() {
            this.stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                'this', 'that', 'these', 'those', 'what', 'which', 'who', 'when',
                'where', 'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more',
                'most', 'other', 'some', 'such', 'than', 'too', 'very', 'just', 'also',
                'into', 'about', 'over', 'under', 'through', 'across'
            ]);

            this.unsupportedLegacyExtensions = new Set(['doc', 'xls']);
            this.supportedExtensions = new Set(['pdf', 'docx', 'xlsx', 'txt', 'csv', 'md']);

            this.mimeProcessors = {
                'application/pdf': this.processPDF.bind(this),
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': this.processDOCX.bind(this),
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': this.processXLSX.bind(this),
                'text/plain': this.processText.bind(this),
                'text/csv': this.processCSV.bind(this),
                'text/markdown': this.processText.bind(this)
            };

            this.extensionProcessors = {
                'pdf': this.processPDF.bind(this),
                'docx': this.processDOCX.bind(this),
                'xlsx': this.processXLSX.bind(this),
                'txt': this.processText.bind(this),
                'csv': this.processCSV.bind(this),
                'md': this.processText.bind(this)
            };
        }

        getExtension(filename = '') {
            const parts = filename.split('.');
            if (parts.length < 2) return '';
            return parts.pop().toLowerCase();
        }

        resolveProcessor(file, extension) {
            return this.extensionProcessors[extension] || this.mimeProcessors[file.type] || this.processText.bind(this);
        }

        normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\u0000/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/[^\S\n]+/g, ' ')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
        }

        splitIntoSentences(text) {
            return text
                .split(/(?<=[.!?])\s+(?=[A-Z0-9"â€œ'`])/)
                .map(s => s.trim())
                .filter(Boolean);
        }

        tokenizeForMemory(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.stopWords.has(token));
        }

        extractHeadings(text) {
            const lines = text.split('\n');
            const headings = [];
            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line || line.length > 120) continue;
                if (/^\[Page\s+\d+\]$/i.test(line)) {
                    headings.push(line);
                    continue;
                }
                const markdownHeading = /^#{1,6}\s+(.+)$/;
                const numberedHeading = /^\d+(\.\d+){0,3}\s+[A-Z]/;
                const titleCaseHeading = /^[A-Z][A-Za-z0-9\s,:;()/-]{4,}$/;
                if (markdownHeading.test(line) || numberedHeading.test(line) || titleCaseHeading.test(line)) {
                    if (!/[.!?]$/.test(line)) {
                        headings.push(line.replace(/^#{1,6}\s*/, ''));
                    }
                }
            }
            return Array.from(new Set(headings)).slice(0, 24);
        }

        isLikelyHeading(line) {
            if (!line) return false;
            if (line.length < 4 || line.length > 120) return false;
            if (/^[\[\](){}]/.test(line)) return false;
            if (/[.!?]$/.test(line)) return false;
            if (/^[-*â€¢]/.test(line)) return false;
            if (/^\d+$/.test(line)) return false;
            return (
                /^#{1,6}\s+/.test(line) ||
                /^\d+(\.\d+){0,3}\s+[A-Z]/.test(line) ||
                /^[A-Z][A-Za-z0-9\s,:;()/-]+$/.test(line)
            );
        }

        splitLargeParagraph(paragraph, maxChars = 1500) {
            const cleaned = paragraph.trim();
            if (!cleaned) return [];
            if (cleaned.length <= maxChars) return [cleaned];
            const sentences = this.splitIntoSentences(cleaned);
            if (sentences.length <= 1) {
                const chunks = [];
                for (let i = 0; i < cleaned.length; i += maxChars) chunks.push(cleaned.slice(i, i + maxChars));
                return chunks;
            }
            const result = [];
            let current = '';
            for (const sentence of sentences) {
                const candidate = current ? `${current} ${sentence}` : sentence;
                if (candidate.length > maxChars && current) {
                    result.push(current.trim());
                    current = sentence;
                } else if (sentence.length > maxChars) {
                    const hardSplit = this.splitLargeParagraph(sentence, maxChars);
                    if (current) { result.push(current.trim()); current = ''; }
                    result.push(...hardSplit);
                } else {
                    current = candidate;
                }
            }
            if (current.trim()) result.push(current.trim());
            return result;
        }

        getOverlapTail(text, overlapChars = 260) {
            if (!text || text.length <= overlapChars) return text;
            const tail = text.slice(-overlapChars);
            const boundary = tail.search(/[.!?]\s+[A-Z]/);
            if (boundary > 0) return tail.slice(boundary + 2).trim();
            return tail.trim();
        }

        splitIntoSections(text) {
            const sections = [];
            const lines = text.split('\n');
            let currentTitle = 'Document';
            let currentPage = null;
            let buffer = [];

            const flush = () => {
                const content = buffer.join('\n').trim();
                if (content) {
                    sections.push({ title: currentTitle, page: currentPage, content });
                }
                buffer = [];
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                const pageMatch = line.match(/^\[Page\s+(\d+)\]$/i);
                if (pageMatch) {
                    flush();
                    currentPage = parseInt(pageMatch[1], 10);
                    currentTitle = `Page ${currentPage}`;
                    continue;
                }
                if (this.isLikelyHeading(line) && buffer.join('\n').length > 700) {
                    flush();
                    currentTitle = line.replace(/^#{1,6}\s*/, '');
                    continue;
                }
                buffer.push(rawLine);
            }

            flush();
            return sections.length ? sections : [{ title: 'Document', page: null, content: text }];
        }

        extractPageFromText(text) {
            const match = text.match(/\[Page\s+(\d+)\]/i);
            return match ? parseInt(match[1], 10) : null;
        }

        scoreSentence(sentence, conceptSet) {
            const words = sentence.toLowerCase().match(/\b[a-z][a-z0-9-]+\b/g) || [];
            let score = 0;
            for (const word of words) if (conceptSet.has(word)) score += 1;
            if (/\d/.test(sentence)) score += 0.7;
            if (/[A-Z][a-z]+ [A-Z][a-z]+/.test(sentence)) score += 0.6;
            if (sentence.length >= 60 && sentence.length <= 260) score += 0.5;
            return score;
        }

        buildDocumentMemory(text, chunks, filename) {
            const words = text.split(/\s+/).filter(Boolean);
            const wordCount = words.length;
            const readingTimeMinutes = Math.max(1, Math.round(wordCount / 220));
            const headings = this.extractHeadings(text);
            const tokens = this.tokenizeForMemory(text);
            const frequencies = new Map();
            for (const token of tokens) frequencies.set(token, (frequencies.get(token) || 0) + 1);
            const keyConcepts = Array.from(frequencies.entries())
                .filter(([, count]) => count > 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 18)
                .map(([token]) => token);
            const conceptSet = new Set(keyConcepts);
            const sentences = this.splitIntoSentences(text).filter(s => s.length >= 35 && s.length <= 320);
            const everyNth = Math.max(1, Math.floor(sentences.length / 14));
            const scored = sentences.map((sentence, idx) => ({
                sentence,
                score: this.scoreSentence(sentence, conceptSet) + ((idx % everyNth === 0) ? 0.3 : 0)
            }));
            const salientSentences = scored
                .sort((a, b) => b.score - a.score)
                .slice(0, 14)
                .map(item => item.sentence.trim());
            const synopsis = salientSentences.slice(0, 6).join(' ').trim();
            return {
                filename,
                wordCount,
                chunkCount: chunks.length,
                readingTimeMinutes,
                outline: headings,
                keyConcepts,
                salientSentences,
                synopsis
            };
        }

        intelligentChunk(text, filename, baseChunkSize = 1800, overlap = 260) {
            const cleaned = this.normalizeText(text);
            if (!cleaned) return [];
            const dynamicChunkSize = cleaned.length > 350000 ? 2400 :
                cleaned.length > 150000 ? 2100 :
                cleaned.length > 50000 ? 1900 : baseChunkSize;
            const sections = this.splitIntoSections(cleaned);
            const chunks = [];
            let chunkIndex = 0;

            for (const section of sections) {
                const paragraphs = section.content
                    .split(/\n{2,}/)
                    .map(p => p.trim())
                    .filter(Boolean);
                let current = section.title ? `${section.title}\n` : '';
                let currentPage = section.page || null;

                const pushChunk = () => {
                    const chunkText = current.trim();
                    if (!chunkText) return;
                    chunks.push({
                        id: `${filename}-chunk-${chunkIndex}`,
                        text: chunkText,
                        filename,
                        section: section.title || 'Document',
                        page: currentPage || this.extractPageFromText(chunkText),
                        index: chunkIndex,
                        preview: chunkText.replace(/\s+/g, ' ').slice(0, 120) + (chunkText.length > 120 ? '...' : '')
                    });
                    chunkIndex++;
                };

                for (const paragraph of paragraphs) {
                    const pageInParagraph = paragraph.match(/\[Page\s+(\d+)\]/i);
                    if (pageInParagraph) currentPage = parseInt(pageInParagraph[1], 10);
                    const units = this.splitLargeParagraph(paragraph, Math.floor(dynamicChunkSize * 0.9));
                    for (const unit of units) {
                        const candidate = current ? `${current}\n\n${unit}` : unit;
                        if (candidate.length > dynamicChunkSize && current.trim()) {
                            pushChunk();
                            const overlapText = this.getOverlapTail(current, overlap);
                            current = overlapText ? `${overlapText}\n\n${unit}` : unit;
                        } else if (candidate.length > dynamicChunkSize && !current.trim()) {
                            const hardUnits = this.splitLargeParagraph(unit, Math.floor(dynamicChunkSize * 0.8));
                            for (const hardUnit of hardUnits) {
                                current = hardUnit;
                                pushChunk();
                                current = '';
                            }
                        } else {
                            current = candidate;
                        }
                    }
                }
                if (current.trim()) pushChunk();
            }
            return chunks;
        }

        async processFile(file) {
            const extension = this.getExtension(file.name);
            if (this.unsupportedLegacyExtensions.has(extension)) {
                throw new Error(`Legacy ${extension.toUpperCase()} is not supported in-browser. Convert to DOCX or XLSX first.`);
            }
            if (!this.supportedExtensions.has(extension)) {
                throw new Error(`Unsupported file type: .${extension || 'unknown'}`);
            }

            const processor = this.resolveProcessor(file, extension);
            const extracted = await processor(file);
            const text = this.normalizeText(extracted);
            if (!text || text.length < 20) throw new Error(`Could not extract readable text from ${file.name}.`);

            const chunks = this.intelligentChunk(text, file.name);
            const memory = this.buildDocumentMemory(text, chunks, file.name);

            return {
                filename: file.name,
                type: file.type || extension,
                extension,
                size: file.size,
                uploadedAt: new Date().toISOString(),
                fullText: text,
                chunks,
                memory
            };
        }

        async processText(file) { return await file.text(); }

        async processCSV(file) {
            const text = await file.text();
            const lines = text.split('\n');
            let formatted = `CSV Data from ${file.name}:\n\n`;
            if (lines.length > 0) {
                const headers = lines[0].split(',').map(h => h.trim());
                formatted += `Columns: ${headers.join(', ')}\n\n`;
                for (let i = 1; i < Math.min(lines.length, 300); i++) {
                    const values = lines[i].split(',');
                    if (!values.some(value => value.trim())) continue;
                    formatted += `Row ${i}: `;
                    headers.forEach((header, idx) => {
                        if (values[idx] && values[idx].trim()) formatted += `${header}: ${values[idx].trim()}; `;
                    });
                    formatted += '\n';
                }
            }
            return formatted;
        }

        async processPDF(file) {
            if (typeof pdfjsLib === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js');
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += `[Page ${i}]\n${pageText}\n\n`;
            }
            return fullText;
        }

        async processDOCX(file) {
            if (typeof mammoth === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js');
            }
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        async processXLSX(file) {
            if (typeof XLSX === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
            }
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            let fullText = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                fullText += `[Sheet: ${sheetName}]\n`;
                jsonData.forEach((row, rowIndex) => {
                    if (row.length > 0) fullText += `Row ${rowIndex + 1}: ${row.join(' | ')}\n`;
                });
                fullText += '\n';
            });
            return fullText;
        }

        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    }

    class CognitiveRetriever {
        constructor() {
            this.documents = [];
            this.allChunks = [];
            this.idf = new Map();
            this.avgChunkLength = 1;
            this.chunkTokenCache = new Map();
            this.chunkLookup = new Map();
            this.conceptIndex = new Map();
            this.documentConceptMap = new Map();
            this.embeddingApiKey = localStorage.getItem('openai_api_key') || '';
            this.embeddingModel = EMBEDDING_MODEL;
            this.chunkEmbeddingCache = new Map();
            this.queryEmbeddingCache = new Map();
            this.chunkEmbeddingTextCache = new Map();
            this.embeddingEnabled = true;
            this.lastEmbeddingError = '';
        }

        setEmbeddingApiKey(apiKey) { this.embeddingApiKey = apiKey || ''; }

        normalizeEmbeddingText(text, maxChars = 2200) {
            return String(text || '').replace(/\s+/g, ' ').trim().slice(0, maxChars);
        }

        prepareChunkEmbeddingText(chunk) {
            const header = `${chunk.filename || 'document'} ${chunk.section || ''} ${chunk.page ? `page ${chunk.page}` : ''}`;
            const body = this.normalizeEmbeddingText(chunk.text || '');
            return `${header}\n${body}`.trim();
        }

        cosineSimilarity(vecA, vecB) {
            if (!Array.isArray(vecA) || !Array.isArray(vecB) || vecA.length !== vecB.length || vecA.length === 0) return 0;
            let dot = 0; let normA = 0; let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                const a = vecA[i]; const b = vecB[i];
                dot += a * b; normA += a * a; normB += b * b;
            }
            if (normA === 0 || normB === 0) return 0;
            return dot / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        async embedTextBatch(texts) {
            if (!this.embeddingApiKey) return null;
            const response = await fetch('https://api.openai.com/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.embeddingApiKey}`
                },
                body: JSON.stringify({ model: this.embeddingModel, input: texts })
            });
            if (!response.ok) {
                let detail = `Embedding API failed (HTTP ${response.status})`;
                try {
                    const error = await response.json();
                    detail = error.error?.message || detail;
                } catch {}
                throw new Error(detail);
            }
            const data = await response.json();
            return data.data.map(item => item.embedding);
        }

        async getQueryEmbedding(query) {
            if (!this.embeddingApiKey || !this.embeddingEnabled) return null;
            const normalizedQuery = this.normalizeEmbeddingText(query, 1000).toLowerCase();
            if (!normalizedQuery) return null;
            if (this.queryEmbeddingCache.has(normalizedQuery)) return this.queryEmbeddingCache.get(normalizedQuery);
            try {
                const vectors = await this.embedTextBatch([normalizedQuery]);
                const vector = vectors?.[0] || null;
                if (vector) this.queryEmbeddingCache.set(normalizedQuery, vector);
                return vector;
            } catch (error) {
                this.lastEmbeddingError = error.message;
                return null;
            }
        }

        async ensureEmbeddingsForChunks(chunks) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !chunks?.length) return;
            const uniqueChunks = [];
            const seen = new Set();
            for (const chunk of chunks) {
                if (!chunk?.id || seen.has(chunk.id)) continue;
                seen.add(chunk.id);
                uniqueChunks.push(chunk);
            }
            const missing = uniqueChunks.filter(chunk => !this.chunkEmbeddingCache.has(chunk.id));
            if (missing.length === 0) return;
            for (let i = 0; i < missing.length; i += EMBEDDING_BATCH_SIZE) {
                const batch = missing.slice(i, i + EMBEDDING_BATCH_SIZE);
                const batchTexts = batch.map(chunk => {
                    const text = this.prepareChunkEmbeddingText(chunk);
                    this.chunkEmbeddingTextCache.set(chunk.id, text);
                    return text;
                });
                try {
                    const vectors = await this.embedTextBatch(batchTexts);
                    vectors.forEach((vector, idx) => {
                        const chunkId = batch[idx].id;
                        if (chunkId && vector) this.chunkEmbeddingCache.set(chunkId, vector);
                    });
                } catch (error) {
                    this.lastEmbeddingError = error.message;
                    return;
                }
            }
        }

        async semanticRerank(query, candidates, topK, intent = {}) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !candidates?.length) return null;
            const limited = candidates.slice(0, EMBEDDING_RERANK_CANDIDATE_LIMIT);
            const queryVector = await this.getQueryEmbedding(query);
            if (!queryVector) return null;
            await this.ensureEmbeddingsForChunks(limited);
            const reranked = limited.map(chunk => {
                const embedding = this.chunkEmbeddingCache.get(chunk.id);
                const semanticScore = embedding ? this.cosineSimilarity(queryVector, embedding) : 0;
                const lexicalScore = chunk.score || 0;
                let hybridScore = (lexicalScore * 0.62) + (semanticScore * 0.38);
                if (intent.broadCoverage) hybridScore += semanticScore * 0.05;
                return { ...chunk, lexicalScore, semanticScore, score: hybridScore };
            }).sort((a, b) => b.score - a.score);
            return this.diversifyResults(reranked, topK);
        }

        shouldUseSemanticRerank(intent = {}, candidates = [], topK = 10) {
            if (!this.embeddingEnabled || !this.embeddingApiKey) return false;
            if (!Array.isArray(candidates) || candidates.length < Math.max(topK * 2, 18)) return false;
            if (intent.broadCoverage || intent.comparative || intent.timeline) return true;
            return this.allChunks.length > 30;
        }

        updateCorpus(documents) {
            this.documents = documents.map(doc => {
                if (doc.memory) return doc;
                return { ...doc, memory: this.deriveMemoryFromChunks(doc) };
            });
            this.allChunks = this.documents.flatMap(doc => doc.chunks || []);
            this.chunkLookup = new Map(this.allChunks.map(chunk => [chunk.id, chunk]));
            this.chunkEmbeddingCache.clear();
            this.chunkEmbeddingTextCache.clear();
            this.buildTokenStats();
            this.buildConceptIndex();
        }

        deriveMemoryFromChunks(doc) {
            const chunks = doc.chunks || [];
            const previews = chunks.slice(0, 8).map(chunk => chunk.preview || chunk.text.slice(0, 120));
            const synopsis = previews.join(' ');
            return {
                filename: doc.filename,
                wordCount: Math.max(0, Math.round((doc.fullText || '').split(/\s+/).filter(Boolean).length)),
                chunkCount: chunks.length,
                readingTimeMinutes: Math.max(1, Math.round(((doc.fullText || '').split(/\s+/).length || 0) / 220)),
                outline: [],
                keyConcepts: this.extractConcepts((doc.fullText || '').slice(0, 4000)).slice(0, 10),
                salientSentences: previews,
                synopsis
            };
        }

        buildTokenStats() {
            this.idf.clear();
            this.chunkTokenCache.clear();
            if (this.allChunks.length === 0) { this.avgChunkLength = 1; return; }

            const df = new Map();
            let totalLength = 0;
            for (const chunk of this.allChunks) {
                const tokens = this.tokenize(chunk.text);
                const tf = new Map();
                for (const token of tokens) tf.set(token, (tf.get(token) || 0) + 1);
                this.chunkTokenCache.set(chunk.id, { tokens, tf, length: tokens.length || 1 });
                totalLength += tokens.length;
                const uniqueTokens = new Set(tokens);
                for (const token of uniqueTokens) df.set(token, (df.get(token) || 0) + 1);
            }
            this.avgChunkLength = totalLength / Math.max(1, this.allChunks.length);
            const N = this.allChunks.length;
            for (const [token, count] of df.entries()) {
                const idf = Math.log(((N - count + 0.5) / (count + 0.5)) + 1);
                this.idf.set(token, idf);
            }
        }

        buildConceptIndex() {
            this.conceptIndex.clear();
            this.documentConceptMap.clear();
            for (const doc of this.documents) {
                const docConcepts = new Set();
                for (const chunk of (doc.chunks || [])) {
                    const concepts = this.extractKeyConceptsFromChunk(chunk.text);
                    for (const concept of concepts) {
                        docConcepts.add(concept);
                        if (!this.conceptIndex.has(concept)) this.conceptIndex.set(concept, []);
                        this.conceptIndex.get(concept).push({ docId: doc.id, filename: doc.filename, chunkId: chunk.id });
                    }
                }
                this.documentConceptMap.set(doc.filename, docConcepts);
            }
        }

        detectQueryIntent(query) {
            const q = query.toLowerCase();
            return {
                broadCoverage: /\b(whole|entire|full|overall|comprehensive|big picture|summari[sz]e|main themes|analyze.*document|review.*document)\b/.test(q),
                comparative: /\b(compare|contrast|versus|vs\.?)\b/.test(q),
                extraction: /\b(list|extract|enumerate|all instances|find all)\b/.test(q),
                timeline: /\b(timeline|chronological|over time|sequence)\b/.test(q)
            };
        }

        splitIntoSubQueries(query) {
            const compact = query.replace(/\s+/g, ' ').trim();
            const pieces = compact.split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|along with)\b\s+)/i)
                .map(piece => piece.trim())
                .filter(piece => piece.length >= 12);
            return Array.from(new Set(pieces)).slice(0, 6);
        }

        extractQueryPhrases(query) {
            const phrases = query.toLowerCase().match(/\b[a-z0-9][a-z0-9-]{2,}(?:\s+[a-z0-9][a-z0-9-]{2,}){1,2}\b/g) || [];
            return Array.from(new Set(phrases))
                .filter(phrase => phrase.split(/\s+/).some(word => !this.isStopWord(word)))
                .slice(0, 10);
        }

        generateQueryVariants(query, intent = {}) {
            const variants = [query.trim()];
            variants.push(...this.splitIntoSubQueries(query).slice(0, 3));
            variants.push(...this.extractQueryPhrases(query).slice(0, 3));
            if (intent.broadCoverage) variants.push(`${query} key themes and overall synthesis`);
            if (intent.timeline) variants.push(`${query} timeline chronology milestones`);
            if (intent.comparative) variants.push(`${query} differences similarities trade-offs`);
            return Array.from(new Set(variants.map(v => v.trim()).filter(Boolean))).slice(0, 7);
        }

        calculateQueryVariantScore(chunk, query, queryTokens, queryEntities, queryConcepts, weight = 1) {
            const score = this.calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts);
            return score * weight;
        }

        tokenize(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.isStopWord(token));
        }

        isStopWord(word) {
            const stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'this', 'that',
                'these', 'those', 'what', 'which', 'who', 'whom', 'whose', 'when', 'where',
                'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more', 'most', 'other',
                'some', 'such', 'than', 'too', 'very', 'just', 'also', 'into', 'about'
            ]);
            return stopWords.has(word);
        }

        extractEntities(text) {
            const entities = [];
            const capitalizedWords = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
            entities.push(...capitalizedWords.map(e => e.toLowerCase()));
            const numbers = text.match(/\d+(?:\.\d+)?%?/g) || [];
            entities.push(...numbers);
            const dates = text.match(/\d{4}|\d{1,2}\/\d{1,2}\/\d{2,4}/g) || [];
            entities.push(...dates);
            return entities;
        }

        extractConcepts(text) {
            const concepts = [];
            const phrases = text.match(/\b\w+\s+\w+(?:\s+\w+)?\b/g) || [];
            concepts.push(...phrases.map(p => p.toLowerCase()));
            return concepts;
        }

        extractKeyConceptsFromChunk(text) {
            const concepts = new Set();
            const properNouns = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
            properNouns.forEach(p => concepts.add(p.toLowerCase()));
            const technical = text.match(/\b[a-z]+[-_]?[a-z]*\d+[a-z]*\b/gi) || [];
            technical.forEach(t => concepts.add(t.toLowerCase()));
            const quoted = text.match(/"([^"]+)"/g) || [];
            quoted.forEach(q => concepts.add(q.replace(/"/g, '').toLowerCase()));
            return concepts;
        }

        calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts) {
            const cache = this.chunkTokenCache.get(chunk.id) || { tokens: this.tokenize(chunk.text), tf: new Map(), length: 1 };
            if (cache.tf.size === 0) {
                for (const token of cache.tokens) cache.tf.set(token, (cache.tf.get(token) || 0) + 1);
            }

            const uniqueQueryTokens = Array.from(new Set(queryTokens));
            const chunkTextLower = chunk.text.toLowerCase();
            const queryTextLower = query.toLowerCase().trim();
            let score = 0;

            if (uniqueQueryTokens.length > 0) {
                const k1 = 1.2; const b = 0.75;
                let bm25 = 0; let maxIdf = 0;
                for (const token of uniqueQueryTokens) {
                    const tf = cache.tf.get(token) || 0;
                    const idf = this.idf.get(token) || 0.4;
                    maxIdf += idf;
                    if (tf === 0) continue;
                    const numerator = tf * (k1 + 1);
                    const denominator = tf + k1 * (1 - b + b * (cache.length / this.avgChunkLength));
                    bm25 += idf * (numerator / denominator);
                }
                if (maxIdf > 0) score += (bm25 / maxIdf) * 0.55;
            }

            if (queryTextLower.length > 12 && chunkTextLower.includes(queryTextLower)) score += 0.2;
            if (queryEntities.length > 0) {
                const entityMatches = queryEntities.filter(entity => chunkTextLower.includes(entity.toLowerCase())).length;
                score += (entityMatches / queryEntities.length) * 0.15;
            }
            if (queryConcepts.length > 0) {
                const conceptMatches = queryConcepts.filter(concept => chunkTextLower.includes(concept)).length;
                score += (conceptMatches / queryConcepts.length) * 0.08;
            }
            const tokenMatches = uniqueQueryTokens.filter(token => cache.tf.has(token)).length;
            const density = tokenMatches / Math.max(1, cache.length / 100);
            score += Math.min(density * 0.04, 0.06);
            return score;
        }

        pickEvenlyDistributed(chunks, count) {
            if (!chunks || chunks.length === 0 || count <= 0) return [];
            if (chunks.length <= count) return chunks.slice();
            const selected = [];
            for (let i = 0; i < count; i++) {
                const index = Math.floor((i * (chunks.length - 1)) / Math.max(1, count - 1));
                selected.push(chunks[index]);
            }
            return selected;
        }

        mergeUniqueChunks(primary, additions, limit) {
            const result = [];
            const seen = new Set();
            for (const chunk of [...primary, ...additions]) {
                if (!chunk || seen.has(chunk.id)) continue;
                result.push(chunk);
                seen.add(chunk.id);
                if (result.length >= limit) break;
            }
            return result;
        }

        diversifyResults(scoredChunks, topK) {
            const results = [];
            const seenDocuments = new Map();
            const maxPerDocument = Math.max(2, Math.ceil(topK / 2));
            for (const chunk of scoredChunks) {
                if (results.length >= topK) break;
                const docCount = seenDocuments.get(chunk.filename) || 0;
                if (docCount < maxPerDocument) {
                    results.push(chunk);
                    seenDocuments.set(chunk.filename, docCount + 1);
                }
            }
            if (results.length < topK) {
                for (const chunk of scoredChunks) {
                    if (results.length >= topK) break;
                    if (!results.some(existing => existing.id === chunk.id)) results.push(chunk);
                }
            }
            return results;
        }

        buildCoverageCandidates(primaryResults, scoredChunks, count) {
            if (count <= 0) return [];
            const topDocs = Array.from(new Set(primaryResults.map(chunk => chunk.filename)));
            if (topDocs.length === 0) {
                for (const chunk of scoredChunks.slice(0, 3)) topDocs.push(chunk.filename);
            }
            const coverage = [];
            const perDoc = Math.max(1, Math.ceil(count / Math.max(1, topDocs.length)));
            for (const filename of topDocs) {
                const docChunks = this.allChunks
                    .filter(chunk => chunk.filename === filename)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));
                coverage.push(...this.pickEvenlyDistributed(docChunks, perDoc));
            }
            return coverage.slice(0, count);
        }

        findConceptLinkedChunks(primaryChunks, query, queryTokens, queryConcepts) {
            const linkedChunkIds = new Set();
            const linkedChunks = [];
            for (const chunk of primaryChunks) {
                const chunkConcepts = this.extractKeyConceptsFromChunk(chunk.text);
                for (const concept of chunkConcepts) {
                    const links = this.conceptIndex.get(concept) || [];
                    for (const link of links) {
                        if (linkedChunkIds.has(link.chunkId)) continue;
                        linkedChunkIds.add(link.chunkId);
                        const linkedChunk = this.chunkLookup.get(link.chunkId);
                        if (linkedChunk) {
                            const score = this.calculateRelevanceScore(linkedChunk, query, queryTokens, [], queryConcepts);
                            linkedChunks.push({ ...linkedChunk, score, isLinked: true });
                        }
                    }
                }
            }
            linkedChunks.sort((a, b) => b.score - a.score);
            return linkedChunks;
        }

        async retrieve(query, topK = null, options = {}) {
            if (this.allChunks.length === 0) return [];
            const intent = options.intent || this.detectQueryIntent(query);
            const corpusSize = this.allChunks.length;
            if (topK === null) {
                if (intent.broadCoverage) topK = corpusSize <= 60 ? 18 : corpusSize <= 200 ? 24 : Math.min(32, Math.ceil(corpusSize * 0.08));
                else if (corpusSize <= 50) topK = 10;
                else if (corpusSize <= 200) topK = 15;
                else if (corpusSize <= 500) topK = 20;
                else topK = Math.min(25, Math.ceil(corpusSize * 0.05));
            }

            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                return {
                    variant,
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.58 : (0.42 / Math.max(1, queryVariants.length - 1))
                };
            });

            const scoredChunks = this.allChunks.map(chunk => {
                let score = 0; let maxVariantScore = 0;
                for (const features of variantFeatures) {
                    const variantScore = this.calculateQueryVariantScore(
                        chunk, features.variant, features.queryTokens, features.queryEntities, features.queryConcepts, features.weight
                    );
                    score += variantScore;
                    maxVariantScore = Math.max(maxVariantScore, variantScore);
                }
                score += maxVariantScore * 0.18;
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let primaryResults = this.diversifyResults(scoredChunks, Math.ceil(topK * 0.7));
            const bestScore = primaryResults[0]?.score || 0;
            if (intent.broadCoverage || bestScore < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const coverage = this.buildCoverageCandidates(primaryResults, scoredChunks, Math.ceil(topK * 0.5));
                primaryResults = this.mergeUniqueChunks(primaryResults, coverage, topK);
            }
            const baseFeatures = variantFeatures[0];
            const linkedChunks = this.findConceptLinkedChunks(primaryResults, query, baseFeatures.queryTokens, baseFeatures.queryConcepts)
                .slice(0, Math.max(2, Math.floor(topK * 0.25)));
            const merged = this.mergeUniqueChunks(primaryResults, linkedChunks, topK);
            if (merged.length === 0) return this.allChunks.slice(0, topK);

            const rerankCandidates = this.mergeUniqueChunks(
                scoredChunks.slice(0, Math.max(topK * 8, 80)),
                merged,
                EMBEDDING_RERANK_CANDIDATE_LIMIT
            );

            if (this.shouldUseSemanticRerank(intent, rerankCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, rerankCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = merged.slice(0, Math.ceil(topK * 0.5));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.7));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }
            return merged;
        }

        calculateLocalRelevanceScore(chunk, queryTokens, queryEntities, queryConcepts) {
            const chunkTokens = this.tokenize(chunk.text);
            const chunkTokenSet = new Set(chunkTokens);
            const chunkText = chunk.text.toLowerCase();
            let score = 0;
            if (queryTokens.length > 0) {
                const matches = queryTokens.filter(token => chunkTokenSet.has(token)).length;
                score += (matches / queryTokens.length) * 0.55;
            }
            if (queryEntities.length > 0) {
                const matches = queryEntities.filter(entity => chunkText.includes(entity.toLowerCase())).length;
                score += (matches / queryEntities.length) * 0.2;
            }
            if (queryConcepts.length > 0) {
                const matches = queryConcepts.filter(concept => chunkText.includes(concept)).length;
                score += (matches / queryConcepts.length) * 0.1;
            }
            if (queryTokens.length > 0) {
                const density = queryTokens.filter(token => chunkTokenSet.has(token)).length / Math.max(1, chunk.text.length / 120);
                score += Math.min(density * 0.06, 0.08);
            }
            return score;
        }

        async retrieveFromChunks(query, chunks, topK = 10, options = {}) {
            if (!chunks || chunks.length === 0) return [];
            const intent = options.intent || this.detectQueryIntent(query);
            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                return {
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.6 : (0.4 / Math.max(1, queryVariants.length - 1))
                };
            });
            const scored = chunks.map(chunk => {
                let score = 0;
                for (const features of variantFeatures) {
                    const localScore = this.calculateLocalRelevanceScore(chunk, features.queryTokens, features.queryEntities, features.queryConcepts);
                    score += localScore * features.weight;
                }
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let selected = scored.slice(0, Math.ceil(topK * 0.65));
            if (intent.broadCoverage || selected[0]?.score < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const orderedByIndex = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                const coverage = this.pickEvenlyDistributed(orderedByIndex, Math.ceil(topK * 0.5));
                selected = this.mergeUniqueChunks(selected, coverage, topK);
            }
            const semanticCandidates = this.mergeUniqueChunks(scored.slice(0, Math.max(topK * 6, 48)), selected, Math.min(EMBEDDING_RERANK_CANDIDATE_LIMIT, 96));
            if (this.shouldUseSemanticRerank(intent, semanticCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, semanticCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = selected.slice(0, Math.ceil(topK * 0.55));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.65));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }
            return selected.slice(0, topK);
        }

        extractBestSentence(text, queryTokens) {
            const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
            if (sentences.length === 0) return text.slice(0, 180);
            if (queryTokens.length === 0) return sentences[0].slice(0, 220);
            let bestSentence = sentences[0]; let bestScore = -1;
            for (const sentence of sentences) {
                const lower = sentence.toLowerCase();
                const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                if (score > bestScore) { bestScore = score; bestSentence = sentence; }
            }
            return bestSentence.slice(0, 260);
        }

        buildAttachmentDigest(query, chunks, maxEntries = 14) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            const ranked = chunks.map(chunk => ({ ...chunk, score: this.calculateLocalRelevanceScore(chunk, queryTokens, [], []) }))
                .sort((a, b) => b.score - a.score);
            const top = ranked.slice(0, Math.ceil(maxEntries * 0.65));
            const ordered = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
            const coverage = this.pickEvenlyDistributed(ordered, Math.ceil(maxEntries * 0.4));
            const merged = this.mergeUniqueChunks(top, coverage, maxEntries);
            return merged.map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        buildCorpusDigest(query, chunks, maxEntries = 16) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            return chunks.slice(0, maxEntries).map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        getTopConnectedConcepts(limit = 10) {
            const conceptDocCounts = new Map();
            for (const [concept, links] of this.conceptIndex) {
                const uniqueDocs = new Set(links.map(link => link.filename));
                if (uniqueDocs.size > 1) conceptDocCounts.set(concept, uniqueDocs.size);
            }
            return Array.from(conceptDocCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([concept, docCount]) => ({ concept, docCount }));
        }
    }

    class CognitiveSynthesizer {
        constructor() {
            this.apiKey = localStorage.getItem('openai_api_key') || '';
            this.model = localStorage.getItem('openai_model') || 'gpt-4.1';
            this.conversationHistory = this.loadChatHistory();
            this.workingMemory = this.loadWorkingMemory();
        }

        loadChatHistory() {
            const saved = localStorage.getItem('chat_history');
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }

        loadWorkingMemory() {
            const saved = localStorage.getItem('working_memory');
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }

        saveChatHistory() {
            const trimmed = this.conversationHistory.slice(-40);
            localStorage.setItem('chat_history', JSON.stringify(trimmed));
        }

        saveWorkingMemory() {
            const trimmed = this.workingMemory.slice(-18);
            localStorage.setItem('working_memory', JSON.stringify(trimmed));
        }

        clearHistory() {
            this.conversationHistory = [];
            this.workingMemory = [];
            localStorage.removeItem('chat_history');
            localStorage.removeItem('working_memory');
        }

        setApiKey(key) {
            this.apiKey = key;
            localStorage.setItem('openai_api_key', key);
        }

        setModel(model) {
            this.model = model;
            localStorage.setItem('openai_model', model);
        }

        buildInstructionProfile(query) {
            const lower = query.toLowerCase();
            const wordLimitMatch = query.match(/(\d{2,4})\s*words?/i);
            return {
                requestedFormat: /\btable\b/.test(lower) ? 'table' :
                    /\b(json)\b/.test(lower) ? 'json' :
                    /\b(bullet|bulleted|list|points)\b/.test(lower) ? 'bullet list' :
                    'structured prose',
                wantsSteps: /\b(step[- ]by[- ]step|steps)\b/.test(lower),
                wordLimit: wordLimitMatch ? parseInt(wordLimitMatch[1], 10) : null,
                strictSourceOnly: /\b(only use|based only|strictly from|from provided|from uploaded)\b/.test(lower),
                userIntent: lower
            };
        }

        getWorkingMemorySummary() {
            if (!this.workingMemory.length) return 'No prior working memory yet.';
            return this.workingMemory
                .slice(-6)
                .map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`)
                .join('\n');
        }

        rememberTurn(query, response) {
            const cleaned = response.replace(/\[Source:[^\]]+\]/g, '').replace(/\s+/g, ' ').trim();
            const gist = cleaned.slice(0, 380);
            this.workingMemory.push({
                timestamp: new Date().toISOString(),
                query: query.slice(0, 160),
                gist
            });
            this.saveWorkingMemory();
        }

        safeJsonParse(rawText) {
            if (!rawText) return null;
            const trimmed = rawText.trim();
            try { return JSON.parse(trimmed); } catch {}
            const fenced = trimmed.match(/```json\s*([\s\S]*?)\s*```/i) || trimmed.match(/```([\s\S]*?)```/);
            if (fenced?.[1]) {
                try { return JSON.parse(fenced[1]); } catch {}
            }
            const start = trimmed.indexOf('{');
            const end = trimmed.lastIndexOf('}');
            if (start >= 0 && end > start) {
                const candidate = trimmed.slice(start, end + 1);
                try { return JSON.parse(candidate); } catch { return null; }
            }
            return null;
        }

        heuristicPlan(query, instructionProfile = {}) {
            const normalized = query.replace(/\s+/g, ' ').trim();
            const clauses = normalized
                .split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|then)\b\s+)/i)
                .map(c => c.trim())
                .filter(c => c.length > 10);
            const subQuestions = clauses.length > 0 ? clauses.slice(0, 5) : [
                `What is the core answer to: ${normalized}?`,
                'What evidence supports the answer?',
                'What cross-document links strengthen confidence?'
            ];
            return {
                analysis_mode: 'hierarchical-rag',
                sub_questions: subQuestions,
                evidence_strategy: 'Retrieve broad evidence, then verify every claim with citations.',
                output_spec: {
                    format: instructionProfile.requestedFormat || 'structured prose',
                    step_by_step: !!instructionProfile.wantsSteps,
                    max_words: instructionProfile.wordLimit || null,
                    strict_source_only: !!instructionProfile.strictSourceOnly
                }
            };
        }

        normalizePlan(plan, fallback) {
            if (!plan || typeof plan !== 'object') return fallback;
            const subQuestions = Array.isArray(plan.sub_questions)
                ? plan.sub_questions.filter(q => typeof q === 'string' && q.trim().length > 0).slice(0, 6)
                : [];
            return {
                analysis_mode: typeof plan.analysis_mode === 'string' ? plan.analysis_mode : fallback.analysis_mode,
                sub_questions: subQuestions.length ? subQuestions : fallback.sub_questions,
                evidence_strategy: typeof plan.evidence_strategy === 'string' ? plan.evidence_strategy : fallback.evidence_strategy,
                output_spec: {
                    format: plan.output_spec?.format || fallback.output_spec.format,
                    step_by_step: typeof plan.output_spec?.step_by_step === 'boolean' ? plan.output_spec.step_by_step : fallback.output_spec.step_by_step,
                    max_words: Number.isFinite(plan.output_spec?.max_words) ? plan.output_spec.max_words : fallback.output_spec.max_words,
                    strict_source_only: typeof plan.output_spec?.strict_source_only === 'boolean'
                        ? plan.output_spec.strict_source_only
                        : fallback.output_spec.strict_source_only
                }
            };
        }

        shouldUseModelPlanner(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const wordCount = String(query || '').split(/\s+/).filter(Boolean).length;
            const complexSeparators = /[;:?]/.test(query) || /\b(and|also|plus|compare|contrast|timeline)\b/i.test(query);
            const largeCorpus = (corpusStats.numChunks || 0) > 120 || (corpusStats.numDocs || 0) > 10;
            const largeAttachment = (attachmentContext?.chunks?.length || 0) > 12;
            const constrainedFormat = instructionProfile.wantsSteps || instructionProfile.requestedFormat !== 'structured prose';
            return wordCount > 24 || complexSeparators || largeCorpus || largeAttachment || constrainedFormat;
        }

        async buildCognitivePlan(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const fallback = this.heuristicPlan(query, instructionProfile);
            if (!this.shouldUseModelPlanner(query, instructionProfile, corpusStats, attachmentContext)) return fallback;
            const plannerSystem = `You are a planning module for a strict citation-grounded RAG system.
Return ONLY valid JSON object with keys:
- analysis_mode (string)
- sub_questions (array of 2-6 strings)
- evidence_strategy (string)
- output_spec (object: format, step_by_step, max_words, strict_source_only)
No prose outside JSON.`;
            const plannerUser = `Question: ${query}
Corpus docs: ${corpusStats.numDocs || 0}
Corpus chunks: ${corpusStats.numChunks || 0}
Attachment present: ${attachmentContext ? 'yes' : 'no'}
Requested format: ${instructionProfile.requestedFormat || 'structured prose'}
Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
Word limit: ${instructionProfile.wordLimit || 'none'}
Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}`;
            try {
                const raw = await this.callCompletion([
                    { role: 'system', content: plannerSystem },
                    { role: 'user', content: plannerUser }
                ], { temperature: 0.1, max_tokens: 420, top_p: 0.9 });
                const parsed = this.safeJsonParse(raw);
                return this.normalizePlan(parsed, fallback);
            } catch {
                return fallback;
            }
        }

        estimateChunkChars(chunks = []) {
            return chunks.reduce((sum, chunk) => sum + (chunk.text?.length || 0), 0);
        }

        shouldUseMultiPass(relevantChunks, attachmentContext = null, corpusStats = {}, plan = null) {
            const corpusChars = this.estimateChunkChars(relevantChunks);
            const attachmentChars = this.estimateChunkChars(attachmentContext?.chunks || []);
            const totalChunks = (relevantChunks?.length || 0) + (attachmentContext?.chunks?.length || 0);
            const planBreadth = plan?.sub_questions?.length || 0;
            return (
                totalChunks >= MULTIPASS_CHUNK_THRESHOLD ||
                (corpusChars + attachmentChars) >= MULTIPASS_CONTEXT_CHAR_THRESHOLD ||
                (corpusStats.numChunks || 0) > 260 ||
                (planBreadth >= 5 && totalChunks >= 10)
            );
        }

        dedupeChunks(chunks = []) {
            const seen = new Set();
            const deduped = [];
            for (const chunk of chunks) {
                const key = chunk.id || `${chunk.filename}:${chunk.index}`;
                if (!key || seen.has(key)) continue;
                seen.add(key);
                deduped.push(chunk);
            }
            return deduped;
        }

        buildEvidenceBatches(relevantChunks, attachmentContext = null, maxChars = MAP_PASS_CONTEXT_BUDGET, maxBatches = MAX_MAP_PASSES) {
            const corpusTagged = (relevantChunks || []).map(chunk => ({ ...chunk, _scope: 'corpus' }));
            const attachmentTagged = (attachmentContext?.chunks || []).map(chunk => ({ ...chunk, _scope: 'attachment' }));
            const allChunks = this.dedupeChunks([...attachmentTagged, ...corpusTagged]);
            const batches = [];
            let currentBatch = [];
            let currentChars = 0;
            for (const chunk of allChunks) {
                const text = chunk.text || '';
                const blockSize = text.length + 220;
                if (currentBatch.length > 0 && currentChars + blockSize > maxChars) {
                    batches.push(currentBatch);
                    currentBatch = [];
                    currentChars = 0;
                }
                currentBatch.push(chunk);
                currentChars += blockSize;
                if (batches.length >= maxBatches) break;
            }
            if (currentBatch.length > 0 && batches.length < maxBatches) batches.push(currentBatch);
            return batches.slice(0, maxBatches);
        }

        formatEvidenceBatch(batch = [], label = '') {
            const lines = [`## ${label}`];
            for (const chunk of batch) {
                const page = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const scopeLabel = chunk._scope === 'attachment' ? 'ATTACHMENT' : 'CORPUS';
                lines.push(`### [${scopeLabel}] ${chunk.filename} (${page})`);
                lines.push((chunk.text || '').slice(0, 3000));
            }
            return lines.join('\n\n');
        }

        formatPlanForContext(plan) {
            if (!plan) return '';
            const subQuestions = (plan.sub_questions || []).map((q, i) => `${i + 1}. ${q}`).join('\n');
            return `## COGNITIVE PLAN
Analysis mode: ${plan.analysis_mode || 'hierarchical-rag'}
Evidence strategy: ${plan.evidence_strategy || 'N/A'}
Sub-questions:
${subQuestions || '1. Answer the user query directly.'}

Output spec:
- Format: ${plan.output_spec?.format || 'structured prose'}
- Step-by-step: ${plan.output_spec?.step_by_step ? 'yes' : 'no'}
- Max words: ${plan.output_spec?.max_words || 'none'}
- Strict source only: ${plan.output_spec?.strict_source_only ? 'yes' : 'no'}`;
        }

        async runMapPhase(query, plan, evidenceBatches) {
            const mapNotes = [];
            for (let i = 0; i < evidenceBatches.length; i++) {
                const batch = evidenceBatches[i];
                const batchContext = this.formatEvidenceBatch(batch, `EVIDENCE BATCH ${i + 1}/${evidenceBatches.length}`);
                const mapPrompt = `Question: ${query}

Plan sub-questions:
${(plan.sub_questions || []).map((q, idx) => `${idx + 1}. ${q}`).join('\n')}

Extract the highest-value findings from this batch only.
Rules:
- Use concise bullet points.
- Include only findings supported by this batch.
- Every bullet must include citation in exact format:
  [Source: filename, page X, "brief relevant quote"]
- End with one line: "Batch confidence: High/Medium/Low"`;
                const mapMessages = [
                    { role: 'system', content: 'You are an evidence extractor for long-context RAG map-reduce. Only use the provided batch. Do not generalize beyond it.' },
                    { role: 'user', content: `${batchContext}\n\n${mapPrompt}` }
                ];
                let note = '';
                try {
                    note = await this.callCompletion(mapMessages, { temperature: 0.1, max_tokens: MAP_PHASE_MAX_TOKENS, top_p: 0.85 });
                } catch {
                    note = `- Map pass ${i + 1} unavailable due to transient model error.`;
                }
                mapNotes.push({ batchIndex: i + 1, note });
            }
            return mapNotes;
        }

        formatMapNotes(mapNotes = []) {
            if (!mapNotes.length) return '';
            const blocks = mapNotes.map(item => `### MAP NOTE ${item.batchIndex}\n${item.note}`);
            return `## MAP-REDUCE EVIDENCE NOTES\n${blocks.join('\n\n')}`;
        }

        estimateTokens(text = '') {
            return Math.ceil(String(text || '').length / 4);
        }

        estimateMessagesTokens(messages = []) {
            return (messages || []).reduce((sum, msg) => {
                return sum + this.estimateTokens(msg?.content || '') + 10;
            }, 0);
        }

        isTpmLimitError(error) {
            const msg = String(error?.message || error || '');
            return /tokens per min|TPM|Request too large/i.test(msg);
        }

        truncateSection(section, maxChars) {
            const text = String(section || '');
            if (!text || text.length <= maxChars) return text;
            const clipped = text.slice(0, Math.max(800, maxChars - 220));
            return `${clipped}\n\n[Section truncated for token budget safety.]`;
        }

        getSectionCharCap(section) {
            if (!section) return 6000;
            if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) return 24000;
            if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) return 11000;
            if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) return 12000;
            if (section.startsWith('## FULL-CORPUS REDUCE SYNTHESIS')) return 5000;
            if (section.startsWith('## CONTRADICTION CHECK')) return 4200;
            if (section.startsWith('## MAP-REDUCE EVIDENCE NOTES')) return 8000;
            if (section.startsWith('## DOCUMENT MEMORY BLOCKS')) return 7000;
            if (section.startsWith('## ATTACHMENT MEMORY (FULL FILE)')) return 4500;
            if (section.startsWith('## CORPUS DIGEST')) return 4000;
            if (section.startsWith('## CROSS-DOCUMENT CONCEPT BRIDGES')) return 3000;
            if (section.startsWith('## COGNITIVE PLAN')) return 2600;
            return 5000;
        }

        sectionPriority(section) {
            if (!section) return 9;
            if (section.startsWith('## COGNITIVE PLAN')) return 1;
            if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) return 1;
            if (section.startsWith('## FULL-CORPUS REDUCE SYNTHESIS')) return 2;
            if (section.startsWith('## CONTRADICTION CHECK')) return 2;
            if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) return 3;
            if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) return 3;
            if (section.startsWith('## MAP-REDUCE EVIDENCE NOTES')) return 4;
            if (section.startsWith('## CROSS-DOCUMENT CONCEPT BRIDGES')) return 5;
            if (section.startsWith('## DOCUMENT MEMORY BLOCKS')) return 6;
            if (section.startsWith('## ATTACHMENT MEMORY (FULL FILE)')) return 7;
            if (section.startsWith('## CORPUS DIGEST')) return 8;
            return 9;
        }

        applyContextBudget(contextSections = [], tokenBudget = TPM_CONTEXT_TOKEN_BUDGET) {
            let sections = (contextSections || [])
                .map(section => this.truncateSection(section, this.getSectionCharCap(section)))
                .filter(Boolean);

            const calcTokens = () => this.estimateTokens(sections.join('\n\n'));
            let totalTokens = calcTokens();

            // Drop lower-priority sections until within budget.
            while (sections.length > 2 && totalTokens > tokenBudget) {
                let dropIdx = -1;
                let worstPriority = -1;
                for (let i = 0; i < sections.length; i++) {
                    const p = this.sectionPriority(sections[i]);
                    if (p > worstPriority) {
                        worstPriority = p;
                        dropIdx = i;
                    }
                }
                if (dropIdx < 0 || worstPriority <= 3) break;
                sections.splice(dropIdx, 1);
                totalTokens = calcTokens();
            }

            // If still too large, compress key long sections.
            if (totalTokens > tokenBudget) {
                sections = sections.map(section => {
                    if (section.startsWith('## RETRIEVED EVIDENCE CHUNKS')) {
                        return this.truncateSection(section, 15000);
                    }
                    if (section.startsWith('## FULL-CORPUS DOCUMENT MAP SWEEP')) {
                        return this.truncateSection(section, 8500);
                    }
                    if (section.startsWith('## ATTACHMENT QUERY-SPECIFIC EVIDENCE')) {
                        return this.truncateSection(section, 7000);
                    }
                    return section;
                });
                totalTokens = calcTokens();
            }

            return {
                sections,
                context: sections.join('\n\n'),
                tokenBudget,
                estimatedTokens: totalTokens
            };
        }

        countCitations(text) {
            return (text.match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }

        tokenizeForDiagnostics(text) {
            const stop = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'if', 'then', 'in', 'on', 'at', 'to', 'for', 'of',
                'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'it', 'its', 'that',
                'this', 'these', 'those', 'we', 'they', 'their', 'there', 'here', 'which', 'what', 'when',
                'where', 'why', 'how', 'can', 'could', 'should', 'would', 'may', 'might', 'will', 'also'
            ]);
            return String(text || '').toLowerCase().replace(/[^\w\s-]/g, ' ')
                .split(/\s+/).filter(token => token.length > 2 && !stop.has(token));
        }

        normalizeFilename(name) {
            return String(name || '').trim().toLowerCase();
        }

        extractCitations(text) {
            const regex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citations = [];
            let match;
            while ((match = regex.exec(text)) !== null) {
                citations.push({
                    filename: String(match[1] || '').trim(),
                    page: String(match[2] || '').trim(),
                    quote: String(match[3] || '').trim()
                });
            }
            return citations;
        }

        buildSourceCaches(sources = []) {
            return (sources || []).map(source => {
                const textLower = String(source.text || '').toLowerCase();
                return {
                    filename: this.normalizeFilename(source.filename),
                    textLower,
                    tokenSet: new Set(this.tokenizeForDiagnostics(textLower))
                };
            });
        }

        getTokenOverlapRatio(tokens, tokenSet) {
            if (!tokens.length) return 0;
            let matches = 0;
            for (const token of tokens) if (tokenSet.has(token)) matches++;
            return matches / tokens.length;
        }

        computeClaimSupportScore(claim, sourceCaches = []) {
            const claimTokens = this.tokenizeForDiagnostics(claim);
            if (!claimTokens.length || sourceCaches.length === 0) return 0;
            let best = 0;
            for (const source of sourceCaches) {
                const overlap = this.getTokenOverlapRatio(claimTokens, source.tokenSet);
                if (overlap > best) best = overlap;
                if (best >= 0.98) break;
            }
            return best;
        }

        evaluateCitationPrecision(citations = [], sourceCaches = []) {
            if (citations.length === 0) return { total: 0, valid: 0, precision: 0 };
            let valid = 0;
            for (const citation of citations) {
                const citedName = this.normalizeFilename(citation.filename);
                const quoteLower = citation.quote.toLowerCase();
                const quoteTokens = this.tokenizeForDiagnostics(quoteLower);
                const filenameMatches = sourceCaches.filter(source =>
                    source.filename === citedName ||
                    source.filename.includes(citedName) ||
                    citedName.includes(source.filename)
                );
                if (filenameMatches.length === 0) continue;
                let quoteSupported = false;
                for (const source of filenameMatches) {
                    if (quoteLower.length >= 8 && source.textLower.includes(quoteLower)) {
                        quoteSupported = true; break;
                    }
                    if (quoteTokens.length > 0) {
                        const overlap = this.getTokenOverlapRatio(quoteTokens, source.tokenSet);
                        if (overlap >= 0.55) { quoteSupported = true; break; }
                    }
                }
                if (quoteSupported) valid++;
            }
            return { total: citations.length, valid, precision: citations.length ? (valid / citations.length) : 0 };
        }

        isLikelyClaimLine(line) {
            const cleaned = line.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim();
            if (cleaned.length < 28) return false;
            if (/^\[Source:/i.test(cleaned)) return false;
            if (/^#{1,6}\s+/.test(cleaned)) return false;
            return /[a-zA-Z]/.test(cleaned);
        }

        extractClaimLines(text) {
            const lines = String(text || '').split('\n').map(line => line.trim()).filter(Boolean);
            const claims = lines
                .map(line => line.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim())
                .filter(line => this.isLikelyClaimLine(line));
            if (claims.length > 0) return claims.slice(0, 40);
            return String(text || '').split(/(?<=[.!?])\s+/)
                .map(sentence => sentence.trim()).filter(sentence => sentence.length > 28).slice(0, 40);
        }

        buildClaimCitationDiagnostics(responseText, sources = []) {
            const sourceCaches = this.buildSourceCaches(sources);
            const claims = this.extractClaimLines(responseText);
            const citations = this.extractCitations(responseText);
            const citationPrecision = this.evaluateCitationPrecision(citations, sourceCaches);
            const claimEvaluations = claims.map(claim => {
                const hasCitation = /\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(claim);
                const supportScore = this.computeClaimSupportScore(claim, sourceCaches);
                return { claim, hasCitation, supportScore };
            });
            const totalClaims = claimEvaluations.length;
            const citedClaims = claimEvaluations.filter(item => item.hasCitation).length;
            const supportedClaims = claimEvaluations.filter(item => item.supportScore >= 0.22).length;

            const directCoverage = totalClaims ? (citedClaims / totalClaims) : 1;
            const citationDensityCoverage = totalClaims ? Math.min(1, citations.length / Math.max(1, Math.ceil(totalClaims * 0.75))) : 1;
            const claimCitationCoverage = Math.max(directCoverage, citationDensityCoverage * 0.92);
            const claimSupportRatio = totalClaims ? (supportedClaims / totalClaims) : 1;
            const weakClaims = claimEvaluations
                .filter(item => !item.hasCitation || item.supportScore < 0.22)
                .slice(0, 5)
                .map(item => `- ${item.claim.slice(0, 180)} (citation=${item.hasCitation ? 'yes' : 'no'}, support=${item.supportScore.toFixed(2)})`);

            const needsRepair = (
                (citations.length === 0 && totalClaims > 0) ||
                (totalClaims >= 3 && claimCitationCoverage < CLAIM_CITATION_TARGET && citations.length < Math.max(2, Math.round(totalClaims * 0.35))) ||
                (totalClaims >= 3 && claimSupportRatio < CLAIM_SUPPORT_TARGET && citationPrecision.precision < CITATION_PRECISION_TARGET)
            );
            return {
                totalClaims,
                citedClaims,
                supportedClaims,
                claimCitationCoverage,
                claimSupportRatio,
                citationPrecision: citationPrecision.precision,
                citationCount: citations.length,
                weakClaims,
                needsRepair
            };
        }

        maybeViolatesOutputContract(text, instructionProfile = {}) {
            const citationCount = this.countCitations(text);
            if (citationCount === 0) return true;
            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                if (!(trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.includes('```json'))) return true;
            }
            if (instructionProfile.requestedFormat === 'table') {
                if (!/\|.+\|/.test(text)) return true;
            }
            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                if (words > Math.ceil(instructionProfile.wordLimit * 1.25)) return true;
            }
            return false;
        }

        async verifyAndRepairAnswer(query, answer, instructionProfile, contextSnippet, diagnostics = null) {
            const diagnosticsBlock = diagnostics ? `
Claim/citation diagnostics:
- Total claims: ${diagnostics.totalClaims}
- Claim citation coverage: ${(diagnostics.claimCitationCoverage * 100).toFixed(1)}%
- Claim support ratio: ${(diagnostics.claimSupportRatio * 100).toFixed(1)}%
- Citation precision: ${(diagnostics.citationPrecision * 100).toFixed(1)}%
Weak claim samples:
${(diagnostics.weakClaims || []).join('\n') || '- none'}
` : '';
            const verifierMessages = [
                {
                    role: 'system',
                    content: `You are a response verifier for strict RAG answers.
If the answer violates instructions or lacks proper citations, repair it.
Always preserve factual grounding and keep citations in format:
[Source: filename, page X, "brief relevant quote"].
Return only the repaired answer text.`
                },
                {
                    role: 'user',
                    content: `Question: ${query}
Instruction profile:
- Format: ${instructionProfile.requestedFormat}
- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
- Word limit: ${instructionProfile.wordLimit || 'none'}
- Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}

Evidence snippet:
${contextSnippet}

${diagnosticsBlock}

Answer to verify/repair:
${answer}`
                }
            ];
            const repaired = await this.callCompletion(verifierMessages, {
                temperature: 0.1,
                max_tokens: 2200,
                top_p: 0.9
            });
            return repaired?.trim() ? repaired : answer;
        }

        getSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
            const numDocs = corpusStats.numDocs || 0;
            const numChunks = corpusStats.numChunks || 0;
            const formatReq = instructionProfile.requestedFormat || 'structured prose';
            const stepReq = instructionProfile.wantsSteps ? 'Yes' : 'No';
            const wordLimit = instructionProfile.wordLimit ? `${instructionProfile.wordLimit} words` : 'No explicit limit';
            const sourceOnly = instructionProfile.strictSourceOnly ? 'Yes - strictly source-grounded.' : 'Ground all factual claims in provided sources.';
            return `You are a COGNITIVE SYNTHESIS ENGINE.

You are given:
1) Retrieved evidence chunks from uploaded documents.
2) Document-memory summaries generated from full uploaded files (outline, key concepts, salient sentences).
3) Optional temporary attachment memory for one-time analysis.

IMPORTANT ACCESS RULE:
- If context is provided, NEVER claim you cannot access the documents.
- Never mention "training cutoff" unless user explicitly asks about model knowledge limits.
- If evidence is missing, say: "Based on the available documents, I cannot fully confirm..."

Human-like synthesis mode (inspired by brain-mimicking LLM research):
- Working-memory loop: obey the current instruction contract precisely.
- Semantic-memory loop: use document-memory summaries to maintain long-range context.
- Retrieval loop: verify claims against cited chunks before finalizing.
- Planner loop: decompose complex queries into sub-questions before writing.
- Map-reduce loop: aggregate distributed evidence across long contexts.
- Verifier loop: self-check instruction compliance and citation completeness.

Corpus snapshot:
- Documents: ${numDocs}
- Chunks: ${numChunks}

Instruction contract:
- Output format: ${formatReq}
- Step-by-step required: ${stepReq}
- Length target: ${wordLimit}
- Source policy: ${sourceOnly}

MANDATORY CITATION FORMAT:
[Source: filename, page X, "brief relevant quote"]

MAXIMIZATION GOAL:
- Deliver complete, high-recall, high-precision synthesis across all provided sources.
- Behave like a "super-analyst" only through better retrieval + planning + verification.
- Never invent evidence, never claim hidden access, never skip citations for factual claims.

CONTEXT:
${context}

WORKING MEMORY FROM PRIOR TURNS:
${workingMemorySummary}
`;
        }

        formatDocumentMemories(documentMemories = []) {
            if (!documentMemories.length) return '';
            const blocks = documentMemories.slice(0, 10).map((doc, idx) => {
                const memory = doc.memory || {};
                const concepts = (memory.keyConcepts || []).slice(0, 10).join(', ') || 'N/A';
                const outline = (memory.outline || []).slice(0, 8).join(' | ') || 'N/A';
                const synopsis = memory.synopsis || (memory.salientSentences || []).slice(0, 3).join(' ');
                return `### Document Memory ${idx + 1}: ${doc.filename}
- Word count: ${memory.wordCount || 'N/A'}
- Reading time (min): ${memory.readingTimeMinutes || 'N/A'}
- Outline: ${outline}
- Key concepts: ${concepts}
- Synopsis: ${synopsis}`;
            });
            return `## DOCUMENT MEMORY BLOCKS (generated from full files)\n${blocks.join('\n\n')}`;
        }

        formatContext(chunks, maxChars = MAX_CONTEXT_CHARS) {
            if (!chunks || chunks.length === 0) {
                return { contextText: 'No relevant documents found in the corpus.', included: 0, omitted: 0 };
            }
            let totalChars = 0;
            const includedBlocks = [];
            let omitted = 0;
            for (const chunk of chunks) {
                const sectionLabel = chunk.section ? `, Section: ${chunk.section}` : '';
                const pageLabel = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const block = `### Evidence: ${chunk.filename} (${pageLabel}${sectionLabel})
${chunk.text}`;
                if (totalChars + block.length > maxChars) { omitted++; continue; }
                includedBlocks.push(block);
                totalChars += block.length;
            }
            if (includedBlocks.length === 0 && chunks.length > 0) {
                const fallback = chunks[0];
                includedBlocks.push(`### Evidence: ${fallback.filename} (Page ${fallback.page || 'N/A'})
${fallback.text.slice(0, Math.min(2500, fallback.text.length))}`);
                omitted = Math.max(0, chunks.length - 1);
            }
            return { contextText: includedBlocks.join('\n\n---\n\n'), included: includedBlocks.length, omitted };
        }

        looksLikeContextRefusal(responseText) {
            if (!responseText) return false;
            return REFUSAL_PATTERNS.some(pattern => pattern.test(responseText));
        }

        buildUserPrompt(query, instructionProfile) {
            const lines = [
                `User question:\n${query}`,
                '',
                'Please obey this response contract:',
                `- Format: ${instructionProfile.requestedFormat}`,
                `- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}`,
                `- Word limit: ${instructionProfile.wordLimit ? instructionProfile.wordLimit : 'no strict limit'}`,
                `- Source-only strictness: ${instructionProfile.strictSourceOnly ? 'strict' : 'grounded, with clear uncertainty if missing'}`
            ];
            return lines.join('\n');
        }

        async callCompletion(messages, overrides = {}) {
            const payload = {
                model: this.model,
                messages,
                temperature: 0.25,
                max_tokens: 2500,
                top_p: 0.9,
                ...overrides
            };
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                let detail = 'API request failed';
                try {
                    const error = await response.json();
                    detail = error.error?.message || detail;
                } catch {
                    detail = `${detail} (HTTP ${response.status})`;
                }
                throw new Error(detail);
            }
            const data = await response.json();
            return data.choices?.[0]?.message?.content || '';
        }

        async synthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
            if (!this.apiKey) throw new Error('API key not configured. Please set your OpenAI API key in the Admin Panel.');
            const instructionProfile = this.buildInstructionProfile(query);
            const workingMemorySummary = this.getWorkingMemorySummary();
            const cognitivePlan = await this.buildCognitivePlan(query, instructionProfile, corpusStats, attachmentContext);
            const useMultiPass = this.shouldUseMultiPass(relevantChunks, attachmentContext, corpusStats, cognitivePlan);

            const contextSections = [];
            contextSections.push(this.formatPlanForContext(cognitivePlan));
            if (attachmentContext?.memory) {
                const m = attachmentContext.memory;
                contextSections.push(`## ATTACHMENT MEMORY (FULL FILE)
File: ${attachmentContext.name}
Word count: ${m.wordCount || 'N/A'}
Outline: ${(m.outline || []).slice(0, 10).join(' | ') || 'N/A'}
Key concepts: ${(m.keyConcepts || []).slice(0, 12).join(', ') || 'N/A'}
Synopsis: ${m.synopsis || (m.salientSentences || []).slice(0, 4).join(' ')}`);
            }
            if (attachmentContext?.digest) {
                contextSections.push(`## ATTACHMENT WIDE-COVERAGE DIGEST\n${attachmentContext.digest}`);
            }
            if (corpusStats.documentMemories && corpusStats.documentMemories.length > 0) {
                contextSections.push(this.formatDocumentMemories(corpusStats.documentMemories));
            }
            if (corpusStats.connectedConcepts && corpusStats.connectedConcepts.length > 0) {
                const conceptSummary = corpusStats.connectedConcepts.slice(0, 10)
                    .map(item => `- "${item.concept}" appears in ${item.docCount} documents`)
                    .join('\n');
                contextSections.push(`## CROSS-DOCUMENT CONCEPT BRIDGES\n${conceptSummary}`);
            }
            if (corpusStats.corpusDigest) contextSections.push(`## CORPUS DIGEST\n${corpusStats.corpusDigest}`);

            let mapNotes = [];
            const hasFullCorpusSweep = !!(corpusStats.fullCorpusSweep && Array.isArray(corpusStats.fullCorpusSweep.docSweeps));
            const shouldRunModelMapPass = useMultiPass && !hasFullCorpusSweep;
            if (shouldRunModelMapPass) {
                const modelMapPassCap = String(this.model || '').toLowerCase().includes('gpt-4.1') ? 3 : MAX_MAP_PASSES;
                const evidenceBatches = this.buildEvidenceBatches(relevantChunks, attachmentContext, MAP_PASS_CONTEXT_BUDGET, modelMapPassCap);
                if (evidenceBatches.length > 0) {
                    mapNotes = await this.runMapPhase(query, cognitivePlan, evidenceBatches);
                    if (mapNotes.length > 0) contextSections.push(this.formatMapNotes(mapNotes));
                }
            }

            const dynamicContextBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.58) : MAX_CONTEXT_CHARS;
            const formattedContext = this.formatContext(relevantChunks, dynamicContextBudget);
            contextSections.push(`## RETRIEVED EVIDENCE CHUNKS
Included chunks: ${formattedContext.included}
Omitted due to context budget: ${formattedContext.omitted}

${formattedContext.contextText}`);

            if (attachmentContext?.chunks && attachmentContext.chunks.length > 0) {
                const attachmentBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.24) : Math.floor(MAX_CONTEXT_CHARS * 0.35);
                const attachmentEvidence = this.formatContext(attachmentContext.chunks, attachmentBudget);
                contextSections.push(`## ATTACHMENT QUERY-SPECIFIC EVIDENCE
Included chunks: ${attachmentEvidence.included}
Omitted due to context budget: ${attachmentEvidence.omitted}

${attachmentEvidence.contextText}`);
            }

            const budgetedContext = this.applyContextBudget(contextSections, TPM_CONTEXT_TOKEN_BUDGET);
            const context = budgetedContext.context;
            const systemPrompt = this.getSystemPrompt(context, corpusStats, instructionProfile, workingMemorySummary);
            const userPrompt = this.buildUserPrompt(query, instructionProfile);
            let messages = [
                { role: 'system', content: systemPrompt },
                ...this.conversationHistory.slice(-10),
                { role: 'user', content: userPrompt }
            ];

            const estimatedPromptTokens = this.estimateMessagesTokens(messages);
            const finalMaxTokens = estimatedPromptTokens > 9000 ? 1100 :
                estimatedPromptTokens > 7500 ? 1400 :
                estimatedPromptTokens > 6000 ? 1700 : 2200;

            let assistantMessage = '';
            try {
                assistantMessage = await this.callCompletion(messages, { max_tokens: finalMaxTokens });
            } catch (error) {
                if (!this.isTpmLimitError(error)) throw error;

                const retryBudgetedContext = this.applyContextBudget(contextSections, TPM_RETRY_CONTEXT_TOKEN_BUDGET);
                const retrySystemPrompt = this.getSystemPrompt(retryBudgetedContext.context, corpusStats, instructionProfile, workingMemorySummary);
                messages = [
                    { role: 'system', content: retrySystemPrompt },
                    ...this.conversationHistory.slice(-6),
                    { role: 'user', content: userPrompt }
                ];
                assistantMessage = await this.callCompletion(messages, {
                    max_tokens: Math.min(1200, finalMaxTokens),
                    temperature: 0.2
                });
            }
            if ((relevantChunks.length > 0 || (attachmentContext?.chunks?.length || 0) > 0) && this.looksLikeContextRefusal(assistantMessage)) {
                const retryMessages = [
                    ...messages,
                    { role: 'assistant', content: assistantMessage },
                    { role: 'user', content: 'You incorrectly stated you cannot access documents. Re-answer using the provided evidence and document-memory blocks above. Do not mention training cutoff unless explicitly asked. Keep strict citations.' }
                ];
                assistantMessage = await this.callCompletion(retryMessages, { temperature: 0.15, max_tokens: Math.min(1200, finalMaxTokens) });
            }

            let sources = [...(relevantChunks || [])];
            if (attachmentContext?.chunks) {
                const attachmentSources = attachmentContext.chunks.map(chunk => ({
                    ...chunk,
                    source: attachmentContext.name,
                    filename: attachmentContext.name,
                    isTemporary: true
                }));
                sources = [...attachmentSources, ...sources];
            }

            const availableSourceCount = sources.length;
            let citationCount = this.countCitations(assistantMessage);
            const minimumCitationTarget = availableSourceCount >= 10 ? 4 : availableSourceCount >= 4 ? 2 : availableSourceCount > 0 ? 1 : 0;
            let claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            const strictRepairNeeded = (
                this.maybeViolatesOutputContract(assistantMessage, instructionProfile) ||
                (availableSourceCount > 0 && citationCount < minimumCitationTarget)
            );
            const softRepairNeeded = (
                claimDiagnostics.needsRepair &&
                (claimDiagnostics.citationCount === 0 || claimDiagnostics.citationPrecision < 0.42 || claimDiagnostics.claimSupportRatio < 0.32)
            );
            if (strictRepairNeeded || softRepairNeeded) {
                const verifierSnippet = [
                    this.formatPlanForContext(cognitivePlan),
                    mapNotes.length ? this.formatMapNotes(mapNotes.slice(0, 3)) : '',
                    `## EVIDENCE SNIPPET\n${formattedContext.contextText.slice(0, 9000)}`
                ].filter(Boolean).join('\n\n');
                assistantMessage = await this.verifyAndRepairAnswer(
                    query, assistantMessage, instructionProfile, verifierSnippet, claimDiagnostics
                );
                citationCount = this.countCitations(assistantMessage);
                claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            }

            this.conversationHistory.push({ role: 'user', content: query }, { role: 'assistant', content: assistantMessage });
            this.saveChatHistory();
            this.rememberTurn(query, assistantMessage);

            return {
                response: assistantMessage,
                sources,
                meta: { instructionProfile, cognitivePlan, mapPassCount: mapNotes.length, citationCount, claimDiagnostics }
            };
        }
    }

    class QualityEvaluator {
        constructor() { this.history = this.loadHistory(); }
        loadHistory() {
            const saved = localStorage.getItem('quality_eval_history');
            try { return saved ? JSON.parse(saved) : []; } catch { return []; }
        }
        saveHistory() {
            const trimmed = this.history.slice(-120);
            localStorage.setItem('quality_eval_history', JSON.stringify(trimmed));
        }
        countCitations(text) {
            return (String(text || '').match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }
        evaluateInstructionAdherence(response, instructionProfile = {}, claimDiagnostics = null) {
            const checks = [];
            const text = String(response || '');
            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                checks.push(trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.includes('```json'));
            } else if (instructionProfile.requestedFormat === 'table') {
                checks.push(/\|.+\|/.test(text));
            } else if (instructionProfile.requestedFormat === 'bullet list') {
                checks.push(/^\s*[-*]\s+/m.test(text) || /^\s*\d+\.\s+/m.test(text));
            }
            if (instructionProfile.wantsSteps) checks.push(/\bStep\s*1\b/i.test(text) || /^\s*1\.\s+/m.test(text));
            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                checks.push(words <= Math.ceil(instructionProfile.wordLimit * 1.25));
            }
            if (instructionProfile.strictSourceOnly) {
                checks.push(this.countCitations(text) > 0);
                if (claimDiagnostics) checks.push(claimDiagnostics.claimCitationCoverage >= CLAIM_CITATION_TARGET);
            }
            if (checks.length === 0) return 1;
            const passed = checks.filter(Boolean).length;
            return passed / checks.length;
        }
        evaluateTurn(query, response, sources = [], instructionProfile = {}, claimDiagnostics = null) {
            const diagnostics = claimDiagnostics || {
                claimCitationCoverage: this.countCitations(response) > 0 ? 0.75 : 0,
                claimSupportRatio: sources.length > 0 ? 0.65 : 1,
                citationPrecision: this.countCitations(response) > 0 ? 0.7 : 0
            };
            const coverage = Math.max(0, Math.min(1, diagnostics.claimSupportRatio || 0));
            const citationCoverage = Math.max(0, Math.min(1, diagnostics.claimCitationCoverage || 0));
            const citationPrecision = Math.max(0, Math.min(1, diagnostics.citationPrecision || 0));
            const instructionAdherence = Math.max(0, Math.min(1, this.evaluateInstructionAdherence(response, instructionProfile, diagnostics)));
            const overall = (coverage * 0.34 + citationCoverage * 0.22 + citationPrecision * 0.22 + instructionAdherence * 0.22);
            const report = {
                timestamp: new Date().toISOString(),
                query: String(query || '').slice(0, 220),
                metrics: { coverage, citationCoverage, citationPrecision, instructionAdherence, overall },
                diagnostics
            };
            this.history.push(report);
            this.saveHistory();
            return report;
        }
        getRecentSummary(limit = 8) {
            const recent = this.history.slice(-limit);
            if (recent.length === 0) return null;
            const sum = recent.reduce((acc, item) => {
                acc.coverage += item.metrics.coverage;
                acc.citationCoverage += item.metrics.citationCoverage;
                acc.citationPrecision += item.metrics.citationPrecision;
                acc.instructionAdherence += item.metrics.instructionAdherence;
                acc.overall += item.metrics.overall;
                return acc;
            }, { coverage: 0, citationCoverage: 0, citationPrecision: 0, instructionAdherence: 0, overall: 0 });
            return {
                sampleSize: recent.length,
                averages: {
                    coverage: sum.coverage / recent.length,
                    citationCoverage: sum.citationCoverage / recent.length,
                    citationPrecision: sum.citationPrecision / recent.length,
                    instructionAdherence: sum.instructionAdherence / recent.length,
                    overall: sum.overall / recent.length
                },
                recent
            };
        }
    }

    class UIController {
        constructor(db, processor, retriever, synthesizer, evaluator) {
            this.db = db;
            this.processor = processor;
            this.retriever = retriever;
            this.synthesizer = synthesizer;
            this.evaluator = evaluator;
            this.currentAttachment = null;
            this.defaultSynthesisText = 'Building mental model and synthesizing across documents...';
            this.initializeElements();
            this.bindEvents();
            this.loadCorpus();
            this.restoreChatHistory();
        }

        initializeElements() {
            this.chatMessages = document.getElementById('chatMessages');
            this.chatInput = document.getElementById('chatInput');
            this.sendBtn = document.getElementById('sendBtn');
            this.synthesisIndicator = document.getElementById('synthesisIndicator');
            this.synthesisIndicatorText = document.getElementById('synthesisIndicatorText');
            this.clearChatBtn = document.getElementById('clearChatBtn');
            this.chatAttachBtn = document.getElementById('chatAttachBtn');
            this.chatFileInput = document.getElementById('chatFileInput');
            this.attachmentPreview = document.getElementById('attachmentPreview');
            this.attachmentName = document.getElementById('attachmentName');
            this.attachmentMeta = document.getElementById('attachmentMeta');
            this.attachmentRemove = document.getElementById('attachmentRemove');
            this.corpusList = document.getElementById('corpusList');
            this.docCount = document.getElementById('docCount');
            this.chunkCount = document.getElementById('chunkCount');
            this.adminPanel = document.getElementById('adminPanel');
            this.adminClose = document.getElementById('adminClose');
            this.openAdminBtn = document.getElementById('openAdminBtn');
            this.uploadZone = document.getElementById('uploadZone');
            this.fileInput = document.getElementById('fileInput');
            this.apiKeyInput = document.getElementById('apiKeyInput');
            this.saveApiKeyBtn = document.getElementById('saveApiKey');
            this.modelSelect = document.getElementById('modelSelect');
            this.processingStatus = document.getElementById('processingStatus');
            this.processingText = document.getElementById('processingText');
            this.processingBarFill = document.getElementById('processingBarFill');
            this.rebuildIndexBtn = document.getElementById('rebuildIndex');
            this.clearCorpusBtn = document.getElementById('clearCorpus');
            this.clearChatAdminBtn = document.getElementById('clearChatAdmin');
            this.runEvalHarnessBtn = document.getElementById('runEvalHarness');
            this.citationModal = document.getElementById('citationModal');
            this.citationClose = document.getElementById('citationClose');
            this.citationSource = document.getElementById('citationSource');
            this.citationText = document.getElementById('citationText');
            this.toastContainer = document.getElementById('toastContainer');
            this.apiKeyInput.value = localStorage.getItem('openai_api_key') || '';
            this.modelSelect.value = localStorage.getItem('openai_model') || 'gpt-4.1';
        }

        bindEvents() {
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            this.chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            this.clearChatBtn.addEventListener('click', () => this.clearChatHistory());
            this.chatAttachBtn.addEventListener('click', () => this.chatFileInput.click());
            this.chatFileInput.addEventListener('change', (e) => this.handleChatAttachment(e));
            this.attachmentRemove.addEventListener('click', () => this.removeChatAttachment());
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyA') {
                    e.preventDefault();
                    this.toggleAdminPanel();
                }
            });
            this.openAdminBtn.addEventListener('click', () => this.toggleAdminPanel(true));
            this.adminClose.addEventListener('click', () => this.toggleAdminPanel(false));
            this.adminPanel.addEventListener('click', (e) => { if (e.target === this.adminPanel) this.toggleAdminPanel(false); });
            this.uploadZone.addEventListener('click', () => this.fileInput.click());
            this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));
            this.uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); this.uploadZone.classList.add('dragover'); });
            this.uploadZone.addEventListener('dragleave', () => this.uploadZone.classList.remove('dragover'));
            this.uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                this.uploadZone.classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            });
            this.saveApiKeyBtn.addEventListener('click', () => {
                const key = this.apiKeyInput.value.trim();
                if (key) {
                    this.synthesizer.setApiKey(key);
                    this.retriever.setEmbeddingApiKey(key);
                    this.showToast('API key saved successfully', 'success');
                } else {
                    this.showToast('Please enter a valid API key', 'error');
                }
            });
            this.modelSelect.addEventListener('change', () => {
                this.synthesizer.setModel(this.modelSelect.value);
                this.showToast(`Model changed to ${this.modelSelect.value}`, 'success');
            });
            this.rebuildIndexBtn.addEventListener('click', () => this.rebuildIndex());
            this.clearCorpusBtn.addEventListener('click', () => this.clearCorpus());
            this.clearChatAdminBtn.addEventListener('click', () => this.clearChatHistory());
            this.runEvalHarnessBtn.addEventListener('click', () => this.runEvaluationHarness());
            this.citationClose.addEventListener('click', () => this.citationModal.classList.remove('active'));
            this.citationModal.addEventListener('click', (e) => { if (e.target === this.citationModal) this.citationModal.classList.remove('active'); });
        }

        toggleAdminPanel(show = null) {
            if (show === null) this.adminPanel.classList.toggle('active');
            else this.adminPanel.classList.toggle('active', show);
        }

        async loadCorpus() {
            const documents = await this.db.getAllDocuments();
            this.retriever.updateCorpus(documents);
            this.updateCorpusUI(documents);
        }

        updateCorpusUI(documents) {
            const totalChunks = documents.reduce((sum, doc) => sum + (doc.chunks?.length || 0), 0);
            this.docCount.textContent = `${documents.length} documents`;
            this.chunkCount.textContent = `${totalChunks} chunks`;
            if (documents.length === 0) {
                this.corpusList.innerHTML = '<div class="corpus-empty">No documents uploaded yet.</div>';
                return;
            }
            this.corpusList.innerHTML = documents.map(doc => `
                <div class="corpus-item" data-id="${doc.id}">
                    <div style="min-width:0;">
                        <div class="corpus-item-name" title="${this.escapeHtml(doc.filename)}">${this.escapeHtml(doc.filename)}</div>
                        <div class="corpus-item-meta">${(doc.size / 1024).toFixed(1)} KB â€¢ ${doc.chunks?.length || 0} chunks</div>
                    </div>
                    <button class="corpus-item-delete" onclick="app.deleteDocument(${doc.id})" title="Delete">âœ•</button>
                </div>
            `).join('');
        }

        async handleFiles(files) {
            const fileArray = Array.from(files);
            if (fileArray.length === 0) return;
            this.processingStatus.classList.add('active');
            let processed = 0;
            const total = fileArray.length;
            for (const file of fileArray) {
                this.processingText.textContent = `Processing ${file.name}...`;
                this.processingBarFill.style.width = `${(processed / total) * 100}%`;
                try {
                    const document = await this.processor.processFile(file);
                    await this.db.addDocument(document);
                    processed++;
                    this.showToast(`Processed: ${file.name}`, 'success');
                } catch (error) {
                    this.showToast(`Failed: ${file.name} (${error.message})`, 'error');
                }
            }
            this.processingBarFill.style.width = '100%';
            this.processingText.textContent = `Completed! Processed ${processed} of ${total} files.`;
            setTimeout(() => {
                this.processingStatus.classList.remove('active');
                this.processingBarFill.style.width = '0%';
            }, 2000);
            await this.loadCorpus();
            this.fileInput.value = '';
        }

        async handleChatAttachment(event) {
            const file = event.target.files[0];
            if (!file) return;
            const ext = (file.name.split('.').pop() || '').toLowerCase();
            const supportedTypes = ['pdf', 'docx', 'txt', 'csv', 'xlsx', 'md'];
            const legacyTypes = ['doc', 'xls'];
            if (legacyTypes.includes(ext)) {
                this.showToast(`.${ext} is not supported in-browser. Convert to ${ext === 'doc' ? 'DOCX' : 'XLSX'} first.`, 'warning');
                this.chatFileInput.value = '';
                return;
            }
            if (!supportedTypes.includes(ext)) {
                this.showToast('Unsupported file type. Supported: PDF, DOCX, TXT, CSV, XLSX, MD', 'error');
                this.chatFileInput.value = '';
                return;
            }
            try {
                this.showToast('Processing attachment...', 'info');
                const result = await this.processor.processFile(file);
                const wordCount = result.memory?.wordCount || result.fullText.split(/\s+/).filter(Boolean).length;
                this.currentAttachment = { name: file.name, chunks: result.chunks, memory: result.memory, type: ext, wordCount };
                this.attachmentName.textContent = file.name;
                this.attachmentMeta.textContent = `${wordCount.toLocaleString()} words - Temporary analysis`;
                this.attachmentPreview.classList.add('active');
                this.showToast(`Attached: ${file.name}`, 'success');
            } catch (error) {
                this.showToast(`Failed to process attachment: ${error.message}`, 'error');
            }
            this.chatFileInput.value = '';
        }

        removeChatAttachment() {
            this.currentAttachment = null;
            this.attachmentPreview.classList.remove('active');
            this.chatFileInput.value = '';
        }

        async deleteDocument(id) {
            if (confirm('Delete this document?')) {
                await this.db.deleteDocument(id);
                await this.loadCorpus();
                this.showToast('Document deleted', 'success');
            }
        }

        async rebuildIndex() {
            this.showToast('Rebuilding index...', 'info');
            await this.loadCorpus();
            this.showToast('Index rebuilt successfully', 'success');
        }

        async clearCorpus() {
            if (confirm('Delete ALL documents? This cannot be undone.')) {
                await this.db.clearAll();
                await this.loadCorpus();
                this.showToast('All documents cleared', 'success');
            }
        }

        clearChatHistory() {
            if (confirm('Clear all chat history?')) {
                this.synthesizer.clearHistory();
                this.chatMessages.innerHTML = `
                    <div class="message system">
                        Chat history cleared. Upload documents and ask questions.
                    </div>`;
                this.showToast('Chat history cleared', 'success');
            }
        }

        restoreChatHistory() {
            const history = this.synthesizer.conversationHistory;
            if (history.length === 0) return;
            for (const msg of history) this.addMessage(msg.content, msg.role);
        }

        setSynthesisMessage(isBroadCoverage) {
            this.synthesisIndicatorText.textContent = isBroadCoverage
                ? 'Running deep coverage synthesis across long context...'
                : this.defaultSynthesisText;
        }

        async sendMessage() {
            const query = this.chatInput.value.trim();
            if (!query) return;
            if (!this.synthesizer.apiKey) {
                this.showToast('Please configure your OpenAI API key in Admin Panel', 'error');
                this.toggleAdminPanel(true);
                return;
            }
            const hasCorpus = this.retriever.allChunks.length > 0;
            const hasAttachment = this.currentAttachment !== null;
            if (!hasCorpus && !hasAttachment) {
                this.showToast('Upload documents or attach a file first', 'warning');
                return;
            }

            let displayMessage = this.escapeHtml(query);
            if (hasAttachment) {
                displayMessage = `<div class="attachment-indicator"><span>ðŸ“Ž ${this.escapeHtml(this.currentAttachment.name)}</span></div>${displayMessage}`;
            }

            this.addMessage(displayMessage, 'user');
            this.chatInput.value = '';
            this.sendBtn.disabled = true;
            const intent = this.retriever.detectQueryIntent(query);
            this.setSynthesisMessage(intent.broadCoverage);
            this.synthesisIndicator.classList.add('active');

            try {
                let relevantChunks = hasCorpus ? await this.retriever.retrieve(query, null, { intent }) : [];
                let attachmentContext = null;
                if (hasAttachment) {
                    const broadCoverage = intent.broadCoverage || (this.currentAttachment.wordCount >= LONG_DOC_WORD_THRESHOLD);
                    const attachmentChunks = await this.retriever.retrieveFromChunks(
                        query,
                        this.currentAttachment.chunks,
                        broadCoverage ? 20 : 12,
                        { intent: { ...intent, broadCoverage } }
                    );
                    attachmentContext = {
                        name: this.currentAttachment.name,
                        chunks: attachmentChunks,
                        memory: this.currentAttachment.memory,
                        digest: broadCoverage ? this.retriever.buildAttachmentDigest(query, this.currentAttachment.chunks, 16) : '',
                        isTemporary: true
                    };
                }

                const relevantFilenames = new Set(relevantChunks.map(chunk => chunk.filename));
                const documentMemories = this.retriever.documents
                    .filter(doc => relevantFilenames.has(doc.filename))
                    .slice(0, 10)
                    .map(doc => ({ filename: doc.filename, memory: doc.memory }));

                const corpusStats = {
                    numDocs: this.retriever.documents.length,
                    numChunks: this.retriever.allChunks.length,
                    connectedConcepts: this.retriever.getTopConnectedConcepts(10),
                    documentMemories,
                    corpusDigest: intent.broadCoverage ? this.retriever.buildCorpusDigest(query, relevantChunks, 16) : ''
                };

                const result = await this.synthesizer.synthesize(query, relevantChunks, attachmentContext, corpusStats);
                this.addMessage(result.response, 'assistant', result.sources);

                if (this.evaluator) {
                    const evaluation = this.evaluator.evaluateTurn(
                        query,
                        result.response,
                        result.sources,
                        result.meta?.instructionProfile || {},
                        result.meta?.claimDiagnostics || null
                    );
                    const scorePct = (evaluation.metrics.overall * 100).toFixed(1);
                    const toastType = evaluation.metrics.overall >= 0.82 ? 'success'
                        : evaluation.metrics.overall >= 0.65 ? 'info' : 'warning';
                    this.showToast(
                        `Eval ${scorePct}% (coverage ${(evaluation.metrics.coverage * 100).toFixed(0)}%, citations ${(evaluation.metrics.citationPrecision * 100).toFixed(0)}%)`,
                        toastType
                    );
                }
            } catch (error) {
                this.addMessage(`I encountered an error: ${this.escapeHtml(error.message)}. Check API key/model and retry.`, 'system');
            } finally {
                this.sendBtn.disabled = false;
                this.synthesisIndicator.classList.remove('active');
                this.setSynthesisMessage(false);
                this.removeChatAttachment();
            }
        }

        runEvaluationHarness() {
            const summary = this.evaluator?.getRecentSummary(10);
            if (!summary) {
                this.showToast('No evaluation data yet. Ask at least one question first.', 'warning');
                return;
            }
            const avg = summary.averages;
            const message = [
                `Eval Harness (last ${summary.sampleSize} turns):`,
                `Overall ${(avg.overall * 100).toFixed(1)}%`,
                `Coverage ${(avg.coverage * 100).toFixed(1)}%`,
                `Claim citation coverage ${(avg.citationCoverage * 100).toFixed(1)}%`,
                `Citation precision ${(avg.citationPrecision * 100).toFixed(1)}%`,
                `Instruction adherence ${(avg.instructionAdherence * 100).toFixed(1)}%`
            ].join(' | ');
            this.addMessage(message, 'system');
            this.showToast(`Eval harness completed: ${(avg.overall * 100).toFixed(1)}% overall`, 'info');
        }

        escapeHtml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        renderMarkdownLite(escapedText) {
            let text = escapedText
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            const lines = text.split('\n');
            let html = '';
            let inUl = false;
            let inOl = false;
            const closeLists = () => {
                if (inUl) { html += '</ul>'; inUl = false; }
                if (inOl) { html += '</ol>'; inOl = false; }
            };
            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) { closeLists(); continue; }
                const ulMatch = line.match(/^- (.+)$/);
                const olMatch = line.match(/^\d+\. (.+)$/);
                if (ulMatch) {
                    if (!inUl) { closeLists(); html += '<ul>'; inUl = true; }
                    html += `<li>${ulMatch[1]}</li>`;
                    continue;
                }
                if (olMatch) {
                    if (!inOl) { closeLists(); html += '<ol>'; inOl = true; }
                    html += `<li>${olMatch[1]}</li>`;
                    continue;
                }
                closeLists();
                html += `<p>${line}</p>`;
            }
            closeLists();
            return html || '<p></p>';
        }

        formatCitations(content, sources) {
            const citationRegex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citationTokens = [];
            let tokenized = content.replace(citationRegex, (match, filename, page, quote) => {
                const token = `__CITATION_${citationTokens.length}__`;
                citationTokens.push({
                    token,
                    filename: String(filename || '').trim(),
                    page: String(page || '').trim(),
                    quote: String(quote || '').trim()
                });
                return token;
            });
            tokenized = this.escapeHtml(tokenized);
            let rendered = this.renderMarkdownLite(tokenized);
            for (const citation of citationTokens) {
                const sourceInfo = `${citation.filename}, Page ${citation.page}`;
                const html = `<span class="citation" data-source="${this.escapeHtml(sourceInfo)}" data-text="${this.escapeHtml(citation.quote)}">${this.escapeHtml(citation.filename).slice(0, 22)}...</span>`;
                rendered = rendered.replace(citation.token, html);
            }
            return rendered;
        }

        addMessage(content, role, sources = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            let processedContent = content;
            if (role === 'assistant') processedContent = this.formatCitations(content, sources);
            else if (role === 'system') processedContent = `<p>${this.escapeHtml(content)}</p>`;
            messageDiv.innerHTML = processedContent;
            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            if (role === 'assistant') {
                messageDiv.querySelectorAll('.citation').forEach(citation => {
                    citation.addEventListener('click', () => {
                        const source = citation.dataset.source;
                        const text = citation.dataset.text;
                        this.showCitation(source, text);
                    });
                });
            }
        }

        showCitation(source, text) {
            this.citationSource.textContent = source;
            this.citationText.textContent = text;
            this.citationModal.classList.add('active');
        }

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            this.toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 4200);
        }
    }

    let app;

    async function initializeApp() {
        try {
            const db = new DocumentDatabase();
            await db.init();
            const processor = new DocumentProcessor();
            const retriever = new CognitiveRetriever();
            const synthesizer = new CognitiveSynthesizer();
            const evaluator = new QualityEvaluator();
            retriever.setEmbeddingApiKey(synthesizer.apiKey);
            app = new UIController(db, processor, retriever, synthesizer, evaluator);
            window.app = app;
            console.log('Cognitive Synthesis Engine initialized successfully');
        } catch (error) {
            console.error('Failed to initialize application:', error);
            alert('Failed to initialize the application. Please refresh the page.');
        }
    }

    document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

    <!-- Inline super-brain enhancer (self-contained; no external dependency). -->
    <script>
    (function inlineSuperBrainEnhancer() {
        'use strict';

        const PATCH_VERSION = '2026-02-11-inline-superbrain-v5';
        const FULL_SCAN_MIN_TOPK = 26;
        const FULL_SCAN_MAX_TOPK = 46;
        const MAX_CONCEPT_EXPANSION = 30;
        const MAX_MENTAL_MODEL_SOURCES = 36;
        const MIN_RICH_CORPUS_CITATIONS = 4;
        const MAX_RETRIEVAL_REFINEMENT_PASSES = 4;
        const RETRIEVAL_STABLE_CHUNK_DELTA = 3;
        const MAX_MODEL_REFINEMENT_PASSES = 3;
        const MODEL_GAP_THRESHOLD = 6;
        const MAX_GAP_REFINEMENT_QUERIES = 4;
        const MIN_CROSS_SOURCE_DOCS = 2;
        const FULL_CORPUS_DOC_ANCHORS_PER_DOC = 6;
        const FULL_CORPUS_DOC_TOP_RELEVANT = 3;
        const FULL_CORPUS_MAP_BLOCK_MAX_CHARS = 14000;
        const CONTRADICTION_BLOCK_MAX_CHARS = 2600;
        const CONTRADICTION_MAX_PAIRS = 6;

        const BRAIN_INSPIRED_PRIOR = [
            'Use latent task structure, not surface wording only.',
            'Link semantically related evidence across documents.',
            'Build and validate an explicit internal mental model before finalizing.',
            'Perform iterative verification against retrieved source evidence only.'
        ];

        function uniqueBy(items, keyFn) {
            const seen = new Set();
            const out = [];
            for (const item of items || []) {
                const key = keyFn(item);
                if (key === undefined || key === null) continue;
                if (seen.has(key)) continue;
                seen.add(key);
                out.push(item);
            }
            return out;
        }

        function normalizeTextLite(text) {
            return String(text || '')
                .toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function patchMethod(klass, methodName, wrapperFactory) {
            if (!klass || !klass.prototype) return false;
            const original = klass.prototype[methodName];
            if (typeof original !== 'function') return false;
            if (original.__inlineSuperBrainPatch === PATCH_VERSION) return true;
            const wrapped = wrapperFactory(original);
            if (typeof wrapped !== 'function') return false;
            wrapped.__inlineSuperBrainPatch = PATCH_VERSION;
            klass.prototype[methodName] = wrapped;
            return true;
        }

        function installRetrieverEnhancements(CognitiveRetriever) {
            if (!CognitiveRetriever || !CognitiveRetriever.prototype) return;

            if (typeof CognitiveRetriever.prototype.extractSemanticConcepts !== 'function') {
                CognitiveRetriever.prototype.extractSemanticConcepts = function extractSemanticConcepts(text) {
                    const source = String(text || '');
                    if (!source) return [];
                    const concepts = new Set();

                    const proper = source.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
                    for (const p of proper) {
                        const v = normalizeTextLite(p);
                        if (v.length >= 3) concepts.add(v);
                    }
                    const hyphenated = source.match(/\b[a-z]+(?:[-_][a-z0-9]+)+\b/gi) || [];
                    for (const h of hyphenated) {
                        const v = normalizeTextLite(h);
                        if (v.length >= 3) concepts.add(v);
                    }
                    const quoted = source.match(/"([^"]{3,80})"/g) || [];
                    for (const q of quoted) {
                        const v = normalizeTextLite(q.replace(/"/g, ''));
                        if (v.length >= 3) concepts.add(v);
                    }

                    const tokens = (typeof this.tokenize === 'function' ? this.tokenize(source) : normalizeTextLite(source).split(/\s+/).filter(Boolean));
                    const freq = new Map();
                    for (const token of tokens) {
                        if (token.length < 4) continue;
                        freq.set(token, (freq.get(token) || 0) + 1);
                    }
                    const top = Array.from(freq.entries())
                        .filter(([, c]) => c >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 16)
                        .map(([token]) => token);
                    for (const token of top) concepts.add(token);
                    return Array.from(concepts).slice(0, 24);
                };
            }

            if (typeof CognitiveRetriever.prototype.buildSemanticBridgeGraph !== 'function') {
                CognitiveRetriever.prototype.buildSemanticBridgeGraph = function buildSemanticBridgeGraph() {
                    this.semanticBridgeGraph = new Map();    // concept -> Map(concept, weight)
                    this.bridgeConceptToChunkIds = new Map(); // concept -> Set(chunkId)
                    this.chunkConcepts = new Map();          // chunkId -> concepts
                    this.chunkIdToDoc = new Map();           // chunkId -> filename

                    const addEdge = (a, b, w) => {
                        if (!a || !b || a === b) return;
                        if (!this.semanticBridgeGraph.has(a)) this.semanticBridgeGraph.set(a, new Map());
                        const neighbors = this.semanticBridgeGraph.get(a);
                        neighbors.set(b, (neighbors.get(b) || 0) + w);
                    };

                    for (const chunk of this.allChunks || []) {
                        const concepts = this.extractSemanticConcepts(chunk.text).slice(0, 18);
                        this.chunkConcepts.set(chunk.id, concepts);
                        this.chunkIdToDoc.set(chunk.id, chunk.filename);

                        for (const concept of concepts) {
                            if (!this.bridgeConceptToChunkIds.has(concept)) this.bridgeConceptToChunkIds.set(concept, new Set());
                            this.bridgeConceptToChunkIds.get(concept).add(chunk.id);
                        }

                        for (let i = 0; i < concepts.length; i++) {
                            for (let j = i + 1; j < concepts.length; j++) {
                                const dist = Math.abs(i - j) + 1;
                                const w = 1 / dist;
                                addEdge(concepts[i], concepts[j], w);
                                addEdge(concepts[j], concepts[i], w);
                            }
                        }
                    }
                };
            }

            if (typeof CognitiveRetriever.prototype.getPerDocumentAnchors !== 'function') {
                CognitiveRetriever.prototype.getPerDocumentAnchors = function getPerDocumentAnchors(query, intent = {}) {
                    const anchors = [];
                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);

                    for (const doc of this.documents || []) {
                        const docChunks = (doc.chunks || [])
                            .map(ch => this.chunkLookup.get(ch.id) || ch)
                            .filter(Boolean);
                        if (!docChunks.length) continue;

                        const scored = docChunks.map(chunk => ({
                            ...chunk,
                            score: this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts)
                        })).sort((a, b) => b.score - a.score);

                        anchors.push(...scored.slice(0, intent.broadCoverage ? 2 : 1));

                        const ordered = docChunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                        const spread = this.pickEvenlyDistributed(ordered, intent.broadCoverage ? 2 : 1);
                        anchors.push(...spread);
                    }

                    return uniqueBy(anchors, item => item.id);
                };
            }

            if (typeof CognitiveRetriever.prototype.expandImplicitLinks !== 'function') {
                CognitiveRetriever.prototype.expandImplicitLinks = function expandImplicitLinks(seedChunks, query, limit = MAX_CONCEPT_EXPANSION) {
                    if (!seedChunks?.length || !this.semanticBridgeGraph?.size || !this.bridgeConceptToChunkIds?.size) return [];

                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);
                    const seedIds = new Set(seedChunks.map(c => c.id));

                    const conceptWeights = new Map();
                    for (const chunk of seedChunks) {
                        const concepts = this.chunkConcepts.get(chunk.id) || this.extractSemanticConcepts(chunk.text);
                        const base = (chunk.score || 0.15) + 0.2;
                        for (const concept of concepts) {
                            conceptWeights.set(concept, (conceptWeights.get(concept) || 0) + base);
                        }
                    }

                    const candidateConcepts = new Map();
                    const topSeedConcepts = Array.from(conceptWeights.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 16);
                    for (const [concept, w] of topSeedConcepts) {
                        candidateConcepts.set(concept, Math.max(candidateConcepts.get(concept) || 0, w));
                        const neighbors = this.semanticBridgeGraph.get(concept);
                        if (!neighbors) continue;
                        const topNeighbors = Array.from(neighbors.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        for (const [neighbor, edgeWeight] of topNeighbors) {
                            const score = (w * 0.65) + (edgeWeight * 0.35);
                            candidateConcepts.set(neighbor, Math.max(candidateConcepts.get(neighbor) || 0, score));
                        }
                    }

                    const candidates = [];
                    for (const [concept, bridgeWeight] of candidateConcepts.entries()) {
                        const chunkIds = this.bridgeConceptToChunkIds.get(concept);
                        if (!chunkIds) continue;
                        for (const chunkId of chunkIds) {
                            if (seedIds.has(chunkId)) continue;
                            const chunk = this.chunkLookup.get(chunkId);
                            if (!chunk) continue;
                            const lexical = this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts);
                            const score = (lexical * 0.74) + (Math.min(bridgeWeight, 5) * 0.08);
                            candidates.push({ ...chunk, score, bridgeConcept: concept });
                        }
                    }

                    return uniqueBy(candidates.sort((a, b) => b.score - a.score), item => item.id).slice(0, limit);
                };
            }

            if (typeof CognitiveRetriever.prototype.buildActivationReport !== 'function') {
                CognitiveRetriever.prototype.buildActivationReport = function buildActivationReport(query, selectedChunks) {
                    const totalDocs = this.documents?.length || 0;
                    const totalChunks = this.allChunks?.length || 0;
                    const activatedDocs = new Set((selectedChunks || []).map(ch => ch.filename));
                    const conceptDocCount = new Map();
                    for (const [concept, ids] of (this.bridgeConceptToChunkIds || new Map()).entries()) {
                        const docs = new Set();
                        for (const id of ids) {
                            const d = this.chunkIdToDoc?.get(id);
                            if (d) docs.add(d);
                        }
                        if (docs.size > 1) conceptDocCount.set(concept, docs.size);
                    }
                    const bridgeConcepts = Array.from(conceptDocCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                        .map(([concept, docs]) => ({ concept, docs }));
                    return {
                        query,
                        totalDocuments: totalDocs,
                        totalChunks,
                        activatedDocuments: activatedDocs.size,
                        activatedChunks: (selectedChunks || []).length,
                        activationCoveragePct: totalDocs ? Math.round((activatedDocs.size / totalDocs) * 100) : 0,
                        bridgeConcepts
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.buildFullCorpusDocumentSweep !== 'function') {
                CognitiveRetriever.prototype.buildFullCorpusDocumentSweep = function buildFullCorpusDocumentSweep(query, options = {}) {
                    const docs = this.documents || [];
                    const qTokens = this.tokenize(query);
                    const qEntities = this.extractEntities(query);
                    const qConcepts = this.extractConcepts(query);
                    const perDocMaxChunks = options.perDocMaxChunks || FULL_CORPUS_DOC_ANCHORS_PER_DOC;
                    const perDocTopRelevant = options.perDocTopRelevant || FULL_CORPUS_DOC_TOP_RELEVANT;
                    const docSweeps = [];

                    for (const doc of docs) {
                        const docChunks = (doc.chunks || [])
                            .map(ch => this.chunkLookup.get(ch.id) || ch)
                            .filter(Boolean);

                        if (!docChunks.length) {
                            docSweeps.push({
                                filename: doc.filename,
                                totalChunks: 0,
                                selectedChunks: [],
                                averageScore: 0,
                                keyConcepts: (doc.memory?.keyConcepts || []).slice(0, 12)
                            });
                            continue;
                        }

                        const scored = docChunks.map(chunk => ({
                            ...chunk,
                            score: this.calculateRelevanceScore(chunk, query, qTokens, qEntities, qConcepts)
                        })).sort((a, b) => b.score - a.score);

                        const ordered = docChunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                        const spreadCount = Math.max(2, Math.min(5, Math.ceil(docChunks.length / 12)));
                        const spread = this.pickEvenlyDistributed(ordered, spreadCount);
                        const boundary = [ordered[0], ordered[ordered.length - 1]].filter(Boolean);

                        const selected = uniqueBy(
                            [...scored.slice(0, perDocTopRelevant), ...spread, ...boundary],
                            item => item.id
                        ).slice(0, perDocMaxChunks);

                        const avgScore = selected.length
                            ? (selected.reduce((sum, chunk) => sum + (chunk.score || 0), 0) / selected.length)
                            : 0;

                        docSweeps.push({
                            filename: doc.filename,
                            totalChunks: docChunks.length,
                            selectedChunks: selected,
                            averageScore: avgScore,
                            keyConcepts: (doc.memory?.keyConcepts || []).slice(0, 12)
                        });
                    }

                    const conceptDocs = new Map();
                    for (const docSweep of docSweeps) {
                        const concepts = docSweep.keyConcepts || [];
                        for (const conceptRaw of concepts) {
                            const concept = normalizeTextLite(conceptRaw);
                            if (!concept) continue;
                            if (!conceptDocs.has(concept)) conceptDocs.set(concept, new Set());
                            conceptDocs.get(concept).add(docSweep.filename);
                        }
                    }

                    const crossConcepts = Array.from(conceptDocs.entries())
                        .filter(([, files]) => files.size > 1)
                        .sort((a, b) => b[1].size - a[1].size)
                        .slice(0, 20)
                        .map(([concept, files]) => ({
                            concept,
                            docs: files.size,
                            files: Array.from(files).slice(0, 8)
                        }));

                    const totalSelectedChunks = docSweeps.reduce((sum, docSweep) => sum + (docSweep.selectedChunks?.length || 0), 0);
                    return {
                        query,
                        totalDocuments: docs.length,
                        totalChunks: this.allChunks?.length || 0,
                        totalSelectedChunks,
                        docSweeps,
                        crossConcepts
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainResolveQueryFromSession !== 'function') {
                CognitiveRetriever.prototype.superBrainResolveQueryFromSession = function superBrainResolveQueryFromSession(query) {
                    const raw = String(query || '').trim();
                    if (!raw) return raw;
                    const hasReference = /\b(it|this|that|those|these|they|them|previous|same one|compare it|what about)\b/i.test(raw);
                    if (!hasReference) return raw;
                    const history = (typeof window !== 'undefined' && window.app?.synthesizer?.conversationHistory)
                        ? window.app.synthesizer.conversationHistory
                        : [];
                    if (!Array.isArray(history) || history.length === 0) return raw;
                    const recentUser = history.slice().reverse().find(item => item?.role === 'user' && String(item?.content || '').trim());
                    if (!recentUser) return raw;
                    const hint = String(recentUser.content || '').replace(/\s+/g, ' ').trim().slice(0, 240);
                    if (!hint) return raw;
                    return `${raw}\n\n[Continuity hint from prior user turn: ${hint}]`;
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildIntentGraph !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildIntentGraph = function superBrainBuildIntentGraph(query) {
                    const normalized = String(query || '').replace(/\s+/g, ' ').trim();
                    const entities = this.extractEntities(normalized).slice(0, 20);
                    const concepts = this.extractConcepts(normalized).slice(0, 24);
                    const constraintPhrases = (normalized.match(/\b(must|cannot|only|at least|at most|required|unless|except|without)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    const relationPhrases = (normalized.match(/\b(cause|impact|depends on|related to|trade[- ]?off|compare|versus|vs)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    const unknownSignals = (normalized.match(/\b(uncertain|unknown|missing|need|evidence|prove|validate)\b[^.?!;]{0,80}/gi) || [])
                        .map(item => item.trim())
                        .slice(0, 10);
                    return {
                        raw: normalized,
                        entities,
                        concepts,
                        constraints: constraintPhrases,
                        relations: relationPhrases,
                        unknowns: unknownSignals
                    };
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainBuildProbeQueries !== 'function') {
                CognitiveRetriever.prototype.superBrainBuildProbeQueries = function superBrainBuildProbeQueries(query, intentGraph = null, intent = {}) {
                    const graph = intentGraph || this.superBrainBuildIntentGraph(query);
                    const probes = [];
                    const push = (value) => {
                        const cleaned = String(value || '').replace(/\s+/g, ' ').trim();
                        if (!cleaned) return;
                        probes.push(cleaned);
                    };
                    push(`${query} semantic evidence relationships constraints`);
                    if (graph.entities.length) push(`${query} ${graph.entities.slice(0, 4).join(' ')} evidence across documents`);
                    if (graph.concepts.length) push(`${query} ${graph.concepts.slice(0, 5).join(' ')} implicit links`);
                    if (graph.constraints.length) push(`${query} constraints exceptions conflicts`);
                    if (graph.relations.length || intent.comparative) push(`${query} compare trade-offs and dependencies`);
                    if (intent.timeline) push(`${query} chronology sequence and milestones`);
                    if (graph.unknowns.length) push(`${query} missing evidence validation`);
                    return uniqueBy(probes, item => normalizeTextLite(item)).slice(0, MAX_RETRIEVAL_REFINEMENT_PASSES * 2);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainDeepScanAugment !== 'function') {
                CognitiveRetriever.prototype.superBrainDeepScanAugment = function superBrainDeepScanAugment(query, selectedChunks = [], targetTopK = FULL_SCAN_MIN_TOPK) {
                    const out = Array.isArray(selectedChunks) ? selectedChunks.slice() : [];
                    const seen = new Set(out.map(item => item.id));
                    const docNames = uniqueBy(out.map(item => item.filename).filter(Boolean), item => item);
                    if (!docNames.length) return out;
                    const qTokens = this.tokenize(query);

                    for (const filename of docNames) {
                        const docChunks = (this.allChunks || [])
                            .filter(item => item.filename === filename)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));
                        if (docChunks.length < 4) continue;

                        const midIdx = Math.floor(docChunks.length / 2);
                        const lateIdx = Math.floor(docChunks.length * 0.8);
                        const deepCandidates = [docChunks[midIdx], docChunks[lateIdx], docChunks[docChunks.length - 1]]
                            .filter(Boolean)
                            .map(chunk => ({
                                ...chunk,
                                score: this.calculateRelevanceScore(chunk, query, qTokens, this.extractEntities(query), this.extractConcepts(query))
                            }))
                            .sort((a, b) => (b.score || 0) - (a.score || 0));

                        for (const candidate of deepCandidates) {
                            if (out.length >= targetTopK) break;
                            if (!candidate?.id || seen.has(candidate.id)) continue;
                            out.push(candidate);
                            seen.add(candidate.id);
                        }
                        if (out.length >= targetTopK) break;
                    }

                    return out.slice(0, targetTopK);
                };
            }

            if (typeof CognitiveRetriever.prototype.superBrainRunRetrievalRefinement !== 'function') {
                CognitiveRetriever.prototype.superBrainRunRetrievalRefinement = async function superBrainRunRetrievalRefinement(query, seedChunks = [], topK = FULL_SCAN_MIN_TOPK, options = {}, intent = {}, originalRetrieve = null) {
                    if (typeof originalRetrieve !== 'function') {
                        return { chunks: seedChunks || [], passes: 1, stabilized: true, intentGraph: this.superBrainBuildIntentGraph(query) };
                    }

                    const intentGraph = this.superBrainBuildIntentGraph(query);
                    const probes = this.superBrainBuildProbeQueries(query, intentGraph, intent);
                    let merged = Array.isArray(seedChunks) ? seedChunks.slice() : [];
                    let passes = 1;
                    let stableHits = 0;
                    let prevChunkCount = merged.length;
                    let prevDocCount = new Set(merged.map(item => item.filename)).size;

                    for (const probe of probes) {
                        if (passes >= MAX_RETRIEVAL_REFINEMENT_PASSES) break;
                        let probeResults = [];
                        try {
                            probeResults = await originalRetrieve.call(
                                this,
                                probe,
                                Math.max(FULL_SCAN_MIN_TOPK, Math.ceil(topK * 0.8)),
                                { ...options, intent: { ...intent, broadCoverage: true } }
                            );
                        } catch {
                            probeResults = [];
                        }
                        const anchors = this.getPerDocumentAnchors(probe, { ...intent, broadCoverage: true });
                        const links = this.expandImplicitLinks(probeResults, probe, Math.max(10, Math.floor(MAX_CONCEPT_EXPANSION * 0.8)));
                        const mergedProbe = this.mergeUniqueChunks(
                            this.mergeUniqueChunks(probeResults || [], anchors || [], Math.max(topK * 2, 96)),
                            links || [],
                            Math.max(topK * 3, 128)
                        );
                        merged = this.mergeUniqueChunks(merged, mergedProbe, Math.max(topK * 4, 180));

                        const chunkCount = merged.length;
                        const docCount = new Set(merged.map(item => item.filename)).size;
                        const chunkDelta = chunkCount - prevChunkCount;
                        const docDelta = docCount - prevDocCount;
                        if (docDelta <= 0 && chunkDelta <= RETRIEVAL_STABLE_CHUNK_DELTA) stableHits += 1;
                        else stableHits = 0;
                        prevChunkCount = chunkCount;
                        prevDocCount = docCount;
                        passes += 1;
                        if (stableHits >= 1) break;
                    }

                    return {
                        chunks: merged,
                        passes,
                        stabilized: stableHits >= 1,
                        intentGraph
                    };
                };
            }
        }

        function installSynthEnhancements(CognitiveSynthesizer) {
            if (!CognitiveSynthesizer || !CognitiveSynthesizer.prototype) return;

            if (typeof CognitiveSynthesizer.prototype.superBrainTokenize !== 'function') {
                CognitiveSynthesizer.prototype.superBrainTokenize = function superBrainTokenize(text) {
                    const stop = new Set([
                        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                        'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'it', 'this', 'that', 'these', 'those',
                        'can', 'could', 'should', 'would', 'may', 'might', 'will', 'also'
                    ]);
                    return normalizeTextLite(text).split(/\s+/).filter(t => t.length > 2 && !stop.has(t));
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainFormatModelBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainFormatModelBlock = function superBrainFormatModelBlock(model) {
                    const relLines = (model.relationships || []).map(item => {
                        if (typeof item === 'string') return `- ${item}`;
                        const stmt = item?.statement || `${item?.subject || ''} ${item?.predicate || ''} ${item?.object || ''}`.trim();
                        return stmt ? `- ${stmt}` : null;
                    }).filter(Boolean);
                    return [
                        '## PRE-BUILT MENTAL MODEL (STRICT SOURCE-GROUNDED)',
                        `- Entities: ${(model.entities || []).join(', ') || 'N/A'}`,
                        `- Concepts: ${(model.concepts || []).join(', ') || 'N/A'}`,
                        '- Relationships:',
                        ...(relLines.length ? relLines : ['- N/A']),
                        '- Constraints:',
                        ...((model.constraints || []).length ? model.constraints.map(x => `- ${x}`) : ['- N/A']),
                        '- Assumptions:',
                        ...((model.assumptions || []).length ? model.assumptions.map(x => `- ${x}`) : ['- N/A']),
                        '- Evidence gaps:',
                        ...((model.gaps || []).length ? model.gaps.map(x => `- ${x}`) : ['- N/A'])
                    ].join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildMentalModel !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildMentalModel = async function superBrainBuildMentalModel(query, sources = [], activationReport = null) {
                    const selected = (sources || []).slice(0, MAX_MENTAL_MODEL_SOURCES);
                    const corpusText = selected.map(s => String(s.text || '')).join('\n');
                    const entities = Array.from(new Set(
                        (corpusText.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [])
                            .map(x => normalizeTextLite(x))
                            .filter(Boolean)
                    )).slice(0, 16);
                    const tokenFreq = new Map();
                    for (const token of this.superBrainTokenize(corpusText)) {
                        tokenFreq.set(token, (tokenFreq.get(token) || 0) + 1);
                    }
                    const concepts = Array.from(tokenFreq.entries())
                        .filter(([, c]) => c >= 3)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 18)
                        .map(([token]) => token);
                    const sentences = corpusText.split(/(?<=[.!?])\s+/);
                    const relationships = sentences
                        .filter(s => /\b(causes?|leads to|results? in|depends on|requires?|enables?|prevents?|increases?|decreases?)\b/i.test(s))
                        .slice(0, 10)
                        .map(s => ({ statement: s.trim().slice(0, 240) }));
                    const constraints = sentences
                        .filter(s => /\b(must|required|cannot|only|at least|at most|limit|constraint)\b/i.test(s))
                        .slice(0, 10)
                        .map(s => s.trim().slice(0, 220));
                    const assumptions = sentences
                        .filter(s => /\b(assume|assuming|likely|may|might|unclear)\b/i.test(s))
                        .slice(0, 8)
                        .map(s => s.trim().slice(0, 220));
                    const queryTokens = this.superBrainTokenize(query);
                    const evidenceTokenSet = new Set(this.superBrainTokenize(corpusText));
                    const gaps = queryTokens
                        .filter(t => !evidenceTokenSet.has(t))
                        .slice(0, 10)
                        .map(t => `Insufficient direct evidence for concept: "${t}"`);

                    const heuristic = { entities, concepts, relationships, constraints, assumptions, gaps };
                    if (!this.apiKey || selected.length === 0) return heuristic;

                    const digest = selected.map((s, i) => {
                        const page = s.page ? `page ${s.page}` : 'page N/A';
                        return `${i + 1}. [${s.filename}, ${page}] ${String(s.text || '').replace(/\s+/g, ' ').slice(0, 280)}`;
                    }).join('\n');
                    const activationLine = activationReport
                        ? `Activated documents: ${activationReport.activatedDocuments}/${activationReport.totalDocuments}; activated chunks: ${activationReport.activatedChunks}/${activationReport.totalChunks}.`
                        : '';

                    const messages = [
                        {
                            role: 'system',
                            content: 'You are an internal cognition module for strict RAG. Return ONLY valid JSON with keys: entities, concepts, relationships, constraints, assumptions, gaps. Use only provided evidence.'
                        },
                        {
                            role: 'user',
                            content: `Question: ${query}\n${activationLine}\nEvidence digest:\n${digest}`
                        }
                    ];
                    try {
                        const raw = await this.callCompletion(messages, { temperature: 0.1, max_tokens: 900, top_p: 0.9 });
                        const parsed = this.safeJsonParse(raw);
                        if (!parsed || typeof parsed !== 'object') return heuristic;
                        return {
                            entities: Array.isArray(parsed.entities) ? parsed.entities.slice(0, 16) : heuristic.entities,
                            concepts: Array.isArray(parsed.concepts) ? parsed.concepts.slice(0, 20) : heuristic.concepts,
                            relationships: Array.isArray(parsed.relationships) ? parsed.relationships.slice(0, 12) : heuristic.relationships,
                            constraints: Array.isArray(parsed.constraints) ? parsed.constraints.slice(0, 10) : heuristic.constraints,
                            assumptions: Array.isArray(parsed.assumptions) ? parsed.assumptions.slice(0, 10) : heuristic.assumptions,
                            gaps: Array.isArray(parsed.gaps) ? parsed.gaps.slice(0, 10) : heuristic.gaps
                        };
                    } catch {
                        return heuristic;
                    }
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBestSentence !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBestSentence = function superBrainBestSentence(text, queryTokens = []) {
                    const sentences = String(text || '')
                        .split(/(?<=[.!?])\s+/)
                        .map(s => s.trim())
                        .filter(Boolean);
                    if (!sentences.length) return String(text || '').slice(0, 220);
                    if (!queryTokens.length) return sentences[0].slice(0, 220);
                    let best = sentences[0];
                    let bestScore = -1;
                    for (const sentence of sentences) {
                        const lower = sentence.toLowerCase();
                        const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                        if (score > bestScore) {
                            best = sentence;
                            bestScore = score;
                        }
                    }
                    return best.slice(0, 240);
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildFullCorpusMapBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildFullCorpusMapBlock = function superBrainBuildFullCorpusMapBlock(query, sweep, maxChars = FULL_CORPUS_MAP_BLOCK_MAX_CHARS) {
                    if (!sweep || !Array.isArray(sweep.docSweeps) || sweep.docSweeps.length === 0) return '';
                    const queryTokens = this.superBrainTokenize(query);
                    const lines = [];
                    lines.push('## FULL-CORPUS DOCUMENT MAP SWEEP (DOCUMENT-BY-DOCUMENT)');
                    lines.push(`Documents swept: ${sweep.totalDocuments || sweep.docSweeps.length}`);
                    lines.push(`Total corpus chunks: ${sweep.totalChunks || 0}`);
                    lines.push(`Selected sweep anchors: ${sweep.totalSelectedChunks || 0}`);
                    lines.push('');

                    let charCount = lines.join('\n').length;
                    const remainingBudget = Math.max(2400, maxChars - charCount);
                    const perDocBudget = Math.max(120, Math.floor(remainingBudget / Math.max(1, sweep.docSweeps.length)));
                    const pushLine = (line) => {
                        lines.push(line);
                        charCount += line.length + 1;
                    };

                    for (let i = 0; i < sweep.docSweeps.length; i++) {
                        const doc = sweep.docSweeps[i];
                        const primary = (doc.selectedChunks || [])[0];
                        if (!primary) {
                            pushLine(`- DOC ${i + 1}: ${doc.filename} â€” no anchor chunks available.`);
                            continue;
                        }

                        const primarySentence = this.superBrainBestSentence(primary.text, queryTokens)
                            .replace(/\s+/g, ' ')
                            .trim()
                            .slice(0, Math.max(80, perDocBudget - 100));
                        const primaryQuote = primarySentence.slice(0, 110).replace(/"/g, '\'');
                        const primaryPage = primary.page || 'N/A';
                        pushLine(`- DOC ${i + 1}: ${doc.filename} -> ${primarySentence} [Source: ${doc.filename}, page ${primaryPage}, "${primaryQuote}"]`);

                        if (charCount > maxChars) {
                            pushLine('- Additional per-document evidence lines truncated for prompt budget safety; sweep execution still covered all documents.');
                            break;
                        }
                    }

                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildFullCorpusReduceBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildFullCorpusReduceBlock = function superBrainBuildFullCorpusReduceBlock(sweep) {
                    if (!sweep || !Array.isArray(sweep.docSweeps) || sweep.docSweeps.length === 0) return '';
                    const lines = [];
                    lines.push('## FULL-CORPUS REDUCE SYNTHESIS');
                    const crossConcepts = Array.isArray(sweep.crossConcepts) ? sweep.crossConcepts.slice(0, 14) : [];
                    if (crossConcepts.length) {
                        lines.push('- Cross-document concept bridges:');
                        for (const item of crossConcepts) {
                            lines.push(`- "${item.concept}" appears in ${item.docs} documents (${(item.files || []).join(', ')})`);
                        }
                    } else {
                        lines.push('- No strong repeated bridge concepts detected across multiple documents.');
                    }

                    const topDocs = sweep.docSweeps
                        .slice()
                        .sort((a, b) => (b.averageScore || 0) - (a.averageScore || 0))
                        .slice(0, 10);
                    if (topDocs.length) {
                        lines.push('- Highest query-aligned documents in full sweep:');
                        for (const doc of topDocs) {
                            lines.push(`- ${doc.filename} (avg anchor relevance ${(doc.averageScore || 0).toFixed(3)})`);
                        }
                    }
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainTokenOverlap !== 'function') {
                CognitiveSynthesizer.prototype.superBrainTokenOverlap = function superBrainTokenOverlap(tokensA = [], tokensB = []) {
                    if (!tokensA.length || !tokensB.length) return [];
                    const setB = new Set(tokensB);
                    const overlap = [];
                    for (const token of tokensA) {
                        if (setB.has(token)) overlap.push(token);
                    }
                    return Array.from(new Set(overlap));
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildContradictionBlock !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildContradictionBlock = function superBrainBuildContradictionBlock(query, sources = [], maxPairs = CONTRADICTION_MAX_PAIRS, maxChars = CONTRADICTION_BLOCK_MAX_CHARS) {
                    const selected = (sources || []).slice(0, 180);
                    if (!selected.length) return '';

                    const restrictiveRegex = /\b(must|required|shall|cannot|can't|prohibited|not allowed|only|ineligible|restricted)\b/i;
                    const permissiveRegex = /\b(may|can|allowed|eligible|unless|either|or|option)\b/i;
                    const policyLikeRegex = /\b(policy|enrol|enroll|require|limit|program|course|admission|completion|eligible|ineligible)\b/i;

                    const restrictive = [];
                    const permissive = [];

                    for (const source of selected) {
                        const text = String(source.text || '');
                        if (!text) continue;
                        const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
                        for (const sentenceRaw of sentences) {
                            const sentence = sentenceRaw.replace(/\s+/g, ' ').trim();
                            if (sentence.length < 40 || sentence.length > 330) continue;
                            if (!policyLikeRegex.test(sentence)) continue;
                            const tokens = this.superBrainTokenize(sentence).slice(0, 28);
                            if (tokens.length < 5) continue;
                            const item = {
                                sentence,
                                tokens,
                                filename: source.filename || 'Unknown',
                                page: source.page || 'N/A'
                            };
                            if (restrictiveRegex.test(sentence)) restrictive.push(item);
                            if (permissiveRegex.test(sentence)) permissive.push(item);
                        }
                    }

                    if (!restrictive.length || !permissive.length) return '## CONTRADICTION CHECK\n- No high-signal policy contradictions detected in sampled evidence.';

                    const pairs = [];
                    const restrictHead = restrictive.slice(0, 90);
                    const permissiveHead = permissive.slice(0, 90);
                    for (const a of restrictHead) {
                        for (const b of permissiveHead) {
                            if (a.sentence === b.sentence) continue;
                            const overlap = this.superBrainTokenOverlap(a.tokens, b.tokens);
                            if (overlap.length < 4) continue;
                            const score = overlap.length + (a.filename !== b.filename ? 0.6 : 0);
                            pairs.push({ a, b, overlap, score });
                        }
                    }

                    const ordered = pairs.sort((x, y) => y.score - x.score);
                    const unique = [];
                    const seenIssues = new Set();
                    for (const pair of ordered) {
                        const issueKey = pair.overlap.slice(0, 4).join('|');
                        if (!issueKey || seenIssues.has(issueKey)) continue;
                        seenIssues.add(issueKey);
                        unique.push(pair);
                        if (unique.length >= maxPairs) break;
                    }

                    if (!unique.length) return '## CONTRADICTION CHECK\n- No high-signal policy contradictions detected in sampled evidence.';

                    const lines = ['## CONTRADICTION CHECK (CROSS-SOURCE TENSION TEST)'];
                    for (let i = 0; i < unique.length; i++) {
                        const pair = unique[i];
                        const issue = pair.overlap.slice(0, 5).join(', ');
                        const aQuote = pair.a.sentence.slice(0, 120).replace(/"/g, '\'');
                        const bQuote = pair.b.sentence.slice(0, 120).replace(/"/g, '\'');
                        lines.push(`- Potential tension ${i + 1} on: ${issue}`);
                        lines.push(`  - Restrictive evidence: ${pair.a.sentence.slice(0, 220)} [Source: ${pair.a.filename}, page ${pair.a.page}, "${aQuote}"]`);
                        lines.push(`  - Permissive/conditional evidence: ${pair.b.sentence.slice(0, 220)} [Source: ${pair.b.filename}, page ${pair.b.page}, "${bQuote}"]`);
                        lines.push('  - Resolution guidance: Treat as scope-dependent; verify whether condition/exceptions narrow applicability.');
                    }

                    let block = lines.join('\n');
                    if (block.length > maxChars) {
                        block = `${block.slice(0, maxChars - 120)}\n- Additional contradiction checks truncated for prompt budget safety.`;
                    }
                    return block;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainNormalizeCitationSyntax !== 'function') {
                CognitiveSynthesizer.prototype.superBrainNormalizeCitationSyntax = function superBrainNormalizeCitationSyntax(text) {
                    let out = String(text || '');
                    if (!out) return out;
                    out = out.replace(/\[(source)\s*:/gi, '[Source:');
                    out = out.replace(/\(Source:\s*([^)]+)\)/gi, '[Source: $1]');

                    // [Source: file, "quote"] -> [Source: file, page N/A, "quote"]
                    out = out.replace(/\[Source:\s*([^,\]\n]+)\s*,\s*"([^"]+)"\]/gi, '[Source: $1, page N/A, "$2"]');

                    // [Source: file, page X] -> include placeholder quote for clickable citation rendering.
                    out = out.replace(/\[Source:\s*([^,\]\n]+)\s*,\s*(?:page\s*)?([^,\]\n]+)\s*\]/gi, '[Source: $1, page $2, "citation excerpt unavailable"]');
                    return out;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainHasMalformedCitationPatterns !== 'function') {
                CognitiveSynthesizer.prototype.superBrainHasMalformedCitationPatterns = function superBrainHasMalformedCitationPatterns(text) {
                    const value = String(text || '');
                    if (!value) return false;
                    if (/\bCitations?:\s*\n/i.test(value) && !/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(value)) {
                        return true;
                    }
                    if (/\b[A-Za-z0-9._ -]+\.(?:pdf|docx|md)\s*\.\.\./i.test(value)) return true;
                    if (/\[Source:\s*[^\]]*$/m.test(value)) return true;
                    return false;
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildGapDrivenQueries !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildGapDrivenQueries = function superBrainBuildGapDrivenQueries(query, model = null) {
                    const out = [];
                    const push = (value) => {
                        const cleaned = String(value || '').replace(/\s+/g, ' ').trim();
                        if (cleaned) out.push(cleaned);
                    };
                    push(`${query} cross-source supporting evidence`);
                    push(`${query} constraints exceptions conflicts`);
                    const gaps = Array.isArray(model?.gaps) ? model.gaps : [];
                    for (const gapRaw of gaps.slice(0, MAX_GAP_REFINEMENT_QUERIES)) {
                        const gap = String(gapRaw || '')
                            .replace(/^Insufficient direct evidence for concept:\s*/i, '')
                            .replace(/"/g, '')
                            .trim();
                        if (!gap) continue;
                        push(`${query} ${gap} validating evidence`);
                    }
                    return uniqueBy(out, item => normalizeTextLite(item)).slice(0, MAX_GAP_REFINEMENT_QUERIES + 2);
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainAssessEvidenceCompleteness !== 'function') {
                CognitiveSynthesizer.prototype.superBrainAssessEvidenceCompleteness = function superBrainAssessEvidenceCompleteness(
                    query,
                    sources = [],
                    model = null,
                    activationReport = {},
                    instructionProfile = {}
                ) {
                    const deduped = uniqueBy(
                        sources || [],
                        item => item?.id || `${item?.filename || 'unknown'}:${item?.index || 0}:${item?.page || 'na'}`
                    );
                    const sourceCount = deduped.length;
                    const docCount = new Set(deduped.map(item => item.filename).filter(Boolean)).size;
                    const totalDocs = activationReport.totalDocuments || docCount;
                    const broadOrDecision = !!instructionProfile?.decisionMode || /\b(overall|across|entire|comprehensive|compare|contrast|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                    const requiredDocs = broadOrDecision ? (totalDocs >= 7 ? 3 : Math.min(totalDocs, MIN_CROSS_SOURCE_DOCS)) : 1;
                    const activationCoverage = activationReport.activationCoveragePct || 0;
                    const gapCount = Array.isArray(model?.gaps) ? model.gaps.length : 0;

                    const reasons = [];
                    if (sourceCount === 0) reasons.push('No retrievable evidence was found for the question.');
                    if (requiredDocs > 1 && docCount < requiredDocs) {
                        reasons.push(`Cross-source coverage is insufficient (${docCount}/${requiredDocs} required documents).`);
                    }
                    if (broadOrDecision && totalDocs >= 5 && activationCoverage > 0 && activationCoverage < 22) {
                        reasons.push(`Activation coverage remains low for a broad query (${activationCoverage}%).`);
                    }
                    if (gapCount >= MODEL_GAP_THRESHOLD && docCount < Math.max(2, requiredDocs)) {
                        reasons.push('Mental model still has unresolved high-priority evidence gaps.');
                    }

                    const requestedDocuments = [];
                    if (sourceCount === 0) {
                        requestedDocuments.push(`Primary source documents directly addressing: "${query}"`);
                    }
                    if (requiredDocs > 1 && docCount < requiredDocs) {
                        requestedDocuments.push(`Additional relevant sources from at least ${requiredDocs} distinct documents are needed.`);
                    }
                    for (const gapRaw of (model?.gaps || []).slice(0, 5)) {
                        requestedDocuments.push(`Source material that explicitly covers: ${String(gapRaw).replace(/^Insufficient direct evidence for concept:\s*/i, '').replace(/"/g, '').trim()}`);
                    }

                    return {
                        needsMoreEvidence: reasons.length > 0,
                        sourceCount,
                        docCount,
                        totalDocs,
                        requiredDocs,
                        activationCoverage,
                        reasons: uniqueBy(reasons, item => item),
                        requestedDocuments: uniqueBy(requestedDocuments.filter(Boolean), item => item).slice(0, 8)
                    };
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainBuildMissingEvidenceResponse !== 'function') {
                CognitiveSynthesizer.prototype.superBrainBuildMissingEvidenceResponse = function superBrainBuildMissingEvidenceResponse(query, completeness, sources = [], model = null) {
                    const queryTokens = this.superBrainTokenize(query);
                    const evidenceLines = (sources || []).slice(0, 4).map(source => {
                        const sentence = this.superBrainBestSentence(source.text || '', queryTokens).replace(/\s+/g, ' ').trim();
                        if (!sentence) return null;
                        const quote = sentence.slice(0, 110).replace(/"/g, '\'');
                        return `- ${sentence.slice(0, 210)} [Source: ${source.filename || 'Unknown'}, page ${source.page || 'N/A'}, "${quote || 'relevant quote'}"]`;
                    }).filter(Boolean);

                    const lines = [
                        '## Mental Model',
                        '- Status: Incomplete for a reliable expert conclusion.',
                        `- Query focus: ${query}`,
                        `- Current entities: ${(model?.entities || []).slice(0, 8).join(', ') || 'N/A'}`,
                        `- Current concepts: ${(model?.concepts || []).slice(0, 10).join(', ') || 'N/A'}`,
                        '',
                        '## Evidence-Based Status',
                        `- Source chunks reviewed: ${completeness?.sourceCount || 0}`,
                        `- Distinct documents covered: ${completeness?.docCount || 0}/${completeness?.requiredDocs || 1} required`,
                        completeness?.activationCoverage ? `- Activation coverage: ${completeness.activationCoverage}%` : '- Activation coverage: N/A'
                    ];

                    if (evidenceLines.length) {
                        lines.push('- Current grounded evidence:');
                        lines.push(...evidenceLines);
                    } else {
                        lines.push('- No citable evidence is currently available for this question.');
                    }

                    lines.push('', '## Uncertainties & Missing Information');
                    for (const reason of (completeness?.reasons || [])) lines.push(`- ${reason}`);
                    if (!completeness?.reasons?.length) lines.push('- Evidence is insufficient to produce a high-confidence answer.');
                    if (Array.isArray(model?.gaps) && model.gaps.length) {
                        lines.push('- Open evidence gaps:');
                        for (const gap of model.gaps.slice(0, 6)) lines.push(`- ${gap}`);
                    }

                    lines.push('', '## Required Documents/Data');
                    const requested = completeness?.requestedDocuments || [];
                    if (requested.length) {
                        requested.forEach((item, idx) => lines.push(`${idx + 1}. ${item}`));
                    } else {
                        lines.push('1. Additional source documents that directly answer unresolved parts of the question.');
                    }
                    lines.push('');
                    lines.push('Please provide the missing documents/data so I can complete a fully grounded, cross-source expert answer with precise citations.');
                    return lines.join('\n');
                };
            }

            if (typeof CognitiveSynthesizer.prototype.superBrainRunModelRefinementLoop !== 'function') {
                CognitiveSynthesizer.prototype.superBrainRunModelRefinementLoop = async function superBrainRunModelRefinementLoop(
                    query,
                    relevantChunks = [],
                    attachmentContext = null,
                    localStats = {},
                    instructionProfile = {}
                ) {
                    const retriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                    const broadOrDecision = !!instructionProfile?.decisionMode || /\b(overall|across|entire|comprehensive|compare|contrast|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                    let chunks = uniqueBy(relevantChunks || [], item => item.id || `${item.filename}:${item.index || 0}`);
                    let passes = 1;
                    let stableHits = 0;
                    let previousGapCount = null;
                    let model = null;
                    let completeness = null;

                    for (let cycle = 0; cycle < MAX_MODEL_REFINEMENT_PASSES; cycle++) {
                        passes = cycle + 1;
                        const sourcesForModel = uniqueBy(
                            [
                                ...(attachmentContext?.chunks || []).map(item => ({ ...item, filename: attachmentContext?.name || item.filename || 'attachment' })),
                                ...chunks
                            ],
                            item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                        ).slice(0, MAX_MENTAL_MODEL_SOURCES * 2);

                        model = await this.superBrainBuildMentalModel(query, sourcesForModel, localStats.activationReport || null);
                        completeness = this.superBrainAssessEvidenceCompleteness(
                            query,
                            sourcesForModel,
                            model,
                            localStats.activationReport || {},
                            instructionProfile
                        );

                        const gapCount = Array.isArray(model?.gaps) ? model.gaps.length : 0;
                        const gapDelta = previousGapCount === null ? null : Math.abs(gapCount - previousGapCount);
                        if (gapDelta !== null && gapDelta <= 1) stableHits += 1;
                        else stableHits = 0;
                        previousGapCount = gapCount;

                        const shouldRetrieveAgain = completeness.needsMoreEvidence &&
                            broadOrDecision &&
                            retriever &&
                            typeof retriever.retrieve === 'function' &&
                            stableHits < 1;
                        if (!shouldRetrieveAgain) break;

                        const gapQueries = this.superBrainBuildGapDrivenQueries(query, model);
                        if (!gapQueries.length) break;
                        const expanded = [];
                        for (const gapQuery of gapQueries.slice(0, MAX_GAP_REFINEMENT_QUERIES)) {
                            try {
                                const retrieved = await retriever.retrieve(gapQuery, null, {
                                    intent: {
                                        ...(typeof retriever.detectQueryIntent === 'function' ? retriever.detectQueryIntent(gapQuery) : {}),
                                        broadCoverage: true,
                                        comparative: true
                                    }
                                });
                                expanded.push(...(retrieved || []));
                            } catch {
                                // keep loop resilient on transient retrieval failures
                            }
                        }
                        if (!expanded.length) break;
                        const merged = uniqueBy([...chunks, ...expanded], item => item.id || `${item.filename}:${item.index || 0}`);
                        if (merged.length <= chunks.length + 1) {
                            stableHits += 1;
                            if (stableHits >= 1) break;
                        }
                        chunks = merged;
                    }

                    return {
                        chunks,
                        model,
                        completeness,
                        passes,
                        stabilized: stableHits >= 1
                    };
                };
            }
        }

        function tryInstall() {
            if (typeof CognitiveRetriever !== 'function' || typeof CognitiveSynthesizer !== 'function') return false;

            installRetrieverEnhancements(CognitiveRetriever);
            installSynthEnhancements(CognitiveSynthesizer);

            patchMethod(CognitiveRetriever, 'updateCorpus', (original) => function patchedUpdateCorpus(documents) {
                const result = original.call(this, documents);
                if (typeof this.buildSemanticBridgeGraph === 'function') this.buildSemanticBridgeGraph();
                return result;
            });

            patchMethod(CognitiveRetriever, 'retrieve', (original) => async function patchedRetrieve(query, topK = null, options = {}) {
                if (!this.allChunks?.length) return [];
                const retrievalQuery = this.superBrainResolveQueryFromSession(query);
                const baseIntent = options.intent || this.detectQueryIntent(query);
                const intent = { ...baseIntent, broadCoverage: true };
                const corpusSize = this.allChunks.length;
                const targetTopK = topK ?? (corpusSize <= 80 ? FULL_SCAN_MIN_TOPK : Math.min(FULL_SCAN_MAX_TOPK, Math.ceil(corpusSize * 0.09)));

                const base = await original.call(this, retrievalQuery, Math.max(targetTopK, FULL_SCAN_MIN_TOPK), { ...options, intent });
                const anchors = this.getPerDocumentAnchors(retrievalQuery, intent);
                let merged = this.mergeUniqueChunks(base, anchors, Math.max(targetTopK * 2, 90));
                const bridges = this.expandImplicitLinks(merged, retrievalQuery, MAX_CONCEPT_EXPANSION);
                merged = this.mergeUniqueChunks(merged, bridges, Math.max(targetTopK * 3, 120));

                const refinement = await this.superBrainRunRetrievalRefinement(
                    retrievalQuery,
                    merged,
                    targetTopK,
                    options,
                    intent,
                    original
                );
                merged = refinement.chunks;

                let ranked = merged;
                if (this.shouldUseSemanticRerank(intent, merged, targetTopK)) {
                    const sem = await this.semanticRerank(retrievalQuery, merged, targetTopK, intent);
                    if (sem?.length) ranked = sem;
                } else {
                    ranked = merged.slice().sort((a, b) => (b.score || 0) - (a.score || 0));
                    ranked = this.diversifyResults(ranked, targetTopK);
                }

                // Guarantee broad document spread where possible.
                let out = [];
                const seenDocs = new Set();
                const desiredDocSpread = Math.min(this.documents.length, Math.max(1, Math.ceil(targetTopK * 0.7)));
                for (const chunk of ranked) {
                    if (out.length >= targetTopK) break;
                    if (seenDocs.size < desiredDocSpread && seenDocs.has(chunk.filename)) continue;
                    out.push(chunk);
                    seenDocs.add(chunk.filename);
                }
                if (out.length < targetTopK) {
                    for (const chunk of ranked) {
                        if (out.length >= targetTopK) break;
                        if (!out.some(x => x.id === chunk.id)) out.push(chunk);
                    }
                }

                out = this.superBrainDeepScanAugment(retrievalQuery, out, targetTopK);
                const broadQuestion = intent.broadCoverage || intent.comparative || intent.timeline ||
                    /\b(overall|across|entire|comprehensive|strategy|decision|recommend|trade-?off)\b/i.test(String(query || ''));
                const requiredDocs = broadQuestion
                    ? (this.documents.length >= 7 ? 3 : Math.min(this.documents.length, MIN_CROSS_SOURCE_DOCS))
                    : 1;
                const currentDocs = new Set(out.map(item => item.filename).filter(Boolean));
                if (broadQuestion && this.documents.length >= MIN_CROSS_SOURCE_DOCS && currentDocs.size < requiredDocs) {
                    const crossAnchors = this.getPerDocumentAnchors(`${retrievalQuery} cross-source corroboration`, intent);
                    for (const anchor of crossAnchors) {
                        if (out.length >= targetTopK) break;
                        if (!anchor?.id || out.some(item => item.id === anchor.id)) continue;
                        if (currentDocs.size < requiredDocs && currentDocs.has(anchor.filename)) continue;
                        out.push(anchor);
                        if (anchor.filename) currentDocs.add(anchor.filename);
                    }
                }

                this.lastActivationReport = this.buildActivationReport(query, out);
                this.lastActivationReport.retrievalPasses = refinement.passes || 1;
                this.lastActivationReport.retrievalStabilized = !!refinement.stabilized;
                this.lastActivationReport.requiredCrossSourceDocs = broadQuestion ? requiredDocs : 1;
                this.lastActivationReport.currentCrossSourceDocs = new Set(out.map(item => item.filename)).size;
                try {
                    this.lastFullCorpusSweep = this.buildFullCorpusDocumentSweep(query, {
                        perDocMaxChunks: FULL_CORPUS_DOC_ANCHORS_PER_DOC,
                        perDocTopRelevant: FULL_CORPUS_DOC_TOP_RELEVANT
                    });
                } catch {
                    this.lastFullCorpusSweep = null;
                }
                return out.slice(0, targetTopK);
            });

            patchMethod(CognitiveSynthesizer, 'buildInstructionProfile', (original) => function patchedBuildInstructionProfile(query) {
                const profile = original.call(this, query);
                const decisionMode = /\b(recommend|recommendation|decision|should|best approach|manage|strategy|trade-?off|pros|cons|options?|what should|how to handle|policy approach)\b/i.test(String(query || ''));
                return {
                    ...profile,
                    strictSourceOnly: true,
                    freshPassRequired: true,
                    requireUncertaintySection: true,
                    decisionMode
                };
            });

            patchMethod(CognitiveSynthesizer, 'getWorkingMemorySummary', () => function patchedWorkingMemorySummary() {
                const recent = Array.isArray(this.workingMemory) ? this.workingMemory.slice(-6) : [];
                if (!recent.length) {
                    return 'No prior conversational memory yet. Use this note only for dialogue continuity, not as factual evidence.';
                }
                const lines = recent.map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`);
                return [
                    'Conversation memory (continuity-only; not factual evidence):',
                    ...lines
                ].join('\n');
            });

            patchMethod(CognitiveSynthesizer, 'getSystemPrompt', (original) => function patchedSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
                const base = original.call(
                    this,
                    context,
                    corpusStats,
                    instructionProfile,
                    workingMemorySummary
                );
                const activation = corpusStats.activationReport || {};
                const conceptBridgeSummary = (activation.bridgeConcepts || []).slice(0, 8)
                    .map(x => `"${x.concept}" (${x.docs} docs)`)
                    .join(', ');
                const decisionRules = instructionProfile?.decisionMode ? [
                    '',
                    'DECISION-QUALITY MODE:',
                    '- Build a decision framework, not a summary.',
                    '- Include sections: Problem Framing, Evidence Synthesis, Options & Trade-offs, Recommendation, Risks, Uncertainties.',
                    '- For each option, provide source-grounded pros/cons with citations.'
                ].join('\n') : '';
                const superRules = [
                    'STRICT EVIDENCE-GROUNDED RAG POLICY (MANDATORY)',
                    '- Use only retrieved source evidence for this request.',
                    '- Do NOT use prior chat memory as evidence.',
                    '- Prior-turn memory is allowed only for conversational continuity (co-reference, follow-up scope, user preferences).',
                    '- Do not produce summary-only output; produce expert analysis, trade-offs, decisions, and actionable recommendations.',
                    '- Follow this cognitive loop: Interpret intent -> Retrieve corpus-wide semantically -> Build mental model -> Reason -> Refine if gaps remain.',
                    '- Deep scan policy: do not assume early document sections are sufficient; include mid/late evidence when relevant.',
                    '- Build and apply a mental model before answering:',
                    '  1) key entities + concepts',
                    '  2) cross-source relationships',
                    '  3) constraints + assumptions',
                    '  4) gaps + uncertainties',
                    '- Every factual statement must carry a citation in exact format:',
                    '  [Source: filename, page X, "brief relevant quote"]',
                    '- Include a final section titled: "Uncertainties & Missing Information".',
                    '',
                    'Cognition priors inspired by:',
                    '- Toyota Frontier Research (human-like event understanding): https://global.toyota/en/mobility/frontier-research/43225436.html',
                    '- Nature: https://www.nature.com/articles/s41586-025-09215-4',
                    '- Neural Networks: https://pure.eur.nl/files/154436763/1-s2.0-S0925231224007240-main.pdf',
                    ...BRAIN_INSPIRED_PRIOR.map(item => `- ${item}`),
                    '',
                    'FULL-CORPUS ACTIVATION REPORT:',
                    `- Activated docs: ${activation.activatedDocuments || 0}/${activation.totalDocuments || 0}`,
                    `- Activated chunks: ${activation.activatedChunks || 0}/${activation.totalChunks || 0}`,
                    `- Coverage: ${activation.activationCoveragePct || 0}%`,
                    `- Retrieval passes: ${activation.retrievalPasses || 1} (stabilized: ${activation.retrievalStabilized ? 'yes' : 'no'})`,
                    `- Bridge concepts: ${conceptBridgeSummary || 'N/A'}`
                ].join('\n') + decisionRules;

                const contradictionBlock = String(corpusStats.superBrainContradictionBlock || '').slice(0, CONTRADICTION_BLOCK_MAX_CHARS);

                return [
                    base,
                    superRules,
                    corpusStats.superBrainMentalModelBlock || '',
                    contradictionBlock,
                    corpusStats.fullCorpusMapSweepBlock || '',
                    corpusStats.fullCorpusReduceSweepBlock || ''
                ].filter(Boolean).join('\n\n');
            });

            patchMethod(CognitiveSynthesizer, 'synthesize', (original) => async function patchedSynthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
                const localStats = { ...(corpusStats || {}) };
                const requestProfile = typeof this.buildInstructionProfile === 'function'
                    ? this.buildInstructionProfile(query)
                    : {};
                if (!localStats.activationReport) {
                    const totalDocs = localStats.numDocs || new Set((relevantChunks || []).map(c => c.filename)).size;
                    const activatedDocs = new Set((relevantChunks || []).map(c => c.filename)).size;
                    localStats.activationReport = {
                        query,
                        totalDocuments: totalDocs,
                        totalChunks: localStats.numChunks || (relevantChunks || []).length,
                        activatedDocuments: activatedDocs,
                        activatedChunks: (relevantChunks || []).length,
                        activationCoveragePct: totalDocs ? Math.round((activatedDocs / totalDocs) * 100) : 100,
                        bridgeConcepts: (localStats.connectedConcepts || []).slice(0, 10).map(item => ({ concept: item.concept, docs: item.docCount }))
                    };
                }

                let fullCorpusSweep = localStats.fullCorpusSweep || null;
                if (!fullCorpusSweep) {
                    const appRetriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                    fullCorpusSweep = appRetriever?.lastFullCorpusSweep || null;
                }

                const refinement = await this.superBrainRunModelRefinementLoop(
                    query,
                    relevantChunks || [],
                    attachmentContext,
                    localStats,
                    requestProfile
                );
                const refinedChunks = Array.isArray(refinement?.chunks) && refinement.chunks.length
                    ? refinement.chunks
                    : (relevantChunks || []);
                localStats.superBrainRefinement = {
                    passes: refinement?.passes || 1,
                    stabilized: !!refinement?.stabilized
                };
                const appRetriever = (typeof window !== 'undefined' && window.app?.retriever) ? window.app.retriever : null;
                if (appRetriever?.lastActivationReport) {
                    localStats.activationReport = { ...appRetriever.lastActivationReport };
                }
                if (!fullCorpusSweep && appRetriever?.lastFullCorpusSweep) {
                    fullCorpusSweep = appRetriever.lastFullCorpusSweep;
                }
                if (fullCorpusSweep) {
                    localStats.fullCorpusSweep = fullCorpusSweep;
                    localStats.fullCorpusMapSweepBlock = this.superBrainBuildFullCorpusMapBlock(query, fullCorpusSweep);
                    localStats.fullCorpusReduceSweepBlock = this.superBrainBuildFullCorpusReduceBlock(fullCorpusSweep);
                }

                const flatSources = [
                    ...(attachmentContext?.chunks || []).map(c => ({ ...c, filename: attachmentContext?.name || c.filename || 'attachment' })),
                    ...refinedChunks,
                    ...((fullCorpusSweep?.docSweeps || []).flatMap(doc => doc.selectedChunks || []))
                ];
                const dedupedSources = uniqueBy(
                    flatSources,
                    item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                ).slice(0, MAX_MENTAL_MODEL_SOURCES * 3);

                localStats.superBrainContradictionBlock = this.superBrainBuildContradictionBlock(query, dedupedSources);
                const mentalModel = refinement?.model || await this.superBrainBuildMentalModel(query, dedupedSources, localStats.activationReport);
                localStats.superBrainMentalModel = mentalModel;
                localStats.superBrainMentalModelBlock = this.superBrainFormatModelBlock(mentalModel);
                localStats.superBrainPreSynthesisCompleteness = refinement?.completeness || null;

                // Keep conversational memory for human continuity while enforcing
                // strict source-only evidence for factual content.
                const result = await original.call(this, query, refinedChunks, attachmentContext, localStats);

                if (!result || typeof result.response !== 'string') return result;

                const sources = Array.isArray(result.sources) ? result.sources : [];
                const diagnosticSources = uniqueBy(
                    [...sources, ...((fullCorpusSweep?.docSweeps || []).flatMap(doc => doc.selectedChunks || []))],
                    item => item.id || `${item.filename}:${item.index || 0}:${item.page || 'na'}`
                );

                result.response = this.superBrainNormalizeCitationSyntax(result.response);
                const citationCount = this.countCitations(result.response);
                const needsUncertaintySection = !/uncertaint|missing information|evidence gap|cannot fully confirm/i.test(result.response);
                const malformedCitationSignals = this.superBrainHasMalformedCitationPatterns(result.response);
                const minCitationTarget = diagnosticSources.length >= 10 ? MIN_RICH_CORPUS_CITATIONS : (diagnosticSources.length >= 4 ? 2 : (diagnosticSources.length > 0 ? 1 : 0));
                const diagnostics = this.buildClaimCitationDiagnostics(result.response, diagnosticSources);
                const extraRepairNeeded = (
                    citationCount < minCitationTarget ||
                    needsUncertaintySection ||
                    diagnostics?.needsRepair ||
                    malformedCitationSignals
                );

                if (extraRepairNeeded) {
                    const snippet = this.formatContext(diagnosticSources || [], 12000).contextText;
                    const repairInstruction = [
                        'REPAIR REQUIREMENTS:',
                        '1) Maintain strict source grounding.',
                        '2) Increase claim-level citations where factual statements are made.',
                        '3) Structure output as:',
                        '   - Mental Model',
                        '   - Evidence-Based Expert Analysis',
                        '   - Uncertainties & Missing Information',
                        '4) Do not summarize only; provide reasoning, trade-offs, and recommended action when the question asks for decisions.',
                        '5) Use prior chat memory only for continuity; do not treat it as factual evidence or hidden knowledge.',
                        '6) Normalize all citations to exact format [Source: filename, page X, "brief relevant quote"].'
                    ].join('\n');
                    const repaired = await this.verifyAndRepairAnswer(
                        query,
                        `${result.response}\n\n${repairInstruction}`,
                        result.meta?.instructionProfile || this.buildInstructionProfile(query),
                        `## EVIDENCE\n${snippet}`,
                        diagnostics
                    );
                    if (repaired?.trim()) result.response = this.superBrainNormalizeCitationSyntax(repaired.trim());
                }

                const profileForChecks = result.meta?.instructionProfile || requestProfile;
                const completeness = this.superBrainAssessEvidenceCompleteness(
                    query,
                    diagnosticSources,
                    mentalModel,
                    localStats.activationReport || {},
                    profileForChecks
                );
                const severeGapRisk = Array.isArray(mentalModel?.gaps) && mentalModel.gaps.length >= MODEL_GAP_THRESHOLD;
                const shouldRequestMoreEvidence = completeness.needsMoreEvidence && (
                    diagnosticSources.length === 0 ||
                    completeness.docCount < completeness.requiredDocs ||
                    (severeGapRisk && completeness.docCount < Math.max(2, completeness.requiredDocs))
                );
                if (shouldRequestMoreEvidence) {
                    result.response = this.superBrainBuildMissingEvidenceResponse(
                        query,
                        completeness,
                        diagnosticSources,
                        mentalModel
                    );
                }

                result.meta = {
                    ...(result.meta || {}),
                    superBrain: {
                        patchVersion: PATCH_VERSION,
                        activationReport: localStats.activationReport,
                        mentalModel,
                        contradictionBlockIncluded: !!localStats.superBrainContradictionBlock,
                        fullCorpusSweepDocs: fullCorpusSweep?.totalDocuments || 0,
                        fullCorpusSweepAnchors: fullCorpusSweep?.totalSelectedChunks || 0,
                        refinement: localStats.superBrainRefinement,
                        evidenceCompleteness: completeness
                    }
                };
                return result;
            });

            if (typeof UIController === 'function') {
                patchMethod(UIController, 'setSynthesisMessage', () => function patchedSetSynthesisMessage() {
                    if (this?.synthesisIndicatorText) {
                        this.synthesisIndicatorText.textContent = 'Running full-corpus document-by-document map-reduce sweep, linking concepts, and building mental model...';
                    }
                });
            }

            try {
                console.log(`[Inline Super-Brain Enhancer] applied (${PATCH_VERSION})`);
            } catch {}
            return true;
        }

        function boot(attempt = 0) {
            const ok = tryInstall();
            if (ok) return;
            if (attempt > 120) {
                try { console.warn('[Inline Super-Brain Enhancer] classes not found; patch not applied.'); } catch {}
                return;
            }
            setTimeout(() => boot(attempt + 1), 50);
        }

        boot();
    })();
    </script>
</body>
</html>
