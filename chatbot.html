<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UofT Cognitive Synthesis Engine</title>
    <style>
        :root {
            --primary: #002A5C;
            --primary-light: #003d82;
            --secondary: #FFE498;
            --accent: #008BB0;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header h1 svg {
            width: 32px;
            height: 32px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .header-btn svg {
            width: 18px;
            height: 18px;
        }

        .brain-badge {
            background: var(--secondary);
            color: var(--primary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 1.5rem;
            gap: 1.5rem;
        }

        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-info h2 {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .chat-header-info p {
            font-size: 0.8rem;
            opacity: 0.85;
            margin-top: 0.25rem;
        }

        .chat-header-actions {
            display: flex;
            gap: 0.5rem;
        }

        .chat-action-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-action-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 400px;
            max-height: calc(100vh - 350px);
        }

        .message {
            max-width: 85%;
            padding: 1rem 1.25rem;
            border-radius: 12px;
            line-height: 1.6;
            font-size: 0.95rem;
        }

        .message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            align-self: flex-start;
            background: var(--bg);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .message.system {
            align-self: center;
            background: var(--secondary);
            color: var(--primary);
            font-size: 0.85rem;
            text-align: center;
            max-width: 100%;
        }

        .attachment-indicator {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            opacity: 0.9;
            padding: 0.25rem 0.5rem;
            background: rgba(255,255,255,0.15);
            border-radius: 4px;
            margin-bottom: 0.5rem;
            width: fit-content;
        }

        .attachment-indicator svg {
            flex-shrink: 0;
        }

        .citation {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: var(--accent);
            color: white;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0.15rem 0;
        }

        .citation:hover {
            background: var(--primary);
            transform: translateY(-1px);
        }

        .citation svg {
            width: 12px;
            height: 12px;
        }

        .chat-input-container {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            background: var(--bg);
        }

        .attachment-preview {
            display: none;
            padding: 0.75rem 1rem;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            align-items: center;
            gap: 0.75rem;
        }

        .attachment-preview.active {
            display: flex;
        }

        .attachment-preview-icon {
            width: 36px;
            height: 36px;
            background: var(--accent);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .attachment-preview-icon svg {
            width: 20px;
            height: 20px;
        }

        .attachment-preview-info {
            flex: 1;
        }

        .attachment-preview-name {
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text);
        }

        .attachment-preview-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .attachment-preview-remove {
            padding: 0.25rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .attachment-preview-remove:hover {
            background: #fee2e2;
            color: var(--error);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 0.75rem;
        }

        .attach-btn {
            padding: 0.875rem;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
        }

        .attach-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: white;
        }

        .attach-btn svg {
            width: 20px;
            height: 20px;
        }

        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            resize: none;
            font-family: inherit;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .send-btn {
            padding: 0.875rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--primary-light);
            transform: translateY(-1px);
        }

        .send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .corpus-sidebar {
            width: 320px;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .corpus-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }

        .corpus-header h3 {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .corpus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .corpus-stats span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .corpus-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
            max-height: 300px;
        }

        .corpus-item {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .corpus-item-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            overflow: hidden;
        }

        .corpus-item-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .corpus-item-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .corpus-item-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .corpus-item-delete:hover {
            color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .corpus-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .admin-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .admin-panel.active {
            display: flex;
        }

        .admin-content {
            background: var(--card);
            border-radius: 16px;
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        }

        .admin-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--primary);
            color: white;
        }

        .admin-header h2 {
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .admin-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .admin-close:hover {
            background: rgba(255,255,255,0.1);
        }

        .admin-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: var(--bg);
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(0, 139, 176, 0.05);
        }

        .upload-zone svg {
            width: 48px;
            height: 48px;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .upload-zone h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .upload-zone p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .upload-zone .file-types {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .api-section {
            margin-top: 1.5rem;
            padding: 1.25rem;
            background: var(--bg);
            border-radius: 8px;
        }

        .api-section h4 {
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .api-input-group {
            display: flex;
            gap: 0.75rem;
        }

        .api-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: monospace;
        }

        .api-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .api-save-btn {
            padding: 0.75rem 1.25rem;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .api-save-btn:hover {
            background: #059669;
        }

        .model-section {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 139, 176, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(0, 139, 176, 0.2);
        }

        .model-section h4 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }

        .model-select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }

        .model-note {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .admin-actions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .admin-action-btn {
            padding: 0.75rem 1.25rem;
            border: 1px solid var(--border);
            background: var(--card);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .admin-action-btn:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .admin-action-btn.danger {
            color: var(--error);
            border-color: var(--error);
        }

        .admin-action-btn.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .processing-status {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 139, 176, 0.1);
            border-radius: 8px;
            display: none;
        }

        .processing-status.active {
            display: block;
        }

        .processing-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.75rem;
        }

        .processing-bar-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .citation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .citation-modal.active {
            display: flex;
        }

        .citation-content {
            background: var(--card);
            border-radius: 12px;
            width: 100%;
            max-width: 600px;
            max-height: 70vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .citation-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--accent);
            color: white;
        }

        .citation-header h3 {
            font-size: 1rem;
        }

        .citation-body {
            padding: 1.25rem;
            overflow-y: auto;
        }

        .citation-source {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .citation-text {
            background: var(--bg);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.7;
            border-left: 3px solid var(--accent);
        }

        .toast-container {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 1002;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toast {
            padding: 1rem 1.25rem;
            background: var(--card);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
            max-width: 350px;
        }

        .toast.success { border-left: 4px solid var(--success); }
        .toast.error { border-left: 4px solid var(--error); }
        .toast.warning { border-left: 4px solid var(--warning); }
        .toast.info { border-left: 4px solid var(--accent); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }
            .corpus-sidebar {
                width: 100%;
            }
        }

        .keyboard-hint {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            background: var(--card);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .keyboard-hint kbd {
            background: var(--bg);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-family: monospace;
            border: 1px solid var(--border);
        }

        .synthesis-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 139, 176, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            color: var(--accent);
        }

        .synthesis-indicator.active {
            display: flex;
        }

        .synthesis-indicator .pulse {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .message.assistant p { margin-bottom: 0.6rem; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant ul, .message.assistant ol {
            margin: 0.4rem 0 0.7rem 1.3rem;
        }
        .message.assistant li { margin-bottom: 0.2rem; }
        .message.assistant strong { font-weight: 600; }
        .message.assistant em { font-style: italic; }
        .message.assistant code {
            background: rgba(0,0,0,0.05);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2a9 9 0 0 0-9 9c0 3.6 2.4 6.9 6 8.5V22h6v-2.5c3.6-1.6 6-4.9 6-8.5a9 9 0 0 0-9-9z"/>
                <path d="M12 6v6l4 2"/>
            </svg>
            UofT Cognitive Synthesis Engine
        </h1>
        <div class="header-actions">
            <span class="brain-badge">Brain-Aligned RAG</span>
            <button class="header-btn" id="openAdminBtn" title="Open Admin Panel (Ctrl+Shift+A)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
                Admin Panel
            </button>
        </div>
    </header>

    <div class="main-container">
        <section class="chat-section">
            <div class="chat-header">
                <div class="chat-header-info">
                    <h2>Knowledge Synthesis Interface</h2>
                    <p>Ask questions to synthesize insights across your document corpus</p>
                </div>
                <div class="chat-header-actions">
                    <button class="chat-action-btn" id="clearChatBtn" title="Clear Chat History">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3,6 5,6 21,6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    Welcome! This engine performs <strong>cognitive synthesis</strong> by combining broad coverage retrieval, concept links, and instruction-aware response formatting.
                    <br><br>
                    Click the <strong>Admin Panel</strong> button (or press Ctrl+Shift+A) to upload documents and configure your API key.
                    <br><br>
                    You can also attach files directly to your messages for one-time analysis (not saved to corpus).
                </div>
            </div>

            <div class="synthesis-indicator" id="synthesisIndicator">
                <div class="pulse"></div>
                <span id="synthesisIndicatorText">Building mental model and synthesizing across documents...</span>
            </div>

            <div class="chat-input-container">
                <div class="attachment-preview" id="attachmentPreview">
                    <div class="attachment-preview-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                            <polyline points="14,2 14,8 20,8"/>
                        </svg>
                    </div>
                    <div class="attachment-preview-info">
                        <div class="attachment-preview-name" id="attachmentName">document.pdf</div>
                        <div class="attachment-preview-meta" id="attachmentMeta">Temporary analysis - not saved to corpus</div>
                    </div>
                    <button class="attachment-preview-remove" id="attachmentRemove" title="Remove attachment">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
                <input type="file" id="chatFileInput" accept=".pdf,.docx,.txt,.csv,.xlsx,.md" style="display:none;">
                <div class="chat-input-wrapper">
                    <button class="attach-btn" id="chatAttachBtn" title="Attach file for analysis (not saved to corpus)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                        </svg>
                    </button>
                    <textarea
                        class="chat-input"
                        id="chatInput"
                        placeholder="Ask a question to synthesize knowledge from your documents..."
                        rows="2"
                    ></textarea>
                    <button class="send-btn" id="sendBtn">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                        </svg>
                        Send
                    </button>
                </div>
            </div>
        </section>

        <aside class="corpus-sidebar">
            <div class="corpus-header">
                <h3>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                    </svg>
                    Document Corpus
                </h3>
                <div class="corpus-stats">
                    <span id="docCount">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        </svg>
                        0 documents
                    </span>
                    <span id="chunkCount">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="7" height="7"/>
                            <rect x="14" y="3" width="7" height="7"/>
                            <rect x="3" y="14" width="7" height="7"/>
                            <rect x="14" y="14" width="7" height="7"/>
                        </svg>
                        0 knowledge chunks
                    </span>
                </div>
            </div>
            <div class="corpus-list" id="corpusList">
                <div class="corpus-empty">
                    No documents uploaded yet.<br>
                    Press <kbd>Ctrl+Shift+A</kbd> to open Admin Panel.
                </div>
            </div>
        </aside>
    </div>

    <div class="admin-panel" id="adminPanel">
        <div class="admin-content">
            <div class="admin-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    Admin Panel
                </h2>
                <button class="admin-close" id="adminClose">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>

            <div class="admin-body">
                <div class="api-section">
                    <h4>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/>
                        </svg>
                        OpenAI API Key
                    </h4>
                    <div class="api-input-group">
                        <input type="password" class="api-input" id="apiKeyInput" placeholder="sk-...">
                        <button class="api-save-btn" id="saveApiKey">Save Key</button>
                    </div>
                    <div class="model-section">
                        <h4>Model Selection</h4>
                        <select class="model-select" id="modelSelect">
                            <option value="gpt-4.1">GPT-4.1 (Best synthesis quality)</option>
                            <option value="gpt-4o">GPT-4o (Balanced)</option>
                            <option value="gpt-4o-mini">GPT-4o mini (Faster)</option>
                        </select>
                        <p class="model-note">For long-document synthesis, use GPT-4.1 or GPT-4o. The engine applies multi-stage retrieval + memory to improve brain-like integration.</p>
                    </div>
                </div>

                <div class="upload-zone" id="uploadZone">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17,8 12,3 7,8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <h3>Drag & Drop Documents</h3>
                    <p>Or click to select files for permanent corpus</p>
                    <div class="file-types">Supported: PDF, DOCX, XLSX, TXT, CSV, MD</div>
                    <input type="file" id="fileInput" multiple accept=".pdf,.docx,.xlsx,.txt,.csv,.md" style="display:none;">
                </div>

                <div class="processing-status" id="processingStatus">
                    <div id="processingText">Processing documents...</div>
                    <div class="processing-bar">
                        <div class="processing-bar-fill" id="processingBarFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="admin-actions">
                    <button class="admin-action-btn" id="rebuildIndex">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="23,4 23,10 17,10"/>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                        </svg>
                        Rebuild Index
                    </button>
                    <button class="admin-action-btn danger" id="clearCorpus">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3,6 5,6 21,6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                        Clear All Documents
                    </button>
                    <button class="admin-action-btn" id="clearChatAdmin">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            <line x1="9" y1="9" x2="15" y2="9"/>
                            <line x1="9" y1="13" x2="15" y2="13"/>
                        </svg>
                        Clear Chat History
                    </button>
                    <button class="admin-action-btn" id="runEvalHarness">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3v18h18"/>
                            <path d="M7 14l3-3 3 2 4-5"/>
                        </svg>
                        Run Eval Harness
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="citation-modal" id="citationModal">
        <div class="citation-content">
            <div class="citation-header">
                <h3>Source Citation</h3>
                <button class="admin-close" id="citationClose">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="citation-body">
                <div class="citation-source" id="citationSource"></div>
                <div class="citation-text" id="citationText"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <div class="keyboard-hint">
        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>A</kbd> Admin Panel
    </div>

    <script>
    const DB_NAME = 'CognitiveSynthesisDB';
    const DB_VERSION = 2;
    const STORE_NAME = 'documents';

    const LONG_DOC_WORD_THRESHOLD = 12000;
    const MAX_CONTEXT_CHARS = 90000;
    const RETRIEVAL_LOW_SCORE_THRESHOLD = 0.18;
    const MULTIPASS_CHUNK_THRESHOLD = 16;
    const MULTIPASS_CONTEXT_CHAR_THRESHOLD = 70000;
    const MAP_PASS_CONTEXT_BUDGET = 15000;
    const MAX_MAP_PASSES = 7;
    const EMBEDDING_MODEL = 'text-embedding-3-small';
    const EMBEDDING_RERANK_CANDIDATE_LIMIT = 160;
    const EMBEDDING_BATCH_SIZE = 24;
    const CLAIM_CITATION_TARGET = 0.55;
    const CLAIM_SUPPORT_TARGET = 0.45;
    const CITATION_PRECISION_TARGET = 0.5;
    const COMPLETION_TIMEOUT_MS = 45000;
    const EMBEDDING_TIMEOUT_MS = 25000;
    const COMPLETION_MAX_RETRIES = 3;
    const EMBEDDING_MAX_RETRIES = 2;
    const RETRY_BASE_DELAY_MS = 600;
    const EMBEDDING_DISABLE_WINDOW_MS = 5 * 60 * 1000;
    const REFUSAL_PATTERNS = [
        /cannot\s+(?:directly\s+)?access/i,
        /outside of (?:the )?provided excerpts/i,
        /training cut[- ]?off/i,
        /cannot review documents outside/i,
        /i do not have access to your document/i
    ];

    function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function computeRetryDelay(attempt, baseMs = RETRY_BASE_DELAY_MS) {
        const expo = Math.pow(2, Math.max(0, attempt));
        const jitter = Math.floor(Math.random() * 250);
        return (baseMs * expo) + jitter;
    }

    function isTransientStatus(status) {
        return status === 408 || status === 409 || status === 425 || status === 429 || status >= 500;
    }

    function buildHttpError(message, status = null, isTransient = false) {
        const error = new Error(message);
        error.status = status;
        error.isTransient = isTransient;
        return error;
    }

    async function fetchJsonWithRetry(url, fetchOptions, retryOptions = {}) {
        const timeoutMs = retryOptions.timeoutMs ?? COMPLETION_TIMEOUT_MS;
        const maxRetries = retryOptions.maxRetries ?? COMPLETION_MAX_RETRIES;
        const baseDelayMs = retryOptions.baseDelayMs ?? RETRY_BASE_DELAY_MS;

        let lastError = null;

        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const response = await fetch(url, {
                    ...fetchOptions,
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) {
                    let detail = `Request failed (HTTP ${response.status})`;
                    try {
                        const payload = await response.json();
                        detail = payload.error?.message || detail;
                    } catch {
                        // Keep default detail if body isn't JSON.
                    }

                    const transient = isTransientStatus(response.status);
                    lastError = buildHttpError(detail, response.status, transient);

                    if (transient && attempt < maxRetries) {
                        await wait(computeRetryDelay(attempt, baseDelayMs));
                        continue;
                    }
                    throw lastError;
                }

                const data = await response.json();
                return { data, status: response.status };
            } catch (error) {
                clearTimeout(timeout);
                const isAbort = error?.name === 'AbortError';
                const transient = isAbort || error?.isTransient === true || error instanceof TypeError;
                lastError = buildHttpError(
                    isAbort ? `Request timed out after ${timeoutMs}ms` : (error?.message || 'Network request failed'),
                    error?.status ?? null,
                    transient
                );

                if (transient && attempt < maxRetries) {
                    await wait(computeRetryDelay(attempt, baseDelayMs));
                    continue;
                }
                throw lastError;
            }
        }

        throw lastError || buildHttpError('Request failed after retries', null, false);
    }

    function simpleHash(input) {
        const text = String(input || '');
        let hash = 2166136261;
        for (let i = 0; i < text.length; i++) {
            hash ^= text.charCodeAt(i);
            hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
        }
        return (hash >>> 0).toString(16);
    }

    class DocumentDatabase {
        constructor() {
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    this.db = request.result;
                    resolve(this.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('filename', 'filename', { unique: false });
                        store.createIndex('type', 'type', { unique: false });
                    }
                };
            });
        }

        async addDocument(doc) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.add(doc);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getAllDocuments() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async deleteDocument(id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async clearAll() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }

    class DocumentProcessor {
        constructor() {
            this.stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                'this', 'that', 'these', 'those', 'what', 'which', 'who', 'when',
                'where', 'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more',
                'most', 'other', 'some', 'such', 'than', 'too', 'very', 'just', 'also',
                'into', 'about', 'over', 'under', 'through', 'across'
            ]);

            this.unsupportedLegacyExtensions = new Set(['doc', 'xls']);
            this.supportedExtensions = new Set(['pdf', 'docx', 'xlsx', 'txt', 'csv', 'md']);

            this.mimeProcessors = {
                'application/pdf': this.processPDF.bind(this),
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': this.processDOCX.bind(this),
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': this.processXLSX.bind(this),
                'text/plain': this.processText.bind(this),
                'text/csv': this.processCSV.bind(this),
                'text/markdown': this.processText.bind(this)
            };

            this.extensionProcessors = {
                'pdf': this.processPDF.bind(this),
                'docx': this.processDOCX.bind(this),
                'xlsx': this.processXLSX.bind(this),
                'txt': this.processText.bind(this),
                'csv': this.processCSV.bind(this),
                'md': this.processText.bind(this)
            };
        }

        getExtension(filename = '') {
            const parts = filename.split('.');
            if (parts.length < 2) return '';
            return parts.pop().toLowerCase();
        }

        resolveProcessor(file, extension) {
            return this.extensionProcessors[extension] || this.mimeProcessors[file.type] || this.processText.bind(this);
        }

        normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\u0000/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/[^\S\n]+/g, ' ')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
        }

        splitIntoSentences(text) {
            return text
                .split(/(?<=[.!?])\s+(?=[A-Z0-9"“'`])/)
                .map(s => s.trim())
                .filter(Boolean);
        }

        tokenizeForMemory(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.stopWords.has(token));
        }

        extractHeadings(text) {
            const lines = text.split('\n');
            const headings = [];

            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line || line.length > 120) continue;
                if (/^\[Page\s+\d+\]$/i.test(line)) {
                    headings.push(line);
                    continue;
                }

                const markdownHeading = /^#{1,6}\s+(.+)$/;
                const numberedHeading = /^\d+(\.\d+){0,3}\s+[A-Z]/;
                const titleCaseHeading = /^[A-Z][A-Za-z0-9\s,:;()/-]{4,}$/;

                if (markdownHeading.test(line) || numberedHeading.test(line) || titleCaseHeading.test(line)) {
                    if (!/[.!?]$/.test(line)) {
                        headings.push(line.replace(/^#{1,6}\s*/, ''));
                    }
                }
            }

            return Array.from(new Set(headings)).slice(0, 24);
        }

        isLikelyHeading(line) {
            if (!line) return false;
            if (line.length < 4 || line.length > 120) return false;
            if (/^[\[\](){}]/.test(line)) return false;
            if (/[.!?]$/.test(line)) return false;
            if (/^[-*•]/.test(line)) return false;
            if (/^\d+$/.test(line)) return false;
            return (
                /^#{1,6}\s+/.test(line) ||
                /^\d+(\.\d+){0,3}\s+[A-Z]/.test(line) ||
                /^[A-Z][A-Za-z0-9\s,:;()/-]+$/.test(line)
            );
        }

        splitLargeParagraph(paragraph, maxChars = 1500) {
            const cleaned = paragraph.trim();
            if (!cleaned) return [];
            if (cleaned.length <= maxChars) return [cleaned];

            const sentences = this.splitIntoSentences(cleaned);
            if (sentences.length <= 1) {
                const chunks = [];
                for (let i = 0; i < cleaned.length; i += maxChars) {
                    chunks.push(cleaned.slice(i, i + maxChars));
                }
                return chunks;
            }

            const result = [];
            let current = '';

            for (const sentence of sentences) {
                const candidate = current ? `${current} ${sentence}` : sentence;
                if (candidate.length > maxChars && current) {
                    result.push(current.trim());
                    current = sentence;
                } else if (sentence.length > maxChars) {
                    const hardSplit = this.splitLargeParagraph(sentence, maxChars);
                    if (current) {
                        result.push(current.trim());
                        current = '';
                    }
                    result.push(...hardSplit);
                } else {
                    current = candidate;
                }
            }

            if (current.trim()) result.push(current.trim());
            return result;
        }

        getOverlapTail(text, overlapChars = 260) {
            if (!text || text.length <= overlapChars) return text;
            const tail = text.slice(-overlapChars);
            const boundary = tail.search(/[.!?]\s+[A-Z]/);
            if (boundary > 0) {
                return tail.slice(boundary + 2).trim();
            }
            return tail.trim();
        }

        splitIntoSections(text) {
            const sections = [];
            const lines = text.split('\n');
            let currentTitle = 'Document';
            let currentPage = null;
            let buffer = [];

            const flush = () => {
                const content = buffer.join('\n').trim();
                if (content) {
                    sections.push({
                        title: currentTitle,
                        page: currentPage,
                        content
                    });
                }
                buffer = [];
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                const pageMatch = line.match(/^\[Page\s+(\d+)\]$/i);
                if (pageMatch) {
                    flush();
                    currentPage = parseInt(pageMatch[1], 10);
                    currentTitle = `Page ${currentPage}`;
                    continue;
                }

                if (this.isLikelyHeading(line) && buffer.join('\n').length > 700) {
                    flush();
                    currentTitle = line.replace(/^#{1,6}\s*/, '');
                    continue;
                }

                buffer.push(rawLine);
            }

            flush();
            return sections.length ? sections : [{ title: 'Document', page: null, content: text }];
        }

        extractPageFromText(text) {
            const match = text.match(/\[Page\s+(\d+)\]/i);
            return match ? parseInt(match[1], 10) : null;
        }

        scoreSentence(sentence, conceptSet) {
            const words = sentence.toLowerCase().match(/\b[a-z][a-z0-9-]+\b/g) || [];
            let score = 0;

            for (const word of words) {
                if (conceptSet.has(word)) score += 1;
            }

            if (/\d/.test(sentence)) score += 0.7;
            if (/[A-Z][a-z]+ [A-Z][a-z]+/.test(sentence)) score += 0.6;
            if (sentence.length >= 60 && sentence.length <= 260) score += 0.5;
            return score;
        }

        buildDocumentMemory(text, chunks, filename) {
            const words = text.split(/\s+/).filter(Boolean);
            const wordCount = words.length;
            const readingTimeMinutes = Math.max(1, Math.round(wordCount / 220));

            const headings = this.extractHeadings(text);
            const tokens = this.tokenizeForMemory(text);
            const frequencies = new Map();
            for (const token of tokens) {
                frequencies.set(token, (frequencies.get(token) || 0) + 1);
            }

            const keyConcepts = Array.from(frequencies.entries())
                .filter(([, count]) => count > 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 18)
                .map(([token]) => token);

            const conceptSet = new Set(keyConcepts);
            const sentences = this.splitIntoSentences(text)
                .filter(sentence => sentence.length >= 35 && sentence.length <= 320);
            const everyNth = Math.max(1, Math.floor(sentences.length / 14));
            const scored = sentences.map((sentence, idx) => ({
                sentence,
                score: this.scoreSentence(sentence, conceptSet) + ((idx % everyNth === 0) ? 0.3 : 0)
            }));

            const salientSentences = scored
                .sort((a, b) => b.score - a.score)
                .slice(0, 14)
                .map(item => item.sentence.trim());

            const synopsis = salientSentences.slice(0, 6).join(' ').trim();

            return {
                filename,
                wordCount,
                chunkCount: chunks.length,
                readingTimeMinutes,
                outline: headings,
                keyConcepts,
                salientSentences,
                synopsis
            };
        }

        intelligentChunk(text, filename, baseChunkSize = 1800, overlap = 260) {
            const cleaned = this.normalizeText(text);
            if (!cleaned) return [];

            const dynamicChunkSize = cleaned.length > 350000 ? 2400 :
                cleaned.length > 150000 ? 2100 :
                cleaned.length > 50000 ? 1900 : baseChunkSize;

            const sections = this.splitIntoSections(cleaned);
            const chunks = [];
            let chunkIndex = 0;

            for (const section of sections) {
                const paragraphs = section.content
                    .split(/\n{2,}/)
                    .map(p => p.trim())
                    .filter(Boolean);

                let current = section.title ? `${section.title}\n` : '';
                let currentPage = section.page || null;

                const pushChunk = () => {
                    const chunkText = current.trim();
                    if (!chunkText) return;
                    chunks.push({
                        id: `${filename}-chunk-${chunkIndex}`,
                        text: chunkText,
                        filename,
                        section: section.title || 'Document',
                        page: currentPage || this.extractPageFromText(chunkText),
                        index: chunkIndex,
                        preview: chunkText.replace(/\s+/g, ' ').slice(0, 120) + (chunkText.length > 120 ? '...' : '')
                    });
                    chunkIndex++;
                };

                for (const paragraph of paragraphs) {
                    const pageInParagraph = paragraph.match(/\[Page\s+(\d+)\]/i);
                    if (pageInParagraph) {
                        currentPage = parseInt(pageInParagraph[1], 10);
                    }

                    const units = this.splitLargeParagraph(paragraph, Math.floor(dynamicChunkSize * 0.9));
                    for (const unit of units) {
                        const candidate = current ? `${current}\n\n${unit}` : unit;
                        if (candidate.length > dynamicChunkSize && current.trim()) {
                            pushChunk();
                            const overlapText = this.getOverlapTail(current, overlap);
                            current = overlapText ? `${overlapText}\n\n${unit}` : unit;
                        } else if (candidate.length > dynamicChunkSize && !current.trim()) {
                            const hardUnits = this.splitLargeParagraph(unit, Math.floor(dynamicChunkSize * 0.8));
                            for (const hardUnit of hardUnits) {
                                current = hardUnit;
                                pushChunk();
                                current = '';
                            }
                        } else {
                            current = candidate;
                        }
                    }
                }

                if (current.trim()) {
                    pushChunk();
                }
            }

            return chunks;
        }

        async processFile(file) {
            const extension = this.getExtension(file.name);
            if (this.unsupportedLegacyExtensions.has(extension)) {
                throw new Error(`Legacy ${extension.toUpperCase()} is not supported in-browser. Convert to DOCX or XLSX first.`);
            }

            if (!this.supportedExtensions.has(extension)) {
                throw new Error(`Unsupported file type: .${extension || 'unknown'}`);
            }

            const processor = this.resolveProcessor(file, extension);
            const extracted = await processor(file);
            const text = this.normalizeText(extracted);

            if (!text || text.length < 20) {
                throw new Error(`Could not extract readable text from ${file.name}.`);
            }

            const chunks = this.intelligentChunk(text, file.name);
            const memory = this.buildDocumentMemory(text, chunks, file.name);

            return {
                filename: file.name,
                type: file.type || extension,
                extension,
                size: file.size,
                uploadedAt: new Date().toISOString(),
                fullText: text,
                chunks,
                memory
            };
        }

        async processText(file) {
            return await file.text();
        }

        async processCSV(file) {
            const text = await file.text();
            const lines = text.split('\n');
            let formatted = `CSV Data from ${file.name}:\n\n`;

            if (lines.length > 0) {
                const headers = lines[0].split(',').map(h => h.trim());
                formatted += `Columns: ${headers.join(', ')}\n\n`;

                for (let i = 1; i < Math.min(lines.length, 300); i++) {
                    const values = lines[i].split(',');
                    if (!values.some(value => value.trim())) continue;
                    formatted += `Row ${i}: `;
                    headers.forEach((header, idx) => {
                        if (values[idx] && values[idx].trim()) {
                            formatted += `${header}: ${values[idx].trim()}; `;
                        }
                    });
                    formatted += '\n';
                }
            }

            return formatted;
        }

        async processPDF(file) {
            if (typeof pdfjsLib === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js');
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += `[Page ${i}]\n${pageText}\n\n`;
            }

            return fullText;
        }

        async processDOCX(file) {
            if (typeof mammoth === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js');
            }

            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        async processXLSX(file) {
            if (typeof XLSX === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
            }

            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            let fullText = '';

            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                fullText += `[Sheet: ${sheetName}]\n`;
                jsonData.forEach((row, rowIndex) => {
                    if (row.length > 0) {
                        fullText += `Row ${rowIndex + 1}: ${row.join(' | ')}\n`;
                    }
                });
                fullText += '\n';
            });

            return fullText;
        }

        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    }

    class CognitiveRetriever {
        constructor() {
            this.documents = [];
            this.allChunks = [];
            this.idf = new Map();
            this.avgChunkLength = 1;
            this.chunkTokenCache = new Map();
            this.chunkLookup = new Map();
            this.conceptIndex = new Map();
            this.documentConceptMap = new Map();
            this.embeddingApiKey = localStorage.getItem('openai_api_key') || '';
            this.embeddingModel = EMBEDDING_MODEL;
            this.chunkEmbeddingCache = new Map();
            this.queryEmbeddingCache = new Map();
            this.chunkEmbeddingTextCache = new Map();
            this.embeddingInFlight = new Map();
            this.embeddingEnabled = true;
            this.lastEmbeddingError = '';
            this.embeddingFailureCount = 0;
            this.embeddingDisabledUntil = 0;
        }

        setEmbeddingApiKey(apiKey) {
            this.embeddingApiKey = apiKey || '';
            this.embeddingFailureCount = 0;
            this.embeddingDisabledUntil = 0;
        }

        normalizeEmbeddingText(text, maxChars = 2200) {
            return String(text || '')
                .replace(/\s+/g, ' ')
                .trim()
                .slice(0, maxChars);
        }

        prepareChunkEmbeddingText(chunk) {
            const header = `${chunk.filename || 'document'} ${chunk.section || ''} ${chunk.page ? `page ${chunk.page}` : ''}`;
            const body = this.normalizeEmbeddingText(chunk.text || '');
            return `${header}\n${body}`.trim();
        }

        cosineSimilarity(vecA, vecB) {
            if (!Array.isArray(vecA) || !Array.isArray(vecB) || vecA.length !== vecB.length || vecA.length === 0) {
                return 0;
            }
            let dot = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                const a = vecA[i];
                const b = vecB[i];
                dot += a * b;
                normA += a * a;
                normB += b * b;
            }
            if (normA === 0 || normB === 0) return 0;
            return dot / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        async embedTextBatch(texts) {
            if (!this.embeddingApiKey || !this.embeddingEnabled) return null;
            if (this.embeddingDisabledUntil && Date.now() < this.embeddingDisabledUntil) {
                return null;
            }

            const { data } = await fetchJsonWithRetry(
                'https://api.openai.com/v1/embeddings',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.embeddingApiKey}`
                    },
                    body: JSON.stringify({
                        model: this.embeddingModel,
                        input: texts
                    })
                },
                {
                    timeoutMs: EMBEDDING_TIMEOUT_MS,
                    maxRetries: EMBEDDING_MAX_RETRIES
                }
            );

            this.embeddingFailureCount = 0;
            return data.data.map(item => item.embedding);
        }

        handleEmbeddingFailure(error) {
            this.lastEmbeddingError = error?.message || 'Embedding request failed';
            this.embeddingFailureCount += 1;
            if (this.embeddingFailureCount >= 3) {
                this.embeddingDisabledUntil = Date.now() + EMBEDDING_DISABLE_WINDOW_MS;
            }
        }

        async getQueryEmbedding(query) {
            if (!this.embeddingApiKey || !this.embeddingEnabled) return null;
            const normalizedQuery = this.normalizeEmbeddingText(query, 1000).toLowerCase();
            if (!normalizedQuery) return null;
            if (this.queryEmbeddingCache.has(normalizedQuery)) {
                return this.queryEmbeddingCache.get(normalizedQuery);
            }

            try {
                const vectors = await this.embedTextBatch([normalizedQuery]);
                const vector = vectors?.[0] || null;
                if (vector) {
                    this.queryEmbeddingCache.set(normalizedQuery, vector);
                }
                return vector;
            } catch (error) {
                this.handleEmbeddingFailure(error);
                return null;
            }
        }

        async ensureEmbeddingsForChunks(chunks) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !chunks?.length) return;
            const uniqueChunks = [];
            const seen = new Set();
            for (const chunk of chunks) {
                if (!chunk?.id || seen.has(chunk.id)) continue;
                seen.add(chunk.id);
                uniqueChunks.push(chunk);
            }

            const missing = uniqueChunks.filter(chunk => !this.chunkEmbeddingCache.has(chunk.id));
            if (missing.length === 0) return;

            for (let i = 0; i < missing.length; i += EMBEDDING_BATCH_SIZE) {
                const batch = missing.slice(i, i + EMBEDDING_BATCH_SIZE);
                const batchTexts = batch.map(chunk => {
                    const text = this.prepareChunkEmbeddingText(chunk);
                    this.chunkEmbeddingTextCache.set(chunk.id, text);
                    return text;
                });

                try {
                    const vectors = await this.embedTextBatch(batchTexts);
                    if (!Array.isArray(vectors)) {
                        return;
                    }
                    vectors.forEach((vector, idx) => {
                        const chunkId = batch[idx].id;
                        if (chunkId && vector) {
                            this.chunkEmbeddingCache.set(chunkId, vector);
                        }
                    });
                } catch (error) {
                    this.handleEmbeddingFailure(error);
                    return;
                }
            }
        }

        async semanticRerank(query, candidates, topK, intent = {}) {
            if (!this.embeddingApiKey || !this.embeddingEnabled || !candidates?.length) return null;
            const limited = candidates.slice(0, EMBEDDING_RERANK_CANDIDATE_LIMIT);
            const queryVector = await this.getQueryEmbedding(query);
            if (!queryVector) return null;

            await this.ensureEmbeddingsForChunks(limited);

            const reranked = limited.map(chunk => {
                const embedding = this.chunkEmbeddingCache.get(chunk.id);
                const semanticScore = embedding ? this.cosineSimilarity(queryVector, embedding) : 0;
                const lexicalScore = chunk.score || 0;
                let hybridScore = (lexicalScore * 0.62) + (semanticScore * 0.38);
                if (intent.broadCoverage) hybridScore += semanticScore * 0.05;
                return {
                    ...chunk,
                    lexicalScore,
                    semanticScore,
                    score: hybridScore
                };
            }).sort((a, b) => b.score - a.score);

            return this.diversifyResults(reranked, topK);
        }

        shouldUseSemanticRerank(intent = {}, candidates = [], topK = 10) {
            if (!this.embeddingEnabled || !this.embeddingApiKey) return false;
            if (!Array.isArray(candidates) || candidates.length < Math.max(topK * 2, 18)) return false;
            if (intent.broadCoverage || intent.comparative || intent.timeline) return true;
            return this.allChunks.length > 30;
        }

        updateCorpus(documents) {
            this.documents = documents.map(doc => {
                if (doc.memory) return doc;
                return {
                    ...doc,
                    memory: this.deriveMemoryFromChunks(doc)
                };
            });

            this.allChunks = this.documents.flatMap(doc => doc.chunks || []);
            this.chunkLookup = new Map(this.allChunks.map(chunk => [chunk.id, chunk]));
            this.chunkEmbeddingCache.clear();
            this.chunkEmbeddingTextCache.clear();
            this.buildTokenStats();
            this.buildConceptIndex();
        }

        deriveMemoryFromChunks(doc) {
            const chunks = doc.chunks || [];
            const previews = chunks.slice(0, 8).map(chunk => chunk.preview || chunk.text.slice(0, 120));
            const synopsis = previews.join(' ');
            return {
                filename: doc.filename,
                wordCount: Math.max(0, Math.round((doc.fullText || '').split(/\s+/).filter(Boolean).length)),
                chunkCount: chunks.length,
                readingTimeMinutes: Math.max(1, Math.round(((doc.fullText || '').split(/\s+/).length || 0) / 220)),
                outline: [],
                keyConcepts: this.extractConcepts((doc.fullText || '').slice(0, 4000)).slice(0, 10),
                salientSentences: previews,
                synopsis
            };
        }

        buildTokenStats() {
            this.idf.clear();
            this.chunkTokenCache.clear();

            if (this.allChunks.length === 0) {
                this.avgChunkLength = 1;
                return;
            }

            const df = new Map();
            let totalLength = 0;

            for (const chunk of this.allChunks) {
                const tokens = this.tokenize(chunk.text);
                const tf = new Map();
                for (const token of tokens) {
                    tf.set(token, (tf.get(token) || 0) + 1);
                }
                this.chunkTokenCache.set(chunk.id, {
                    tokens,
                    tf,
                    length: tokens.length || 1
                });
                totalLength += tokens.length;

                const uniqueTokens = new Set(tokens);
                for (const token of uniqueTokens) {
                    df.set(token, (df.get(token) || 0) + 1);
                }
            }

            this.avgChunkLength = totalLength / Math.max(1, this.allChunks.length);
            const N = this.allChunks.length;

            for (const [token, count] of df.entries()) {
                const idf = Math.log(((N - count + 0.5) / (count + 0.5)) + 1);
                this.idf.set(token, idf);
            }
        }

        buildConceptIndex() {
            this.conceptIndex.clear();
            this.documentConceptMap.clear();

            for (const doc of this.documents) {
                const docConcepts = new Set();
                for (const chunk of (doc.chunks || [])) {
                    const concepts = this.extractKeyConceptsFromChunk(chunk.text);
                    for (const concept of concepts) {
                        docConcepts.add(concept);
                        if (!this.conceptIndex.has(concept)) {
                            this.conceptIndex.set(concept, []);
                        }
                        this.conceptIndex.get(concept).push({
                            docId: doc.id,
                            filename: doc.filename,
                            chunkId: chunk.id
                        });
                    }
                }
                this.documentConceptMap.set(doc.filename, docConcepts);
            }
        }

        detectQueryIntent(query) {
            const q = query.toLowerCase();
            return {
                broadCoverage: /\b(whole|entire|full|overall|comprehensive|big picture|summari[sz]e|main themes|analyze.*document|review.*document)\b/.test(q),
                comparative: /\b(compare|contrast|versus|vs\.?)\b/.test(q),
                extraction: /\b(list|extract|enumerate|all instances|find all)\b/.test(q),
                timeline: /\b(timeline|chronological|over time|sequence)\b/.test(q)
            };
        }

        splitIntoSubQueries(query) {
            const compact = query
                .replace(/\s+/g, ' ')
                .trim();

            const pieces = compact
                .split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|along with)\b\s+)/i)
                .map(piece => piece.trim())
                .filter(piece => piece.length >= 12);

            return Array.from(new Set(pieces)).slice(0, 6);
        }

        extractQueryPhrases(query) {
            const phrases = query
                .toLowerCase()
                .match(/\b[a-z0-9][a-z0-9-]{2,}(?:\s+[a-z0-9][a-z0-9-]{2,}){1,2}\b/g) || [];

            return Array.from(new Set(phrases))
                .filter(phrase => {
                    const words = phrase.split(/\s+/);
                    return words.some(word => !this.isStopWord(word));
                })
                .slice(0, 10);
        }

        generateQueryVariants(query, intent = {}) {
            const variants = [query.trim()];
            const subQueries = this.splitIntoSubQueries(query);
            variants.push(...subQueries.slice(0, 3));

            const phrases = this.extractQueryPhrases(query).slice(0, 3);
            variants.push(...phrases);

            if (intent.broadCoverage) {
                variants.push(`${query} key themes and overall synthesis`);
            }
            if (intent.timeline) {
                variants.push(`${query} timeline chronology milestones`);
            }
            if (intent.comparative) {
                variants.push(`${query} differences similarities trade-offs`);
            }

            return Array.from(new Set(variants.map(v => v.trim()).filter(Boolean))).slice(0, 7);
        }

        calculateQueryVariantScore(chunk, query, queryTokens, queryEntities, queryConcepts, weight = 1) {
            const score = this.calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts);
            return score * weight;
        }

        tokenize(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.isStopWord(token));
        }

        isStopWord(word) {
            const stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'this', 'that',
                'these', 'those', 'what', 'which', 'who', 'whom', 'whose', 'when', 'where',
                'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more', 'most', 'other',
                'some', 'such', 'than', 'too', 'very', 'just', 'also', 'into', 'about'
            ]);
            return stopWords.has(word);
        }

        extractEntities(text) {
            const entities = [];
            const capitalizedWords = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
            entities.push(...capitalizedWords.map(e => e.toLowerCase()));
            const numbers = text.match(/\d+(?:\.\d+)?%?/g) || [];
            entities.push(...numbers);
            const dates = text.match(/\d{4}|\d{1,2}\/\d{1,2}\/\d{2,4}/g) || [];
            entities.push(...dates);
            return entities;
        }

        extractConcepts(text) {
            const concepts = [];
            const phrases = text.match(/\b\w+\s+\w+(?:\s+\w+)?\b/g) || [];
            concepts.push(...phrases.map(p => p.toLowerCase()));
            return concepts;
        }

        extractKeyConceptsFromChunk(text) {
            const concepts = new Set();
            const properNouns = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
            properNouns.forEach(p => concepts.add(p.toLowerCase()));
            const technical = text.match(/\b[a-z]+[-_]?[a-z]*\d+[a-z]*\b/gi) || [];
            technical.forEach(t => concepts.add(t.toLowerCase()));
            const quoted = text.match(/"([^"]+)"/g) || [];
            quoted.forEach(q => concepts.add(q.replace(/"/g, '').toLowerCase()));
            return concepts;
        }

        calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts) {
            const cache = this.chunkTokenCache.get(chunk.id) || {
                tokens: this.tokenize(chunk.text),
                tf: new Map(),
                length: 1
            };

            if (cache.tf.size === 0) {
                for (const token of cache.tokens) {
                    cache.tf.set(token, (cache.tf.get(token) || 0) + 1);
                }
            }

            const uniqueQueryTokens = Array.from(new Set(queryTokens));
            const chunkTextLower = chunk.text.toLowerCase();
            const queryTextLower = query.toLowerCase().trim();

            let score = 0;

            if (uniqueQueryTokens.length > 0) {
                const k1 = 1.2;
                const b = 0.75;
                let bm25 = 0;
                let maxIdf = 0;
                for (const token of uniqueQueryTokens) {
                    const tf = cache.tf.get(token) || 0;
                    const idf = this.idf.get(token) || 0.4;
                    maxIdf += idf;
                    if (tf === 0) continue;
                    const numerator = tf * (k1 + 1);
                    const denominator = tf + k1 * (1 - b + b * (cache.length / this.avgChunkLength));
                    bm25 += idf * (numerator / denominator);
                }
                if (maxIdf > 0) {
                    score += (bm25 / maxIdf) * 0.55;
                }
            }

            if (queryTextLower.length > 12 && chunkTextLower.includes(queryTextLower)) {
                score += 0.2;
            }

            if (queryEntities.length > 0) {
                const entityMatches = queryEntities.filter(entity => chunkTextLower.includes(entity.toLowerCase())).length;
                score += (entityMatches / queryEntities.length) * 0.15;
            }

            if (queryConcepts.length > 0) {
                const conceptMatches = queryConcepts.filter(concept => chunkTextLower.includes(concept)).length;
                score += (conceptMatches / queryConcepts.length) * 0.08;
            }

            const tokenMatches = uniqueQueryTokens.filter(token => cache.tf.has(token)).length;
            const density = tokenMatches / Math.max(1, cache.length / 100);
            score += Math.min(density * 0.04, 0.06);

            return score;
        }

        pickEvenlyDistributed(chunks, count) {
            if (!chunks || chunks.length === 0 || count <= 0) return [];
            if (chunks.length <= count) return chunks.slice();

            const selected = [];
            for (let i = 0; i < count; i++) {
                const index = Math.floor((i * (chunks.length - 1)) / Math.max(1, count - 1));
                selected.push(chunks[index]);
            }
            return selected;
        }

        mergeUniqueChunks(primary, additions, limit) {
            const result = [];
            const seen = new Set();

            for (const chunk of [...primary, ...additions]) {
                if (!chunk || seen.has(chunk.id)) continue;
                result.push(chunk);
                seen.add(chunk.id);
                if (result.length >= limit) break;
            }

            return result;
        }

        diversifyResults(scoredChunks, topK) {
            const results = [];
            const seenDocuments = new Map();
            const maxPerDocument = Math.max(2, Math.ceil(topK / 2));

            for (const chunk of scoredChunks) {
                if (results.length >= topK) break;
                const docCount = seenDocuments.get(chunk.filename) || 0;
                if (docCount < maxPerDocument) {
                    results.push(chunk);
                    seenDocuments.set(chunk.filename, docCount + 1);
                }
            }

            if (results.length < topK) {
                for (const chunk of scoredChunks) {
                    if (results.length >= topK) break;
                    if (!results.some(existing => existing.id === chunk.id)) {
                        results.push(chunk);
                    }
                }
            }

            return results;
        }

        buildCoverageCandidates(primaryResults, scoredChunks, count) {
            if (count <= 0) return [];

            const topDocs = Array.from(new Set(primaryResults.map(chunk => chunk.filename)));
            if (topDocs.length === 0) {
                for (const chunk of scoredChunks.slice(0, 3)) {
                    topDocs.push(chunk.filename);
                }
            }

            const coverage = [];
            const perDoc = Math.max(1, Math.ceil(count / Math.max(1, topDocs.length)));

            for (const filename of topDocs) {
                const docChunks = this.allChunks
                    .filter(chunk => chunk.filename === filename)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                coverage.push(...this.pickEvenlyDistributed(docChunks, perDoc));
            }

            return coverage.slice(0, count);
        }

        findConceptLinkedChunks(primaryChunks, query, queryTokens, queryConcepts) {
            const linkedChunkIds = new Set();
            const linkedChunks = [];

            for (const chunk of primaryChunks) {
                const chunkConcepts = this.extractKeyConceptsFromChunk(chunk.text);
                for (const concept of chunkConcepts) {
                    const links = this.conceptIndex.get(concept) || [];
                    for (const link of links) {
                        if (linkedChunkIds.has(link.chunkId)) continue;
                        linkedChunkIds.add(link.chunkId);
                        const linkedChunk = this.chunkLookup.get(link.chunkId);
                        if (linkedChunk) {
                            const score = this.calculateRelevanceScore(linkedChunk, query, queryTokens, [], queryConcepts);
                            linkedChunks.push({ ...linkedChunk, score, isLinked: true });
                        }
                    }
                }
            }

            linkedChunks.sort((a, b) => b.score - a.score);
            return linkedChunks;
        }

        async retrieve(query, topK = null, options = {}) {
            if (this.allChunks.length === 0) return [];

            const intent = options.intent || this.detectQueryIntent(query);
            const corpusSize = this.allChunks.length;

            if (topK === null) {
                if (intent.broadCoverage) {
                    topK = corpusSize <= 60 ? 18 : corpusSize <= 200 ? 24 : Math.min(32, Math.ceil(corpusSize * 0.08));
                } else if (corpusSize <= 50) topK = 10;
                else if (corpusSize <= 200) topK = 15;
                else if (corpusSize <= 500) topK = 20;
                else topK = Math.min(25, Math.ceil(corpusSize * 0.05));
            }

            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) {
                    queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                }
                return {
                    variant,
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.58 : (0.42 / Math.max(1, queryVariants.length - 1))
                };
            });

            const scoredChunks = this.allChunks.map(chunk => {
                let score = 0;
                let maxVariantScore = 0;
                for (const features of variantFeatures) {
                    const variantScore = this.calculateQueryVariantScore(
                        chunk,
                        features.variant,
                        features.queryTokens,
                        features.queryEntities,
                        features.queryConcepts,
                        features.weight
                    );
                    score += variantScore;
                    maxVariantScore = Math.max(maxVariantScore, variantScore);
                }
                // Boost chunks that score strongly on at least one sub-query.
                score += maxVariantScore * 0.18;
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let primaryResults = this.diversifyResults(scoredChunks, Math.ceil(topK * 0.7));

            const bestScore = primaryResults[0]?.score || 0;
            if (intent.broadCoverage || bestScore < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const coverage = this.buildCoverageCandidates(primaryResults, scoredChunks, Math.ceil(topK * 0.5));
                primaryResults = this.mergeUniqueChunks(primaryResults, coverage, topK);
            }

            const baseFeatures = variantFeatures[0];
            const linkedChunks = this.findConceptLinkedChunks(primaryResults, query, baseFeatures.queryTokens, baseFeatures.queryConcepts)
                .slice(0, Math.max(2, Math.floor(topK * 0.25)));

            const merged = this.mergeUniqueChunks(primaryResults, linkedChunks, topK);

            if (merged.length === 0) {
                return this.allChunks.slice(0, topK);
            }

            const rerankCandidates = this.mergeUniqueChunks(
                scoredChunks.slice(0, Math.max(topK * 8, 80)),
                merged,
                EMBEDDING_RERANK_CANDIDATE_LIMIT
            );

            if (this.shouldUseSemanticRerank(intent, rerankCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, rerankCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = merged.slice(0, Math.ceil(topK * 0.5));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.7));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }

            return merged;
        }

        calculateLocalRelevanceScore(chunk, queryTokens, queryEntities, queryConcepts) {
            const chunkTokens = this.tokenize(chunk.text);
            const chunkTokenSet = new Set(chunkTokens);
            const chunkText = chunk.text.toLowerCase();
            let score = 0;

            if (queryTokens.length > 0) {
                const matches = queryTokens.filter(token => chunkTokenSet.has(token)).length;
                score += (matches / queryTokens.length) * 0.55;
            }

            if (queryEntities.length > 0) {
                const matches = queryEntities.filter(entity => chunkText.includes(entity.toLowerCase())).length;
                score += (matches / queryEntities.length) * 0.2;
            }

            if (queryConcepts.length > 0) {
                const matches = queryConcepts.filter(concept => chunkText.includes(concept)).length;
                score += (matches / queryConcepts.length) * 0.1;
            }

            if (queryTokens.length > 0) {
                const density = queryTokens.filter(token => chunkTokenSet.has(token)).length / Math.max(1, chunk.text.length / 120);
                score += Math.min(density * 0.06, 0.08);
            }

            return score;
        }

        async retrieveFromChunks(query, chunks, topK = 10, options = {}) {
            if (!chunks || chunks.length === 0) return [];

            const intent = options.intent || this.detectQueryIntent(query);
            const queryVariants = this.generateQueryVariants(query, intent);
            const variantFeatures = queryVariants.map((variant, idx) => {
                let queryTokens = this.tokenize(variant);
                if (queryTokens.length === 0) {
                    queryTokens = variant.toLowerCase().split(/\s+/).filter(token => token.length > 1);
                }
                return {
                    queryTokens,
                    queryEntities: this.extractEntities(variant),
                    queryConcepts: this.extractConcepts(variant),
                    weight: idx === 0 ? 0.6 : (0.4 / Math.max(1, queryVariants.length - 1))
                };
            });

            const scored = chunks.map(chunk => {
                let score = 0;
                for (const features of variantFeatures) {
                    const localScore = this.calculateLocalRelevanceScore(
                        chunk,
                        features.queryTokens,
                        features.queryEntities,
                        features.queryConcepts
                    );
                    score += localScore * features.weight;
                }
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let selected = scored.slice(0, Math.ceil(topK * 0.65));
            if (intent.broadCoverage || selected[0]?.score < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const orderedByIndex = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                const coverage = this.pickEvenlyDistributed(orderedByIndex, Math.ceil(topK * 0.5));
                selected = this.mergeUniqueChunks(selected, coverage, topK);
            }
            const semanticCandidates = this.mergeUniqueChunks(
                scored.slice(0, Math.max(topK * 6, 48)),
                selected,
                Math.min(EMBEDDING_RERANK_CANDIDATE_LIMIT, 96)
            );
            if (this.shouldUseSemanticRerank(intent, semanticCandidates, topK)) {
                const semanticResults = await this.semanticRerank(query, semanticCandidates, topK, intent);
                if (semanticResults && semanticResults.length > 0) {
                    const lexicalHead = selected.slice(0, Math.ceil(topK * 0.55));
                    const semanticHead = semanticResults.slice(0, Math.ceil(topK * 0.65));
                    return this.mergeUniqueChunks(lexicalHead, semanticHead, topK);
                }
            }

            return selected.slice(0, topK);
        }

        extractBestSentence(text, queryTokens) {
            const sentences = text
                .split(/(?<=[.!?])\s+/)
                .map(sentence => sentence.trim())
                .filter(Boolean);

            if (sentences.length === 0) return text.slice(0, 180);
            if (queryTokens.length === 0) return sentences[0].slice(0, 220);

            let bestSentence = sentences[0];
            let bestScore = -1;

            for (const sentence of sentences) {
                const lower = sentence.toLowerCase();
                const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                if (score > bestScore) {
                    bestScore = score;
                    bestSentence = sentence;
                }
            }

            return bestSentence.slice(0, 260);
        }

        buildAttachmentDigest(query, chunks, maxEntries = 14) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);

            const ranked = chunks.map(chunk => ({
                ...chunk,
                score: this.calculateLocalRelevanceScore(chunk, queryTokens, [], [])
            })).sort((a, b) => b.score - a.score);

            const top = ranked.slice(0, Math.ceil(maxEntries * 0.65));
            const ordered = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
            const coverage = this.pickEvenlyDistributed(ordered, Math.ceil(maxEntries * 0.4));
            const merged = this.mergeUniqueChunks(top, coverage, maxEntries);

            return merged.map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        buildCorpusDigest(query, chunks, maxEntries = 16) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            return chunks.slice(0, maxEntries).map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        getTopConnectedConcepts(limit = 10) {
            const conceptDocCounts = new Map();

            for (const [concept, links] of this.conceptIndex) {
                const uniqueDocs = new Set(links.map(link => link.filename));
                if (uniqueDocs.size > 1) {
                    conceptDocCounts.set(concept, uniqueDocs.size);
                }
            }

            return Array.from(conceptDocCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([concept, docCount]) => ({ concept, docCount }));
        }
    }

    class CognitiveSynthesizer {
        constructor() {
            this.apiKey = localStorage.getItem('openai_api_key') || '';
            this.model = localStorage.getItem('openai_model') || 'gpt-4.1';
            this.conversationHistory = this.loadChatHistory();
            this.workingMemory = this.loadWorkingMemory();
            this.responseCache = new Map();
            this.maxResponseCacheEntries = 40;
            this.responseCacheTtlMs = 2 * 60 * 60 * 1000;
            this.lastCompletionError = '';
            this.completionFailureCount = 0;
            this.completionFallbackCount = 0;
        }

        loadChatHistory() {
            const saved = localStorage.getItem('chat_history');
            try {
                return saved ? JSON.parse(saved) : [];
            } catch {
                return [];
            }
        }

        loadWorkingMemory() {
            const saved = localStorage.getItem('working_memory');
            try {
                return saved ? JSON.parse(saved) : [];
            } catch {
                return [];
            }
        }

        saveChatHistory() {
            const trimmed = this.conversationHistory.slice(-40);
            localStorage.setItem('chat_history', JSON.stringify(trimmed));
        }

        saveWorkingMemory() {
            const trimmed = this.workingMemory.slice(-18);
            localStorage.setItem('working_memory', JSON.stringify(trimmed));
        }

        clearHistory() {
            this.conversationHistory = [];
            this.workingMemory = [];
            localStorage.removeItem('chat_history');
            localStorage.removeItem('working_memory');
        }

        setApiKey(key) {
            this.apiKey = key;
            localStorage.setItem('openai_api_key', key);
        }

        setModel(model) {
            this.model = model;
            localStorage.setItem('openai_model', model);
        }

        buildInstructionProfile(query) {
            const lower = query.toLowerCase();
            const wordLimitMatch = query.match(/(\d{2,4})\s*words?/i);

            return {
                requestedFormat: /\btable\b/.test(lower) ? 'table' :
                    /\b(json)\b/.test(lower) ? 'json' :
                    /\b(bullet|bulleted|list|points)\b/.test(lower) ? 'bullet list' :
                    'structured prose',
                wantsSteps: /\b(step[- ]by[- ]step|steps)\b/.test(lower),
                wordLimit: wordLimitMatch ? parseInt(wordLimitMatch[1], 10) : null,
                strictSourceOnly: /\b(only use|based only|strictly from|from provided|from uploaded)\b/.test(lower),
                userIntent: lower
            };
        }

        getWorkingMemorySummary() {
            if (!this.workingMemory.length) return 'No prior working memory yet.';
            return this.workingMemory
                .slice(-6)
                .map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`)
                .join('\n');
        }

        rememberTurn(query, response) {
            const cleaned = response
                .replace(/\[Source:[^\]]+\]/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            const gist = cleaned.slice(0, 380);
            this.workingMemory.push({
                timestamp: new Date().toISOString(),
                query: query.slice(0, 160),
                gist
            });
            this.saveWorkingMemory();
        }

        safeJsonParse(rawText) {
            if (!rawText) return null;
            const trimmed = rawText.trim();
            try {
                return JSON.parse(trimmed);
            } catch {
                // Continue with extraction attempts below.
            }

            const fenced = trimmed.match(/```json\s*([\s\S]*?)\s*```/i) || trimmed.match(/```([\s\S]*?)```/);
            if (fenced?.[1]) {
                try {
                    return JSON.parse(fenced[1]);
                } catch {
                    // Continue with brace extraction.
                }
            }

            const start = trimmed.indexOf('{');
            const end = trimmed.lastIndexOf('}');
            if (start >= 0 && end > start) {
                const candidate = trimmed.slice(start, end + 1);
                try {
                    return JSON.parse(candidate);
                } catch {
                    return null;
                }
            }
            return null;
        }

        heuristicPlan(query, instructionProfile = {}) {
            const normalized = query.replace(/\s+/g, ' ').trim();
            const clauses = normalized
                .split(/\?\s+|;\s+|(?:\s+\b(?:and|also|plus|then)\b\s+)/i)
                .map(c => c.trim())
                .filter(c => c.length > 10);

            const subQuestions = clauses.length > 0 ? clauses.slice(0, 5) : [
                `What is the core answer to: ${normalized}?`,
                `What evidence supports the answer?`,
                `What cross-document links strengthen confidence?`
            ];

            return {
                analysis_mode: 'hierarchical-rag',
                sub_questions: subQuestions,
                evidence_strategy: 'Retrieve broad evidence, then verify every claim with citations.',
                output_spec: {
                    format: instructionProfile.requestedFormat || 'structured prose',
                    step_by_step: !!instructionProfile.wantsSteps,
                    max_words: instructionProfile.wordLimit || null,
                    strict_source_only: !!instructionProfile.strictSourceOnly
                }
            };
        }

        normalizePlan(plan, fallback) {
            if (!plan || typeof plan !== 'object') return fallback;
            const subQuestions = Array.isArray(plan.sub_questions)
                ? plan.sub_questions.filter(q => typeof q === 'string' && q.trim().length > 0).slice(0, 6)
                : [];

            return {
                analysis_mode: typeof plan.analysis_mode === 'string' ? plan.analysis_mode : fallback.analysis_mode,
                sub_questions: subQuestions.length ? subQuestions : fallback.sub_questions,
                evidence_strategy: typeof plan.evidence_strategy === 'string' ? plan.evidence_strategy : fallback.evidence_strategy,
                output_spec: {
                    format: plan.output_spec?.format || fallback.output_spec.format,
                    step_by_step: typeof plan.output_spec?.step_by_step === 'boolean'
                        ? plan.output_spec.step_by_step
                        : fallback.output_spec.step_by_step,
                    max_words: Number.isFinite(plan.output_spec?.max_words)
                        ? plan.output_spec.max_words
                        : fallback.output_spec.max_words,
                    strict_source_only: typeof plan.output_spec?.strict_source_only === 'boolean'
                        ? plan.output_spec.strict_source_only
                        : fallback.output_spec.strict_source_only
                }
            };
        }

        shouldUseModelPlanner(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const wordCount = String(query || '').split(/\s+/).filter(Boolean).length;
            const complexSeparators = /[;:?]/.test(query) || /\b(and|also|plus|compare|contrast|timeline)\b/i.test(query);
            const largeCorpus = (corpusStats.numChunks || 0) > 120 || (corpusStats.numDocs || 0) > 10;
            const largeAttachment = (attachmentContext?.chunks?.length || 0) > 12;
            const constrainedFormat = instructionProfile.wantsSteps || instructionProfile.requestedFormat !== 'structured prose';
            return wordCount > 24 || complexSeparators || largeCorpus || largeAttachment || constrainedFormat;
        }

        async buildCognitivePlan(query, instructionProfile = {}, corpusStats = {}, attachmentContext = null) {
            const fallback = this.heuristicPlan(query, instructionProfile);
            if (!this.shouldUseModelPlanner(query, instructionProfile, corpusStats, attachmentContext)) {
                return fallback;
            }
            const plannerSystem = `You are a planning module for a strict citation-grounded RAG system.
Return ONLY valid JSON object with keys:
- analysis_mode (string)
- sub_questions (array of 2-6 strings)
- evidence_strategy (string)
- output_spec (object: format, step_by_step, max_words, strict_source_only)
No prose outside JSON.`;

            const plannerUser = `Question: ${query}
Corpus docs: ${corpusStats.numDocs || 0}
Corpus chunks: ${corpusStats.numChunks || 0}
Attachment present: ${attachmentContext ? 'yes' : 'no'}
Requested format: ${instructionProfile.requestedFormat || 'structured prose'}
Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
Word limit: ${instructionProfile.wordLimit || 'none'}
Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}`;

            try {
                const raw = await this.callCompletion([
                    { role: 'system', content: plannerSystem },
                    { role: 'user', content: plannerUser }
                ], { temperature: 0.1, max_tokens: 420, top_p: 0.9 });
                const parsed = this.safeJsonParse(raw);
                return this.normalizePlan(parsed, fallback);
            } catch (error) {
                console.warn('Planner fallback:', error);
                return fallback;
            }
        }

        estimateChunkChars(chunks = []) {
            return chunks.reduce((sum, chunk) => sum + (chunk.text?.length || 0), 0);
        }

        shouldUseMultiPass(relevantChunks, attachmentContext = null, corpusStats = {}, plan = null) {
            const corpusChars = this.estimateChunkChars(relevantChunks);
            const attachmentChars = this.estimateChunkChars(attachmentContext?.chunks || []);
            const totalChunks = (relevantChunks?.length || 0) + (attachmentContext?.chunks?.length || 0);
            const planBreadth = plan?.sub_questions?.length || 0;

            return (
                totalChunks >= MULTIPASS_CHUNK_THRESHOLD ||
                (corpusChars + attachmentChars) >= MULTIPASS_CONTEXT_CHAR_THRESHOLD ||
                (corpusStats.numChunks || 0) > 260 ||
                (planBreadth >= 5 && totalChunks >= 10)
            );
        }

        dedupeChunks(chunks = []) {
            const seen = new Set();
            const deduped = [];
            for (const chunk of chunks) {
                const key = chunk.id || `${chunk.filename}:${chunk.index}`;
                if (!key || seen.has(key)) continue;
                seen.add(key);
                deduped.push(chunk);
            }
            return deduped;
        }

        buildEvidenceBatches(relevantChunks, attachmentContext = null, maxChars = MAP_PASS_CONTEXT_BUDGET, maxBatches = MAX_MAP_PASSES) {
            const corpusTagged = (relevantChunks || []).map(chunk => ({ ...chunk, _scope: 'corpus' }));
            const attachmentTagged = (attachmentContext?.chunks || []).map(chunk => ({ ...chunk, _scope: 'attachment' }));
            const allChunks = this.dedupeChunks([...attachmentTagged, ...corpusTagged]);

            const batches = [];
            let currentBatch = [];
            let currentChars = 0;

            for (const chunk of allChunks) {
                const text = chunk.text || '';
                const blockSize = text.length + 220;
                if (currentBatch.length > 0 && currentChars + blockSize > maxChars) {
                    batches.push(currentBatch);
                    currentBatch = [];
                    currentChars = 0;
                }

                currentBatch.push(chunk);
                currentChars += blockSize;

                if (batches.length >= maxBatches) break;
            }

            if (currentBatch.length > 0 && batches.length < maxBatches) {
                batches.push(currentBatch);
            }

            return batches.slice(0, maxBatches);
        }

        formatEvidenceBatch(batch = [], label = '') {
            const lines = [`## ${label}`];
            for (const chunk of batch) {
                const page = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const scopeLabel = chunk._scope === 'attachment' ? 'ATTACHMENT' : 'CORPUS';
                lines.push(`### [${scopeLabel}] ${chunk.filename} (${page})`);
                lines.push((chunk.text || '').slice(0, 3000));
            }
            return lines.join('\n\n');
        }

        formatPlanForContext(plan) {
            if (!plan) return '';
            const subQuestions = (plan.sub_questions || []).map((q, i) => `${i + 1}. ${q}`).join('\n');
            return `## COGNITIVE PLAN
Analysis mode: ${plan.analysis_mode || 'hierarchical-rag'}
Evidence strategy: ${plan.evidence_strategy || 'N/A'}
Sub-questions:
${subQuestions || '1. Answer the user query directly.'}

Output spec:
- Format: ${plan.output_spec?.format || 'structured prose'}
- Step-by-step: ${plan.output_spec?.step_by_step ? 'yes' : 'no'}
- Max words: ${plan.output_spec?.max_words || 'none'}
- Strict source only: ${plan.output_spec?.strict_source_only ? 'yes' : 'no'}`;
        }

        async runMapPhase(query, plan, evidenceBatches) {
            const mapNotes = [];
            for (let i = 0; i < evidenceBatches.length; i++) {
                const batch = evidenceBatches[i];
                const batchContext = this.formatEvidenceBatch(batch, `EVIDENCE BATCH ${i + 1}/${evidenceBatches.length}`);
                const mapPrompt = `Question: ${query}

Plan sub-questions:
${(plan.sub_questions || []).map((q, idx) => `${idx + 1}. ${q}`).join('\n')}

Extract the highest-value findings from this batch only.
Rules:
- Use concise bullet points.
- Include only findings supported by this batch.
- Every bullet must include citation in exact format:
  [Source: filename, page X, "brief relevant quote"]
- End with one line: "Batch confidence: High/Medium/Low"`;

                const mapMessages = [
                    {
                        role: 'system',
                        content: `You are an evidence extractor for long-context RAG map-reduce.
Only use the provided batch. Do not generalize beyond it.`
                    },
                    { role: 'user', content: `${batchContext}\n\n${mapPrompt}` }
                ];

                let note = '';
                try {
                    note = await this.callCompletion(mapMessages, {
                        temperature: 0.1,
                        max_tokens: 750,
                        top_p: 0.85
                    });
                } catch (error) {
                    console.warn(`Map pass ${i + 1} failed:`, error);
                    note = `- Map pass ${i + 1} unavailable due to transient model error.`;
                }
                mapNotes.push({ batchIndex: i + 1, note });
            }
            return mapNotes;
        }

        formatMapNotes(mapNotes = []) {
            if (!mapNotes.length) return '';
            const blocks = mapNotes.map(item => `### MAP NOTE ${item.batchIndex}\n${item.note}`);
            return `## MAP-REDUCE EVIDENCE NOTES\n${blocks.join('\n\n')}`;
        }

        countCitations(text) {
            return (text.match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }

        tokenizeForDiagnostics(text) {
            const stop = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'if', 'then', 'in', 'on', 'at', 'to', 'for', 'of',
                'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'it', 'its', 'that',
                'this', 'these', 'those', 'we', 'they', 'their', 'there', 'here', 'which', 'what', 'when',
                'where', 'why', 'how', 'can', 'could', 'should', 'would', 'may', 'might', 'will', 'also'
            ]);
            return String(text || '')
                .toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !stop.has(token));
        }

        normalizeFilename(name) {
            return String(name || '').trim().toLowerCase();
        }

        extractCitations(text) {
            const regex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citations = [];
            let match;
            while ((match = regex.exec(text)) !== null) {
                citations.push({
                    filename: String(match[1] || '').trim(),
                    page: String(match[2] || '').trim(),
                    quote: String(match[3] || '').trim()
                });
            }
            return citations;
        }

        buildSourceCaches(sources = []) {
            return (sources || []).map(source => {
                const originalText = String(source.text || '');
                const textLower = originalText.toLowerCase();
                return {
                    filenameDisplay: String(source.filename || '').trim(),
                    filename: this.normalizeFilename(source.filename),
                    page: source.page || 'N/A',
                    originalText,
                    textLower,
                    tokenSet: new Set(this.tokenizeForDiagnostics(textLower))
                };
            });
        }

        splitSentencesForQuote(text) {
            return String(text || '')
                .replace(/\r\n/g, '\n')
                .split(/(?<=[.!?])\s+|\n+/)
                .map(sentence => sentence.trim())
                .filter(Boolean);
        }

        cleanQuoteText(text) {
            return String(text || '')
                .replace(/["“”]/g, '')
                .replace(/\s+/g, ' ')
                .trim()
                .slice(0, 180);
        }

        buildCitationForClaim(claim, sourceCaches = []) {
            if (!claim || sourceCaches.length === 0) return null;
            const claimTokens = this.tokenizeForDiagnostics(claim);
            if (claimTokens.length === 0) return null;

            let bestSource = null;
            let bestScore = 0;
            for (const source of sourceCaches) {
                const overlap = this.getTokenOverlapRatio(claimTokens, source.tokenSet);
                if (overlap > bestScore) {
                    bestScore = overlap;
                    bestSource = source;
                }
            }

            if (!bestSource || bestScore < 0.12) return null;

            const sentences = this.splitSentencesForQuote(bestSource.originalText);
            let quote = '';
            let quoteScore = 0;

            for (const sentence of sentences) {
                if (sentence.length < 20) continue;
                const sentenceTokens = this.tokenizeForDiagnostics(sentence);
                if (sentenceTokens.length === 0) continue;
                const overlap = this.getTokenOverlapRatio(claimTokens, new Set(sentenceTokens));
                if (overlap > quoteScore) {
                    quoteScore = overlap;
                    quote = sentence;
                }
            }

            if (!quote) {
                quote = bestSource.originalText.slice(0, 160);
            }

            quote = this.cleanQuoteText(quote);
            if (!quote) return null;

            return `[Source: ${bestSource.filenameDisplay || 'Unknown Source'}, page ${bestSource.page}, "${quote}"]`;
        }

        cleanAssistantText(text) {
            return String(text || '')
                .replace(/\r\n/g, '\n')
                .replace(/[\u200B-\u200D\uFEFF]/g, '')
                .replace(/[“”]/g, '"')
                .replace(/[‘’]/g, "'")
                .replace(/[•◦▪●]/g, '-')
                .replace(/[—–]/g, '-')
                .replace(/\p{Extended_Pictographic}/gu, '')
                .replace(/[^\S\r\n]+\n/g, '\n')
                .replace(/\n{3,}/g, '\n\n')
                .replace(/[ \t]{2,}/g, ' ')
                .trim();
        }

        looksLikeAnalysisSectionHeader(line) {
            const lower = String(line || '').toLowerCase().trim();
            return (
                /^mental model[:\s]/i.test(lower) ||
                /^cross-document/i.test(lower) ||
                /^uncertainty/i.test(lower) ||
                /^limits?/i.test(lower) ||
                /^evidence gaps?/i.test(lower) ||
                /^synthesis/i.test(lower)
            );
        }

        hasHumanAnalysisMarkers(text, instructionProfile = {}) {
            if (!text) return false;
            if (instructionProfile.requestedFormat === 'json' || instructionProfile.requestedFormat === 'table') {
                return true;
            }

            const markers = [
                /mental model/i,
                /macro level|meso level|micro level/i,
                /cross-document|across documents|synthesizing across/i,
                /tension|contradiction|trade-off/i,
                /uncertainty|cannot fully confirm|based on the available documents/i,
                /implication|interpretation|what this suggests/i
            ];

            let hitCount = 0;
            for (const marker of markers) {
                if (marker.test(text)) hitCount++;
            }
            return hitCount >= 2;
        }

        enforceCitationCoverage(text, sources = [], instructionProfile = {}) {
            if (!text || !sources.length) return text;
            if (instructionProfile.requestedFormat === 'json' || instructionProfile.requestedFormat === 'table') {
                return text;
            }

            const sourceCaches = this.buildSourceCaches(sources);
            const lines = String(text).split('\n');
            const citationRegex = /\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i;
            let injected = 0;
            const maxInject = 20;

            const updated = lines.map(rawLine => {
                if (injected >= maxInject) return rawLine;
                const line = rawLine.trim();
                if (!line) return rawLine;
                if (citationRegex.test(line)) return rawLine;
                if (/^#{1,6}\s+/.test(line)) return rawLine;
                if (/^[A-Za-z0-9 _-]+:\s*$/.test(line)) return rawLine;
                if (this.looksLikeAnalysisSectionHeader(line)) return rawLine;
                if (!this.isLikelyClaimLine(line)) return rawLine;

                const citation = this.buildCitationForClaim(line, sourceCaches);
                if (!citation) return rawLine;
                injected++;
                return `${rawLine} ${citation}`;
            });

            let merged = updated.join('\n');

            // Second pass for long uncited lines that can hide multiple claims.
            const secondPassLines = merged.split('\n');
            for (let i = 0; i < secondPassLines.length && injected < maxInject; i++) {
                const line = secondPassLines[i].trim();
                if (!line || citationRegex.test(line)) continue;
                if (line.length < 220) continue;
                if (!this.isLikelyClaimLine(line)) continue;
                const citation = this.buildCitationForClaim(line, sourceCaches);
                if (!citation) continue;
                secondPassLines[i] = `${secondPassLines[i]} ${citation}`;
                injected++;
            }

            merged = secondPassLines.join('\n');
            return merged;
        }

        ensureHumanAnalysisStructure(text, sources = [], instructionProfile = {}) {
            if (!text) return text;
            if (instructionProfile.requestedFormat === 'json' || instructionProfile.requestedFormat === 'table') {
                return text;
            }
            if (instructionProfile.requestedFormat === 'bullet list') {
                return text;
            }

            const normalized = this.cleanAssistantText(text);
            const lower = normalized.toLowerCase();
            const hasMental = /mental model/i.test(lower);
            const hasCross = /cross-document|across documents|synthesizing across/i.test(lower);
            const hasUncertainty = /uncertainty|limits|cannot fully confirm|based on the available documents/i.test(lower);
            if (hasMental && hasCross && hasUncertainty) {
                return normalized;
            }

            const paragraphs = normalized
                .split(/\n{2,}/)
                .map(paragraph => paragraph.trim())
                .filter(Boolean);

            const p1 = paragraphs[0] || normalized;
            const p2 = paragraphs.slice(1).join('\n\n') || p1;
            const uncertaintyText = 'Based on the available documents, remaining uncertainty depends on sections where evidence is incomplete, conflicting, or implicit.';

            const sourceCaches = this.buildSourceCaches(sources);
            const attachCitationIfMissing = (body) => {
                if (/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(body)) {
                    return body;
                }
                const citation = this.buildCitationForClaim(body, sourceCaches);
                return citation ? `${body} ${citation}` : body;
            };

            return [
                `Mental model (macro/meso/micro):\n${attachCitationIfMissing(p1)}`,
                `Cross-document synthesis and implications:\n${attachCitationIfMissing(p2)}`,
                `Uncertainty and limits:\n${attachCitationIfMissing(uncertaintyText)}`
            ].join('\n\n');
        }

        finalizeAssistantMessage(text, sources = [], instructionProfile = {}) {
            let output = this.cleanAssistantText(text);
            output = this.enforceCitationCoverage(output, sources, instructionProfile);
            output = this.ensureHumanAnalysisStructure(output, sources, instructionProfile);
            output = this.cleanAssistantText(output);
            return output;
        }

        getTokenOverlapRatio(tokens, tokenSet) {
            if (!tokens.length) return 0;
            let matches = 0;
            for (const token of tokens) {
                if (tokenSet.has(token)) matches++;
            }
            return matches / tokens.length;
        }

        computeClaimSupportScore(claim, sourceCaches = []) {
            const claimTokens = this.tokenizeForDiagnostics(claim);
            if (!claimTokens.length || sourceCaches.length === 0) return 0;
            let best = 0;
            for (const source of sourceCaches) {
                const overlap = this.getTokenOverlapRatio(claimTokens, source.tokenSet);
                if (overlap > best) best = overlap;
                if (best >= 0.98) break;
            }
            return best;
        }

        evaluateCitationPrecision(citations = [], sourceCaches = []) {
            if (citations.length === 0) {
                return {
                    total: 0,
                    valid: 0,
                    precision: 0
                };
            }

            let valid = 0;
            for (const citation of citations) {
                const citedName = this.normalizeFilename(citation.filename);
                const quoteLower = citation.quote.toLowerCase();
                const quoteTokens = this.tokenizeForDiagnostics(quoteLower);

                const filenameMatches = sourceCaches.filter(source =>
                    source.filename === citedName ||
                    source.filename.includes(citedName) ||
                    citedName.includes(source.filename)
                );

                if (filenameMatches.length === 0) continue;

                let quoteSupported = false;
                for (const source of filenameMatches) {
                    if (quoteLower.length >= 8 && source.textLower.includes(quoteLower)) {
                        quoteSupported = true;
                        break;
                    }
                    if (quoteTokens.length > 0) {
                        const overlap = this.getTokenOverlapRatio(quoteTokens, source.tokenSet);
                        if (overlap >= 0.55) {
                            quoteSupported = true;
                            break;
                        }
                    }
                }

                if (quoteSupported) valid++;
            }

            return {
                total: citations.length,
                valid,
                precision: citations.length ? (valid / citations.length) : 0
            };
        }

        isLikelyClaimLine(line) {
            const cleaned = line
                .replace(/^[-*]\s+/, '')
                .replace(/^\d+\.\s+/, '')
                .trim();
            if (cleaned.length < 18) return false;
            if (this.looksLikeAnalysisSectionHeader(cleaned)) return false;
            if (/^\[Source:/i.test(cleaned)) return false;
            if (/^#{1,6}\s+/.test(cleaned)) return false;
            return /[a-zA-Z]/.test(cleaned);
        }

        extractClaimLines(text) {
            const lines = String(text || '')
                .split('\n')
                .map(line => line.trim())
                .filter(Boolean);

            const claims = lines
                .map(line => line.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim())
                .filter(line => this.isLikelyClaimLine(line));

            if (claims.length > 0) return claims.slice(0, 40);

            return String(text || '')
                .split(/(?<=[.!?])\s+/)
                .map(sentence => sentence.trim())
                .filter(sentence => sentence.length > 28)
                .slice(0, 40);
        }

        buildClaimCitationDiagnostics(responseText, sources = []) {
            const sourceCaches = this.buildSourceCaches(sources);
            const claims = this.extractClaimLines(responseText);
            const citations = this.extractCitations(responseText);
            const citationPrecision = this.evaluateCitationPrecision(citations, sourceCaches);

            const claimEvaluations = claims.map(claim => {
                const hasCitation = /\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/i.test(claim);
                const supportScore = this.computeClaimSupportScore(claim, sourceCaches);
                return { claim, hasCitation, supportScore };
            });

            const totalClaims = claimEvaluations.length;
            const citedClaims = claimEvaluations.filter(item => item.hasCitation).length;
            const supportedClaims = claimEvaluations.filter(item => item.supportScore >= 0.22).length;

            const directCoverage = totalClaims ? (citedClaims / totalClaims) : 1;
            const citationDensityCoverage = totalClaims
                ? Math.min(1, citations.length / Math.max(1, Math.ceil(totalClaims * 0.75)))
                : 1;
            const claimCitationCoverage = Math.max(directCoverage, citationDensityCoverage * 0.92);
            const claimSupportRatio = totalClaims ? (supportedClaims / totalClaims) : 1;
            const weakClaims = claimEvaluations
                .filter(item => !item.hasCitation || item.supportScore < 0.22)
                .slice(0, 5)
                .map(item => `- ${item.claim.slice(0, 180)} (citation=${item.hasCitation ? 'yes' : 'no'}, support=${item.supportScore.toFixed(2)})`);

            const needsRepair = (
                (citations.length === 0 && totalClaims > 0) ||
                (
                    totalClaims >= 3 &&
                    claimCitationCoverage < CLAIM_CITATION_TARGET &&
                    citations.length < Math.max(2, Math.round(totalClaims * 0.35))
                ) ||
                (
                    totalClaims >= 3 &&
                    claimSupportRatio < CLAIM_SUPPORT_TARGET &&
                    citationPrecision.precision < CITATION_PRECISION_TARGET
                )
            );

            return {
                totalClaims,
                citedClaims,
                supportedClaims,
                claimCitationCoverage,
                claimSupportRatio,
                citationPrecision: citationPrecision.precision,
                citationCount: citations.length,
                weakClaims,
                needsRepair
            };
        }

        maybeViolatesOutputContract(text, instructionProfile = {}) {
            const citationCount = this.countCitations(text);
            if (citationCount === 0) return true;

            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                if (!(trimmed.startsWith('{') || trimmed.startsWith('[') || trimmed.includes('```json'))) {
                    return true;
                }
            }

            if (instructionProfile.requestedFormat === 'table') {
                if (!/\|.+\|/.test(text)) return true;
            }

            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                if (words > Math.ceil(instructionProfile.wordLimit * 1.25)) {
                    return true;
                }
            }

            return false;
        }

        async verifyAndRepairAnswer(query, answer, instructionProfile, contextSnippet, diagnostics = null) {
            const diagnosticsBlock = diagnostics ? `
Claim/citation diagnostics:
- Total claims: ${diagnostics.totalClaims}
- Claim citation coverage: ${(diagnostics.claimCitationCoverage * 100).toFixed(1)}%
- Claim support ratio: ${(diagnostics.claimSupportRatio * 100).toFixed(1)}%
- Citation precision: ${(diagnostics.citationPrecision * 100).toFixed(1)}%
Weak claim samples:
${(diagnostics.weakClaims || []).join('\n') || '- none'}
` : '';

            const verifierMessages = [
                {
                    role: 'system',
                    content: `You are a response verifier for strict RAG answers.
If the answer violates instructions or lacks proper citations, repair it.
Always preserve factual grounding and keep citations in format:
[Source: filename, page X, "brief relevant quote"].
Ensure response has human-like analysis depth (mental model, cross-document links, and uncertainty).
Remove decorative or unusual special characters.
Return only the repaired answer text.`
                },
                {
                    role: 'user',
                    content: `Question: ${query}
Instruction profile:
- Format: ${instructionProfile.requestedFormat}
- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}
- Word limit: ${instructionProfile.wordLimit || 'none'}
- Strict source-only: ${instructionProfile.strictSourceOnly ? 'yes' : 'no'}

Evidence snippet:
${contextSnippet}

${diagnosticsBlock}

Answer to verify/repair:
${answer}`
                }
            ];

            const repaired = await this.callCompletion(verifierMessages, {
                temperature: 0.1,
                max_tokens: 2200,
                top_p: 0.9
            });

            return repaired?.trim() ? repaired : answer;
        }

        getSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
            const numDocs = corpusStats.numDocs || 0;
            const numChunks = corpusStats.numChunks || 0;
            const formatReq = instructionProfile.requestedFormat || 'structured prose';
            const stepReq = instructionProfile.wantsSteps ? 'Yes' : 'No';
            const wordLimit = instructionProfile.wordLimit ? `${instructionProfile.wordLimit} words` : 'No explicit limit';
            const sourceOnly = instructionProfile.strictSourceOnly ? 'Yes - strictly source-grounded.' : 'Ground all factual claims in provided sources.';

            return `You are a COGNITIVE SYNTHESIS ENGINE.

You are given:
1) Retrieved evidence chunks from uploaded documents.
2) Document-memory summaries generated from full uploaded files (outline, key concepts, salient sentences).
3) Optional temporary attachment memory for one-time analysis.

IMPORTANT ACCESS RULE:
- If context is provided, NEVER claim you cannot access the documents.
- Never mention "training cutoff" unless user explicitly asks about model knowledge limits.
- If evidence is missing, say: "Based on the available documents, I cannot fully confirm..."

Human-like synthesis mode (inspired by brain-mimicking LLM research):
- Working-memory loop: obey the current instruction contract precisely.
- Semantic-memory loop: use document-memory summaries to maintain long-range context.
- Retrieval loop: verify claims against cited chunks before finalizing.
- Planner loop: decompose complex queries into sub-questions before writing.
- Map-reduce loop: aggregate distributed evidence across long contexts.
- Verifier loop: self-check instruction compliance and citation completeness.

Corpus snapshot:
- Documents: ${numDocs}
- Chunks: ${numChunks}

Instruction contract:
- Output format: ${formatReq}
- Step-by-step required: ${stepReq}
- Length target: ${wordLimit}
- Source policy: ${sourceOnly}

MANDATORY CITATION FORMAT:
[Source: filename, page X, "brief relevant quote"]

RESPONSE SHAPE (unless user explicitly requests a different structure):
1) Mental model (macro/meso/micro synthesis)
2) Cross-document links, tensions, and implications
3) Uncertainty and limits from provided evidence

MAXIMIZATION GOAL:
- Deliver complete, high-recall, high-precision synthesis across all provided sources.
- Behave like a "super-analyst" only through better retrieval + planning + verification.
- Never invent evidence, never claim hidden access, never skip citations for factual claims.

CONTEXT:
${context}

WORKING MEMORY FROM PRIOR TURNS:
${workingMemorySummary}
`;
        }

        formatDocumentMemories(documentMemories = []) {
            if (!documentMemories.length) return '';
            const blocks = documentMemories.slice(0, 10).map((doc, idx) => {
                const memory = doc.memory || {};
                const concepts = (memory.keyConcepts || []).slice(0, 10).join(', ') || 'N/A';
                const outline = (memory.outline || []).slice(0, 8).join(' | ') || 'N/A';
                const synopsis = memory.synopsis || (memory.salientSentences || []).slice(0, 3).join(' ');
                return `### Document Memory ${idx + 1}: ${doc.filename}
- Word count: ${memory.wordCount || 'N/A'}
- Reading time (min): ${memory.readingTimeMinutes || 'N/A'}
- Outline: ${outline}
- Key concepts: ${concepts}
- Synopsis: ${synopsis}`;
            });

            return `## DOCUMENT MEMORY BLOCKS (generated from full files)\n${blocks.join('\n\n')}`;
        }

        formatContext(chunks, maxChars = MAX_CONTEXT_CHARS) {
            if (!chunks || chunks.length === 0) {
                return { contextText: 'No relevant documents found in the corpus.', included: 0, omitted: 0 };
            }

            let totalChars = 0;
            const includedBlocks = [];
            let omitted = 0;

            for (const chunk of chunks) {
                const sectionLabel = chunk.section ? `, Section: ${chunk.section}` : '';
                const pageLabel = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const block = `### Evidence: ${chunk.filename} (${pageLabel}${sectionLabel})
${chunk.text}`;

                if (totalChars + block.length > maxChars) {
                    omitted++;
                    continue;
                }

                includedBlocks.push(block);
                totalChars += block.length;
            }

            if (includedBlocks.length === 0 && chunks.length > 0) {
                const fallback = chunks[0];
                includedBlocks.push(`### Evidence: ${fallback.filename} (Page ${fallback.page || 'N/A'})
${fallback.text.slice(0, Math.min(2500, fallback.text.length))}`);
                omitted = Math.max(0, chunks.length - 1);
            }

            return {
                contextText: includedBlocks.join('\n\n---\n\n'),
                included: includedBlocks.length,
                omitted
            };
        }

        looksLikeContextRefusal(responseText) {
            if (!responseText) return false;
            return REFUSAL_PATTERNS.some(pattern => pattern.test(responseText));
        }

        buildUserPrompt(query, instructionProfile) {
            const lines = [
                `User question:\n${query}`,
                '',
                'Please obey this response contract:',
                `- Format: ${instructionProfile.requestedFormat}`,
                `- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}`,
                `- Word limit: ${instructionProfile.wordLimit ? instructionProfile.wordLimit : 'no strict limit'}`,
                `- Source-only strictness: ${instructionProfile.strictSourceOnly ? 'strict' : 'grounded, with clear uncertainty if missing'}`,
                '- Provide human-like analysis (mental model + cross-document connections + uncertainty).',
                '- Avoid decorative symbols or unusual special characters.'
            ];
            return lines.join('\n');
        }

        buildResponseCacheKey(messages, model, overrides = {}) {
            const userMessage = [...messages].reverse().find(msg => msg.role === 'user')?.content || '';
            const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';
            const paramsFingerprint = JSON.stringify({
                temperature: overrides.temperature ?? 0.25,
                top_p: overrides.top_p ?? 0.9,
                max_tokens: overrides.max_tokens ?? 2500
            });

            return [
                model,
                simpleHash(userMessage.slice(0, 6000)),
                simpleHash(systemMessage.slice(0, 8000)),
                simpleHash(paramsFingerprint)
            ].join(':');
        }

        getCachedResponse(cacheKey) {
            const entry = this.responseCache.get(cacheKey);
            if (!entry) return null;
            if ((Date.now() - entry.ts) > this.responseCacheTtlMs) {
                this.responseCache.delete(cacheKey);
                return null;
            }
            return entry.value;
        }

        setCachedResponse(cacheKey, responseText) {
            if (!cacheKey || !responseText) return;
            if (this.responseCache.has(cacheKey)) {
                this.responseCache.delete(cacheKey);
            }
            this.responseCache.set(cacheKey, {
                ts: Date.now(),
                value: responseText
            });

            while (this.responseCache.size > this.maxResponseCacheEntries) {
                const firstKey = this.responseCache.keys().next().value;
                if (!firstKey) break;
                this.responseCache.delete(firstKey);
            }
        }

        getModelFallbackChain(primaryModel, disableFallback = false) {
            if (disableFallback) return [primaryModel];
            const chain = [primaryModel];
            if (primaryModel === 'gpt-4.1') {
                chain.push('gpt-4o');
            } else if (primaryModel === 'gpt-4o') {
                chain.push('gpt-4.1');
            } else {
                chain.push('gpt-4o');
            }
            return Array.from(new Set(chain));
        }

        async callCompletion(messages, overrides = {}) {
            const baseModel = overrides.model || this.model;
            const modelChain = this.getModelFallbackChain(baseModel, overrides.disableModelFallback === true);
            const cacheKey = this.buildResponseCacheKey(messages, baseModel, overrides);
            const cached = this.getCachedResponse(cacheKey);
            if (cached) {
                return cached;
            }

            const basePayload = {
                messages,
                temperature: 0.25,
                max_tokens: 2500,
                top_p: 0.9,
                ...overrides
            };

            let lastError = null;
            for (let idx = 0; idx < modelChain.length; idx++) {
                const candidateModel = modelChain[idx];
                try {
                    const payload = {
                        ...basePayload,
                        model: candidateModel
                    };
                    const { data } = await fetchJsonWithRetry(
                        'https://api.openai.com/v1/chat/completions',
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.apiKey}`
                            },
                            body: JSON.stringify(payload)
                        },
                        {
                            timeoutMs: COMPLETION_TIMEOUT_MS,
                            maxRetries: COMPLETION_MAX_RETRIES
                        }
                    );

                    const assistantMessage = data.choices?.[0]?.message?.content || '';
                    if (!assistantMessage) {
                        throw buildHttpError('Empty completion returned by model', null, false);
                    }

                    if (candidateModel !== baseModel) {
                        this.completionFallbackCount += 1;
                    }
                    this.completionFailureCount = 0;
                    this.lastCompletionError = '';
                    this.setCachedResponse(cacheKey, assistantMessage);
                    return assistantMessage;
                } catch (error) {
                    lastError = error;
                    this.lastCompletionError = error?.message || 'Completion request failed';
                    this.completionFailureCount += 1;

                    const hasNextModel = idx < modelChain.length - 1;
                    if (!hasNextModel) break;
                    if (!error?.isTransient) break;
                }
            }

            const staleCached = this.getCachedResponse(cacheKey);
            if (staleCached) {
                return staleCached;
            }

            throw lastError || new Error('Completion request failed');
        }

        async synthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
            if (!this.apiKey) {
                throw new Error('API key not configured. Please set your OpenAI API key in the Admin Panel.');
            }

            const instructionProfile = this.buildInstructionProfile(query);
            const workingMemorySummary = this.getWorkingMemorySummary();
            const cognitivePlan = await this.buildCognitivePlan(query, instructionProfile, corpusStats, attachmentContext);
            const useMultiPass = this.shouldUseMultiPass(relevantChunks, attachmentContext, corpusStats, cognitivePlan);

            const contextSections = [];
            contextSections.push(this.formatPlanForContext(cognitivePlan));

            if (attachmentContext?.memory) {
                const m = attachmentContext.memory;
                contextSections.push(`## ATTACHMENT MEMORY (FULL FILE)
File: ${attachmentContext.name}
Word count: ${m.wordCount || 'N/A'}
Outline: ${(m.outline || []).slice(0, 10).join(' | ') || 'N/A'}
Key concepts: ${(m.keyConcepts || []).slice(0, 12).join(', ') || 'N/A'}
Synopsis: ${m.synopsis || (m.salientSentences || []).slice(0, 4).join(' ')}`);
            }

            if (attachmentContext?.digest) {
                contextSections.push(`## ATTACHMENT WIDE-COVERAGE DIGEST
${attachmentContext.digest}`);
            }

            if (corpusStats.documentMemories && corpusStats.documentMemories.length > 0) {
                contextSections.push(this.formatDocumentMemories(corpusStats.documentMemories));
            }

            if (corpusStats.connectedConcepts && corpusStats.connectedConcepts.length > 0) {
                const conceptSummary = corpusStats.connectedConcepts
                    .slice(0, 10)
                    .map(item => `- "${item.concept}" appears in ${item.docCount} documents`)
                    .join('\n');
                contextSections.push(`## CROSS-DOCUMENT CONCEPT BRIDGES\n${conceptSummary}`);
            }

            if (corpusStats.corpusDigest) {
                contextSections.push(`## CORPUS DIGEST\n${corpusStats.corpusDigest}`);
            }

            let mapNotes = [];
            if (useMultiPass) {
                const evidenceBatches = this.buildEvidenceBatches(relevantChunks, attachmentContext);
                if (evidenceBatches.length > 0) {
                    mapNotes = await this.runMapPhase(query, cognitivePlan, evidenceBatches);
                    if (mapNotes.length > 0) {
                        contextSections.push(this.formatMapNotes(mapNotes));
                    }
                }
            }

            const dynamicContextBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.58) : MAX_CONTEXT_CHARS;
            const formattedContext = this.formatContext(relevantChunks, dynamicContextBudget);
            contextSections.push(`## RETRIEVED EVIDENCE CHUNKS
Included chunks: ${formattedContext.included}
Omitted due to context budget: ${formattedContext.omitted}

${formattedContext.contextText}`);

            if (attachmentContext?.chunks && attachmentContext.chunks.length > 0) {
                const attachmentBudget = useMultiPass ? Math.floor(MAX_CONTEXT_CHARS * 0.24) : Math.floor(MAX_CONTEXT_CHARS * 0.35);
                const attachmentEvidence = this.formatContext(attachmentContext.chunks, attachmentBudget);
                contextSections.push(`## ATTACHMENT QUERY-SPECIFIC EVIDENCE
Included chunks: ${attachmentEvidence.included}
Omitted due to context budget: ${attachmentEvidence.omitted}

${attachmentEvidence.contextText}`);
            }

            const context = contextSections.join('\n\n');
            const systemPrompt = this.getSystemPrompt(context, corpusStats, instructionProfile, workingMemorySummary);
            const userPrompt = this.buildUserPrompt(query, instructionProfile);

            const messages = [
                { role: 'system', content: systemPrompt },
                ...this.conversationHistory.slice(-8),
                { role: 'user', content: userPrompt }
            ];

            let assistantMessage = await this.callCompletion(messages);
            assistantMessage = this.cleanAssistantText(assistantMessage);

            if ((relevantChunks.length > 0 || (attachmentContext?.chunks?.length || 0) > 0) && this.looksLikeContextRefusal(assistantMessage)) {
                const retryMessages = [
                    ...messages,
                    { role: 'assistant', content: assistantMessage },
                    {
                        role: 'user',
                        content: 'You incorrectly stated you cannot access documents. Re-answer using the provided evidence and document-memory blocks above. Do not mention training cutoff unless explicitly asked. Keep strict citations.'
                    }
                ];
                assistantMessage = await this.callCompletion(retryMessages, { temperature: 0.15 });
                assistantMessage = this.cleanAssistantText(assistantMessage);
            }

            let sources = [...(relevantChunks || [])];
            if (attachmentContext?.chunks) {
                const attachmentSources = attachmentContext.chunks.map(chunk => ({
                    ...chunk,
                    source: attachmentContext.name,
                    filename: attachmentContext.name,
                    isTemporary: true
                }));
                sources = [...attachmentSources, ...sources];
            }

            const availableSourceCount = sources.length;
            assistantMessage = this.finalizeAssistantMessage(assistantMessage, sources, instructionProfile);
            let citationCount = this.countCitations(assistantMessage);
            const minimumCitationTarget = availableSourceCount >= 10 ? 4 : availableSourceCount >= 4 ? 2 : availableSourceCount > 0 ? 1 : 0;
            let claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            const missingHumanAnalysis = !this.hasHumanAnalysisMarkers(assistantMessage, instructionProfile) && availableSourceCount >= 2;
            const strictRepairNeeded = (
                this.maybeViolatesOutputContract(assistantMessage, instructionProfile) ||
                (availableSourceCount > 0 && citationCount < minimumCitationTarget)
            );
            const softRepairNeeded = (
                claimDiagnostics.needsRepair &&
                (
                    claimDiagnostics.citationCount === 0 ||
                    claimDiagnostics.citationPrecision < 0.42 ||
                    claimDiagnostics.claimSupportRatio < 0.32
                )
            );
            const needsRepair = (
                strictRepairNeeded || softRepairNeeded || missingHumanAnalysis
            );

            if (needsRepair) {
                const verifierSnippet = [
                    this.formatPlanForContext(cognitivePlan),
                    mapNotes.length ? this.formatMapNotes(mapNotes.slice(0, 3)) : '',
                    `## EVIDENCE SNIPPET\n${formattedContext.contextText.slice(0, 9000)}`
                ].filter(Boolean).join('\n\n');

                assistantMessage = await this.verifyAndRepairAnswer(
                    query,
                    assistantMessage,
                    instructionProfile,
                    verifierSnippet,
                    claimDiagnostics
                );
                assistantMessage = this.finalizeAssistantMessage(assistantMessage, sources, instructionProfile);
                citationCount = this.countCitations(assistantMessage);
                claimDiagnostics = this.buildClaimCitationDiagnostics(assistantMessage, sources);
            }

            assistantMessage = this.finalizeAssistantMessage(assistantMessage, sources, instructionProfile);

            this.conversationHistory.push(
                { role: 'user', content: query },
                { role: 'assistant', content: assistantMessage }
            );
            this.saveChatHistory();
            this.rememberTurn(query, assistantMessage);

            return {
                response: assistantMessage,
                sources,
                meta: {
                    instructionProfile,
                    cognitivePlan,
                    mapPassCount: mapNotes.length,
                    citationCount,
                    claimDiagnostics
                }
            };
        }
    }

    class QualityEvaluator {
        constructor() {
            this.history = this.loadHistory();
        }

        loadHistory() {
            const saved = localStorage.getItem('quality_eval_history');
            try {
                return saved ? JSON.parse(saved) : [];
            } catch {
                return [];
            }
        }

        saveHistory() {
            const trimmed = this.history.slice(-120);
            localStorage.setItem('quality_eval_history', JSON.stringify(trimmed));
        }

        countCitations(text) {
            return (String(text || '').match(/\[Source:\s*[^,\]]+,\s*(?:page\s*)?[^,\]]+,\s*"[^"]+"\]/gi) || []).length;
        }

        evaluateInstructionAdherence(response, instructionProfile = {}, claimDiagnostics = null) {
            const checks = [];
            const text = String(response || '');

            if (instructionProfile.requestedFormat === 'json') {
                const trimmed = text.trim();
                checks.push(
                    trimmed.startsWith('{') ||
                    trimmed.startsWith('[') ||
                    trimmed.includes('```json')
                );
            } else if (instructionProfile.requestedFormat === 'table') {
                checks.push(/\|.+\|/.test(text));
            } else if (instructionProfile.requestedFormat === 'bullet list') {
                checks.push(/^\s*[-*]\s+/m.test(text) || /^\s*\d+\.\s+/m.test(text));
            }

            if (instructionProfile.wantsSteps) {
                checks.push(/\bStep\s*1\b/i.test(text) || /^\s*1\.\s+/m.test(text));
            }

            if (instructionProfile.wordLimit) {
                const words = text.split(/\s+/).filter(Boolean).length;
                checks.push(words <= Math.ceil(instructionProfile.wordLimit * 1.25));
            }

            if (instructionProfile.strictSourceOnly) {
                checks.push(this.countCitations(text) > 0);
                if (claimDiagnostics) {
                    checks.push(claimDiagnostics.claimCitationCoverage >= CLAIM_CITATION_TARGET);
                }
            }

            if (checks.length === 0) return 1;
            const passed = checks.filter(Boolean).length;
            return passed / checks.length;
        }

        evaluateTurn(query, response, sources = [], instructionProfile = {}, claimDiagnostics = null) {
            const diagnostics = claimDiagnostics || {
                claimCitationCoverage: this.countCitations(response) > 0 ? 0.75 : 0,
                claimSupportRatio: sources.length > 0 ? 0.65 : 1,
                citationPrecision: this.countCitations(response) > 0 ? 0.7 : 0
            };

            const coverage = Math.max(0, Math.min(1, diagnostics.claimSupportRatio || 0));
            const citationCoverage = Math.max(0, Math.min(1, diagnostics.claimCitationCoverage || 0));
            const citationPrecision = Math.max(0, Math.min(1, diagnostics.citationPrecision || 0));
            const instructionAdherence = Math.max(0, Math.min(1, this.evaluateInstructionAdherence(response, instructionProfile, diagnostics)));

            const overall = (
                coverage * 0.34 +
                citationCoverage * 0.22 +
                citationPrecision * 0.22 +
                instructionAdherence * 0.22
            );

            const report = {
                timestamp: new Date().toISOString(),
                query: String(query || '').slice(0, 220),
                metrics: {
                    coverage,
                    citationCoverage,
                    citationPrecision,
                    instructionAdherence,
                    overall
                },
                diagnostics
            };

            this.history.push(report);
            this.saveHistory();
            return report;
        }

        getRecentSummary(limit = 8) {
            const recent = this.history.slice(-limit);
            if (recent.length === 0) return null;

            const sum = recent.reduce((acc, item) => {
                acc.coverage += item.metrics.coverage;
                acc.citationCoverage += item.metrics.citationCoverage;
                acc.citationPrecision += item.metrics.citationPrecision;
                acc.instructionAdherence += item.metrics.instructionAdherence;
                acc.overall += item.metrics.overall;
                return acc;
            }, { coverage: 0, citationCoverage: 0, citationPrecision: 0, instructionAdherence: 0, overall: 0 });

            return {
                sampleSize: recent.length,
                averages: {
                    coverage: sum.coverage / recent.length,
                    citationCoverage: sum.citationCoverage / recent.length,
                    citationPrecision: sum.citationPrecision / recent.length,
                    instructionAdherence: sum.instructionAdherence / recent.length,
                    overall: sum.overall / recent.length
                },
                recent
            };
        }
    }

    class UIController {
        constructor(db, processor, retriever, synthesizer, evaluator) {
            this.db = db;
            this.processor = processor;
            this.retriever = retriever;
            this.synthesizer = synthesizer;
            this.evaluator = evaluator;
            this.currentAttachment = null;
            this.defaultSynthesisText = 'Building mental model and synthesizing across documents...';

            this.initializeElements();
            this.bindEvents();
            this.loadCorpus();
            this.restoreChatHistory();
        }

        initializeElements() {
            this.chatMessages = document.getElementById('chatMessages');
            this.chatInput = document.getElementById('chatInput');
            this.sendBtn = document.getElementById('sendBtn');
            this.synthesisIndicator = document.getElementById('synthesisIndicator');
            this.synthesisIndicatorText = document.getElementById('synthesisIndicatorText');
            this.clearChatBtn = document.getElementById('clearChatBtn');

            this.chatAttachBtn = document.getElementById('chatAttachBtn');
            this.chatFileInput = document.getElementById('chatFileInput');
            this.attachmentPreview = document.getElementById('attachmentPreview');
            this.attachmentName = document.getElementById('attachmentName');
            this.attachmentMeta = document.getElementById('attachmentMeta');
            this.attachmentRemove = document.getElementById('attachmentRemove');

            this.corpusList = document.getElementById('corpusList');
            this.docCount = document.getElementById('docCount');
            this.chunkCount = document.getElementById('chunkCount');

            this.adminPanel = document.getElementById('adminPanel');
            this.adminClose = document.getElementById('adminClose');
            this.openAdminBtn = document.getElementById('openAdminBtn');
            this.uploadZone = document.getElementById('uploadZone');
            this.fileInput = document.getElementById('fileInput');
            this.apiKeyInput = document.getElementById('apiKeyInput');
            this.saveApiKeyBtn = document.getElementById('saveApiKey');
            this.modelSelect = document.getElementById('modelSelect');
            this.processingStatus = document.getElementById('processingStatus');
            this.processingText = document.getElementById('processingText');
            this.processingBarFill = document.getElementById('processingBarFill');
            this.rebuildIndexBtn = document.getElementById('rebuildIndex');
            this.clearCorpusBtn = document.getElementById('clearCorpus');
            this.clearChatAdminBtn = document.getElementById('clearChatAdmin');
            this.runEvalHarnessBtn = document.getElementById('runEvalHarness');

            this.citationModal = document.getElementById('citationModal');
            this.citationClose = document.getElementById('citationClose');
            this.citationSource = document.getElementById('citationSource');
            this.citationText = document.getElementById('citationText');

            this.toastContainer = document.getElementById('toastContainer');

            this.apiKeyInput.value = localStorage.getItem('openai_api_key') || '';
            this.modelSelect.value = localStorage.getItem('openai_model') || 'gpt-4.1';
        }

        bindEvents() {
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            this.chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });

            this.clearChatBtn.addEventListener('click', () => this.clearChatHistory());
            this.chatAttachBtn.addEventListener('click', () => this.chatFileInput.click());
            this.chatFileInput.addEventListener('change', (e) => this.handleChatAttachment(e));
            this.attachmentRemove.addEventListener('click', () => this.removeChatAttachment());

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyA') {
                    e.preventDefault();
                    this.toggleAdminPanel();
                }
            });

            this.openAdminBtn.addEventListener('click', () => this.toggleAdminPanel(true));
            this.adminClose.addEventListener('click', () => this.toggleAdminPanel(false));
            this.adminPanel.addEventListener('click', (e) => {
                if (e.target === this.adminPanel) {
                    this.toggleAdminPanel(false);
                }
            });

            this.uploadZone.addEventListener('click', () => this.fileInput.click());
            this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

            this.uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                this.uploadZone.classList.add('dragover');
            });

            this.uploadZone.addEventListener('dragleave', () => {
                this.uploadZone.classList.remove('dragover');
            });

            this.uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                this.uploadZone.classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            });

            this.saveApiKeyBtn.addEventListener('click', () => {
                const key = this.apiKeyInput.value.trim();
                if (key) {
                    this.synthesizer.setApiKey(key);
                    this.retriever.setEmbeddingApiKey(key);
                    this.showToast('API key saved successfully', 'success');
                } else {
                    this.showToast('Please enter a valid API key', 'error');
                }
            });

            this.modelSelect.addEventListener('change', () => {
                this.synthesizer.setModel(this.modelSelect.value);
                this.showToast(`Model changed to ${this.modelSelect.value}`, 'success');
            });

            this.rebuildIndexBtn.addEventListener('click', () => this.rebuildIndex());
            this.clearCorpusBtn.addEventListener('click', () => this.clearCorpus());
            this.clearChatAdminBtn.addEventListener('click', () => this.clearChatHistory());
            this.runEvalHarnessBtn.addEventListener('click', () => this.runEvaluationHarness());

            this.citationClose.addEventListener('click', () => this.citationModal.classList.remove('active'));
            this.citationModal.addEventListener('click', (e) => {
                if (e.target === this.citationModal) {
                    this.citationModal.classList.remove('active');
                }
            });
        }

        toggleAdminPanel(show = null) {
            if (show === null) {
                this.adminPanel.classList.toggle('active');
            } else {
                this.adminPanel.classList.toggle('active', show);
            }
        }

        async loadCorpus() {
            const documents = await this.db.getAllDocuments();
            this.retriever.updateCorpus(documents);
            this.updateCorpusUI(documents);
        }

        updateCorpusUI(documents) {
            const totalChunks = documents.reduce((sum, doc) => sum + (doc.chunks?.length || 0), 0);

            this.docCount.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                </svg>
                ${documents.length} documents
            `;

            this.chunkCount.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"/>
                    <rect x="14" y="3" width="7" height="7"/>
                    <rect x="3" y="14" width="7" height="7"/>
                    <rect x="14" y="14" width="7" height="7"/>
                </svg>
                ${totalChunks} knowledge chunks
            `;

            if (documents.length === 0) {
                this.corpusList.innerHTML = `
                    <div class="corpus-empty">
                        No documents uploaded yet.<br>
                        Press <kbd>Ctrl+Shift+A</kbd> to open Admin Panel.
                    </div>
                `;
                return;
            }

            this.corpusList.innerHTML = documents.map(doc => `
                <div class="corpus-item" data-id="${doc.id}">
                    <div class="corpus-item-info">
                        <div class="corpus-item-name" title="${this.escapeHtml(doc.filename)}">${this.escapeHtml(doc.filename)}</div>
                        <div class="corpus-item-meta">
                            ${(doc.size / 1024).toFixed(1)} KB • ${doc.chunks?.length || 0} chunks
                        </div>
                    </div>
                    <button class="corpus-item-delete" onclick="app.deleteDocument(${doc.id})">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            `).join('');
        }

        async handleFiles(files) {
            const fileArray = Array.from(files);
            if (fileArray.length === 0) return;

            this.processingStatus.classList.add('active');

            let processed = 0;
            const total = fileArray.length;

            for (const file of fileArray) {
                this.processingText.textContent = `Processing ${file.name}...`;
                this.processingBarFill.style.width = `${(processed / total) * 100}%`;

                try {
                    const document = await this.processor.processFile(file);
                    await this.db.addDocument(document);
                    processed++;
                    this.showToast(`Processed: ${file.name}`, 'success');
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    this.showToast(`Failed: ${file.name} (${error.message})`, 'error');
                }
            }

            this.processingBarFill.style.width = '100%';
            this.processingText.textContent = `Completed! Processed ${processed} of ${total} files.`;

            setTimeout(() => {
                this.processingStatus.classList.remove('active');
                this.processingBarFill.style.width = '0%';
            }, 2000);

            await this.loadCorpus();
            this.fileInput.value = '';
        }

        async handleChatAttachment(event) {
            const file = event.target.files[0];
            if (!file) return;

            const ext = (file.name.split('.').pop() || '').toLowerCase();
            const supportedTypes = ['pdf', 'docx', 'txt', 'csv', 'xlsx', 'md'];
            const legacyTypes = ['doc', 'xls'];

            if (legacyTypes.includes(ext)) {
                this.showToast(`.${ext} is not supported in-browser. Convert to ${ext === 'doc' ? 'DOCX' : 'XLSX'} first.`, 'warning');
                this.chatFileInput.value = '';
                return;
            }

            if (!supportedTypes.includes(ext)) {
                this.showToast('Unsupported file type. Supported: PDF, DOCX, TXT, CSV, XLSX, MD', 'error');
                this.chatFileInput.value = '';
                return;
            }

            try {
                this.showToast('Processing attachment...', 'info');
                const result = await this.processor.processFile(file);
                const wordCount = result.memory?.wordCount || result.fullText.split(/\s+/).filter(Boolean).length;

                this.currentAttachment = {
                    name: file.name,
                    chunks: result.chunks,
                    memory: result.memory,
                    type: ext,
                    wordCount
                };

                this.attachmentName.textContent = file.name;
                this.attachmentMeta.textContent = `${wordCount.toLocaleString()} words - Temporary analysis (not saved to corpus)`;
                this.attachmentPreview.classList.add('active');

                this.showToast(`Attached: ${file.name}`, 'success');
            } catch (error) {
                console.error('Attachment processing error:', error);
                this.showToast(`Failed to process attachment: ${error.message}`, 'error');
            }

            this.chatFileInput.value = '';
        }

        removeChatAttachment() {
            this.currentAttachment = null;
            this.attachmentPreview.classList.remove('active');
            this.chatFileInput.value = '';
        }

        async deleteDocument(id) {
            if (confirm('Are you sure you want to delete this document?')) {
                await this.db.deleteDocument(id);
                await this.loadCorpus();
                this.showToast('Document deleted', 'success');
            }
        }

        async rebuildIndex() {
            this.showToast('Rebuilding index...', 'info');
            await this.loadCorpus();
            this.showToast('Index rebuilt successfully', 'success');
        }

        async clearCorpus() {
            if (confirm('Are you sure you want to delete ALL documents? This cannot be undone.')) {
                await this.db.clearAll();
                await this.loadCorpus();
                this.showToast('All documents cleared', 'success');
            }
        }

        clearChatHistory() {
            if (confirm('Clear all chat history?')) {
                this.synthesizer.clearHistory();
                this.chatMessages.innerHTML = `
                    <div class="message system">
                        Chat history cleared. Upload documents via the Admin Panel (Ctrl+Shift+A), then ask questions.
                        You can also attach files directly for one-time analysis.
                    </div>
                `;
                this.showToast('Chat history cleared', 'success');
            }
        }

        restoreChatHistory() {
            const history = this.synthesizer.conversationHistory;
            if (history.length === 0) return;
            for (const msg of history) {
                this.addMessage(msg.content, msg.role);
            }
        }

        setSynthesisMessage(isBroadCoverage) {
            this.synthesisIndicatorText.textContent = isBroadCoverage
                ? 'Running deep coverage synthesis across long context...'
                : this.defaultSynthesisText;
        }

        async sendMessage() {
            const query = this.chatInput.value.trim();
            if (!query) return;

            if (!this.synthesizer.apiKey) {
                this.showToast('Please configure your OpenAI API key in the Admin Panel', 'error');
                this.toggleAdminPanel(true);
                return;
            }

            const hasCorpus = this.retriever.allChunks.length > 0;
            const hasAttachment = this.currentAttachment !== null;

            if (!hasCorpus && !hasAttachment) {
                this.showToast('Please upload documents via Admin Panel or attach a file for analysis', 'warning');
                return;
            }

            let displayMessage = this.escapeHtml(query);
            if (hasAttachment) {
                displayMessage = `<div class="attachment-indicator">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                    </svg>
                    <span>${this.escapeHtml(this.currentAttachment.name)}</span>
                </div>
                ${displayMessage}`;
            }

            this.addMessage(displayMessage, 'user');
            this.chatInput.value = '';
            this.sendBtn.disabled = true;

            const intent = this.retriever.detectQueryIntent(query);
            this.setSynthesisMessage(intent.broadCoverage);
            this.synthesisIndicator.classList.add('active');

            try {
                let relevantChunks = hasCorpus
                    ? await this.retriever.retrieve(query, null, { intent })
                    : [];

                let attachmentContext = null;
                if (hasAttachment) {
                    const broadCoverage = intent.broadCoverage || (this.currentAttachment.wordCount >= LONG_DOC_WORD_THRESHOLD);
                    const attachmentChunks = await this.retriever.retrieveFromChunks(
                        query,
                        this.currentAttachment.chunks,
                        broadCoverage ? 20 : 12,
                        { intent: { ...intent, broadCoverage } }
                    );

                    attachmentContext = {
                        name: this.currentAttachment.name,
                        chunks: attachmentChunks,
                        memory: this.currentAttachment.memory,
                        digest: broadCoverage
                            ? this.retriever.buildAttachmentDigest(query, this.currentAttachment.chunks, 16)
                            : '',
                        isTemporary: true
                    };
                }

                const relevantFilenames = new Set(relevantChunks.map(chunk => chunk.filename));
                const documentMemories = this.retriever.documents
                    .filter(doc => relevantFilenames.has(doc.filename))
                    .slice(0, 10)
                    .map(doc => ({
                        filename: doc.filename,
                        memory: doc.memory
                    }));

                const corpusStats = {
                    numDocs: this.retriever.documents.length,
                    numChunks: this.retriever.allChunks.length,
                    connectedConcepts: this.retriever.getTopConnectedConcepts(10),
                    documentMemories,
                    corpusDigest: intent.broadCoverage
                        ? this.retriever.buildCorpusDigest(query, relevantChunks, 16)
                        : ''
                };

                const result = await this.synthesizer.synthesize(query, relevantChunks, attachmentContext, corpusStats);
                this.addMessage(result.response, 'assistant', result.sources);

                if (this.evaluator) {
                    const evaluation = this.evaluator.evaluateTurn(
                        query,
                        result.response,
                        result.sources,
                        result.meta?.instructionProfile || {},
                        result.meta?.claimDiagnostics || null
                    );

                    const scorePct = (evaluation.metrics.overall * 100).toFixed(1);
                    const toastType = evaluation.metrics.overall >= 0.82 ? 'success' :
                        evaluation.metrics.overall >= 0.65 ? 'info' : 'warning';
                    this.showToast(
                        `Eval score ${scorePct}% (coverage ${(evaluation.metrics.coverage * 100).toFixed(0)}%, citations ${(evaluation.metrics.citationPrecision * 100).toFixed(0)}%)`,
                        toastType
                    );
                }
            } catch (error) {
                console.error('Error:', error);
                this.addMessage(
                    `I encountered an error: ${this.escapeHtml(error.message)}. Please check your API key/model and try again.`,
                    'system'
                );
            } finally {
                this.sendBtn.disabled = false;
                this.synthesisIndicator.classList.remove('active');
                this.setSynthesisMessage(false);
                this.removeChatAttachment();
            }
        }

        runEvaluationHarness() {
            const summary = this.evaluator?.getRecentSummary(10);
            if (!summary) {
                this.showToast('No evaluation data yet. Ask at least one question first.', 'warning');
                return;
            }

            const avg = summary.averages;
            const message = [
                `Eval Harness (last ${summary.sampleSize} turns):`,
                `Overall: ${(avg.overall * 100).toFixed(1)}%`,
                `Coverage: ${(avg.coverage * 100).toFixed(1)}%`,
                `Claim citation coverage: ${(avg.citationCoverage * 100).toFixed(1)}%`,
                `Citation precision: ${(avg.citationPrecision * 100).toFixed(1)}%`,
                `Instruction adherence: ${(avg.instructionAdherence * 100).toFixed(1)}%`
            ].join(' ');

            this.addMessage(message, 'system');
            this.showToast(`Eval harness completed: ${(avg.overall * 100).toFixed(1)}% overall`, 'info');
        }

        escapeHtml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        normalizeAssistantForDisplay(text) {
            return String(text || '')
                .replace(/\r\n/g, '\n')
                .replace(/[\u200B-\u200D\uFEFF]/g, '')
                .replace(/[“”]/g, '"')
                .replace(/[‘’]/g, "'")
                .replace(/^[\t ]*[•◦▪●]\s*/gm, '- ')
                .replace(/[—–]/g, '-')
                .replace(/\p{Extended_Pictographic}/gu, '')
                .replace(/[^\S\r\n]+\n/g, '\n')
                .replace(/\n{3,}/g, '\n\n')
                .replace(/[ \t]{2,}/g, ' ')
                .trim();
        }

        renderMarkdownLite(escapedText) {
            let text = escapedText
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');

            const lines = text.split('\n');
            let html = '';
            let inUl = false;
            let inOl = false;

            const closeLists = () => {
                if (inUl) { html += '</ul>'; inUl = false; }
                if (inOl) { html += '</ol>'; inOl = false; }
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) {
                    closeLists();
                    continue;
                }

                const ulMatch = line.match(/^- (.+)$/);
                const olMatch = line.match(/^\d+\. (.+)$/);

                if (ulMatch) {
                    if (!inUl) {
                        closeLists();
                        html += '<ul>';
                        inUl = true;
                    }
                    html += `<li>${ulMatch[1]}</li>`;
                    continue;
                }

                if (olMatch) {
                    if (!inOl) {
                        closeLists();
                        html += '<ol>';
                        inOl = true;
                    }
                    html += `<li>${olMatch[1]}</li>`;
                    continue;
                }

                closeLists();
                html += `<p>${line}</p>`;
            }

            closeLists();
            return html || '<p></p>';
        }

        formatCitations(content, sources) {
            const normalizedContent = this.normalizeAssistantForDisplay(content);
            const citationRegex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citationTokens = [];
            let tokenized = normalizedContent.replace(citationRegex, (match, filename, page, quote) => {
                const token = `__CITATION_${citationTokens.length}__`;
                citationTokens.push({
                    token,
                    filename: String(filename || '').trim(),
                    page: String(page || '').trim(),
                    quote: String(quote || '').trim()
                });
                return token;
            });

            tokenized = this.escapeHtml(tokenized);
            let rendered = this.renderMarkdownLite(tokenized);

            for (const citation of citationTokens) {
                const sourceInfo = `${citation.filename}, Page ${citation.page}`;
                const html = `<span class="citation" data-source="${this.escapeHtml(sourceInfo)}" data-text="${this.escapeHtml(citation.quote)}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                    </svg>
                    ${this.escapeHtml(citation.filename).slice(0, 20)}...
                </span>`;
                rendered = rendered.replace(citation.token, html);
            }

            return rendered;
        }

        addMessage(content, role, sources = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            let processedContent = content;
            if (role === 'assistant') {
                processedContent = this.formatCitations(content, sources);
            } else if (role === 'system') {
                processedContent = `<p>${this.escapeHtml(content)}</p>`;
            }

            messageDiv.innerHTML = processedContent;
            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;

            if (role === 'assistant') {
                messageDiv.querySelectorAll('.citation').forEach(citation => {
                    citation.addEventListener('click', () => {
                        const source = citation.dataset.source;
                        const text = citation.dataset.text;
                        this.showCitation(source, text);
                    });
                });
            }
        }

        showCitation(source, text) {
            this.citationSource.textContent = source;
            this.citationText.textContent = text;
            this.citationModal.classList.add('active');
        }

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            const safe = this.escapeHtml(message);
            toast.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${type === 'success' ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22,4 12,14.01 9,11.01"/>' :
                      type === 'error' ? '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>' :
                      type === 'warning' ? '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>' :
                      '<circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>'}
                </svg>
                <span>${safe}</span>
            `;

            this.toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }
    }

    let app;

    async function initializeApp() {
        try {
            const db = new DocumentDatabase();
            await db.init();

            const processor = new DocumentProcessor();
            const retriever = new CognitiveRetriever();
            const synthesizer = new CognitiveSynthesizer();
            const evaluator = new QualityEvaluator();

            retriever.setEmbeddingApiKey(synthesizer.apiKey);
            app = new UIController(db, processor, retriever, synthesizer, evaluator);
            window.app = app;

            console.log('Cognitive Synthesis Engine initialized successfully');
        } catch (error) {
            console.error('Failed to initialize application:', error);
            alert('Failed to initialize the application. Please refresh the page.');
        }
    }

    document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
