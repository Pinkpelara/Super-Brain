<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UofT Cognitive Synthesis Engine</title>
    <style>
        :root {
            --primary: #002A5C;
            --primary-light: #003d82;
            --secondary: #FFE498;
            --accent: #008BB0;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header h1 svg {
            width: 32px;
            height: 32px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .header-btn svg {
            width: 18px;
            height: 18px;
        }

        .brain-badge {
            background: var(--secondary);
            color: var(--primary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 1.5rem;
            gap: 1.5rem;
        }

        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-info h2 {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .chat-header-info p {
            font-size: 0.8rem;
            opacity: 0.85;
            margin-top: 0.25rem;
        }

        .chat-header-actions {
            display: flex;
            gap: 0.5rem;
        }

        .chat-action-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-action-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 400px;
            max-height: calc(100vh - 350px);
        }

        .message {
            max-width: 85%;
            padding: 1rem 1.25rem;
            border-radius: 12px;
            line-height: 1.6;
            font-size: 0.95rem;
        }

        .message.user {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            align-self: flex-start;
            background: var(--bg);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .message.system {
            align-self: center;
            background: var(--secondary);
            color: var(--primary);
            font-size: 0.85rem;
            text-align: center;
            max-width: 100%;
        }

        .attachment-indicator {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            opacity: 0.9;
            padding: 0.25rem 0.5rem;
            background: rgba(255,255,255,0.15);
            border-radius: 4px;
            margin-bottom: 0.5rem;
            width: fit-content;
        }

        .attachment-indicator svg {
            flex-shrink: 0;
        }

        .citation {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: var(--accent);
            color: white;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0.15rem 0;
        }

        .citation:hover {
            background: var(--primary);
            transform: translateY(-1px);
        }

        .citation svg {
            width: 12px;
            height: 12px;
        }

        .chat-input-container {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            background: var(--bg);
        }

        .attachment-preview {
            display: none;
            padding: 0.75rem 1rem;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            align-items: center;
            gap: 0.75rem;
        }

        .attachment-preview.active {
            display: flex;
        }

        .attachment-preview-icon {
            width: 36px;
            height: 36px;
            background: var(--accent);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .attachment-preview-icon svg {
            width: 20px;
            height: 20px;
        }

        .attachment-preview-info {
            flex: 1;
        }

        .attachment-preview-name {
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text);
        }

        .attachment-preview-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .attachment-preview-remove {
            padding: 0.25rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .attachment-preview-remove:hover {
            background: #fee2e2;
            color: var(--error);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 0.75rem;
        }

        .attach-btn {
            padding: 0.875rem;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
        }

        .attach-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: white;
        }

        .attach-btn svg {
            width: 20px;
            height: 20px;
        }

        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
            resize: none;
            font-family: inherit;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .send-btn {
            padding: 0.875rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--primary-light);
            transform: translateY(-1px);
        }

        .send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .corpus-sidebar {
            width: 320px;
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .corpus-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }

        .corpus-header h3 {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .corpus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .corpus-stats span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .corpus-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
            max-height: 300px;
        }

        .corpus-item {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .corpus-item-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            overflow: hidden;
        }

        .corpus-item-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .corpus-item-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .corpus-item-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .corpus-item-delete:hover {
            color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .corpus-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .admin-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .admin-panel.active {
            display: flex;
        }

        .admin-content {
            background: var(--card);
            border-radius: 16px;
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        }

        .admin-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--primary);
            color: white;
        }

        .admin-header h2 {
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .admin-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .admin-close:hover {
            background: rgba(255,255,255,0.1);
        }

        .admin-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: var(--bg);
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(0, 139, 176, 0.05);
        }

        .upload-zone svg {
            width: 48px;
            height: 48px;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .upload-zone h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .upload-zone p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .upload-zone .file-types {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .api-section {
            margin-top: 1.5rem;
            padding: 1.25rem;
            background: var(--bg);
            border-radius: 8px;
        }

        .api-section h4 {
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .api-input-group {
            display: flex;
            gap: 0.75rem;
        }

        .api-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: monospace;
        }

        .api-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .api-save-btn {
            padding: 0.75rem 1.25rem;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .api-save-btn:hover {
            background: #059669;
        }

        .model-section {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 139, 176, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(0, 139, 176, 0.2);
        }

        .model-section h4 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }

        .model-select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }

        .model-note {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .admin-actions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .admin-action-btn {
            padding: 0.75rem 1.25rem;
            border: 1px solid var(--border);
            background: var(--card);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .admin-action-btn:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .admin-action-btn.danger {
            color: var(--error);
            border-color: var(--error);
        }

        .admin-action-btn.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .processing-status {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 139, 176, 0.1);
            border-radius: 8px;
            display: none;
        }

        .processing-status.active {
            display: block;
        }

        .processing-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.75rem;
        }

        .processing-bar-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .citation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        .citation-modal.active {
            display: flex;
        }

        .citation-content {
            background: var(--card);
            border-radius: 12px;
            width: 100%;
            max-width: 600px;
            max-height: 70vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .citation-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--accent);
            color: white;
        }

        .citation-header h3 {
            font-size: 1rem;
        }

        .citation-body {
            padding: 1.25rem;
            overflow-y: auto;
        }

        .citation-source {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .citation-text {
            background: var(--bg);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.7;
            border-left: 3px solid var(--accent);
        }

        .toast-container {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 1002;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toast {
            padding: 1rem 1.25rem;
            background: var(--card);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
            max-width: 350px;
        }

        .toast.success { border-left: 4px solid var(--success); }
        .toast.error { border-left: 4px solid var(--error); }
        .toast.warning { border-left: 4px solid var(--warning); }
        .toast.info { border-left: 4px solid var(--accent); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }
            .corpus-sidebar {
                width: 100%;
            }
        }

        .keyboard-hint {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            background: var(--card);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .keyboard-hint kbd {
            background: var(--bg);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-family: monospace;
            border: 1px solid var(--border);
        }

        .synthesis-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 139, 176, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            color: var(--accent);
        }

        .synthesis-indicator.active {
            display: flex;
        }

        .synthesis-indicator .pulse {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .message.assistant p { margin-bottom: 0.6rem; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant ul, .message.assistant ol {
            margin: 0.4rem 0 0.7rem 1.3rem;
        }
        .message.assistant li { margin-bottom: 0.2rem; }
        .message.assistant strong { font-weight: 600; }
        .message.assistant em { font-style: italic; }
        .message.assistant code {
            background: rgba(0,0,0,0.05);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2a9 9 0 0 0-9 9c0 3.6 2.4 6.9 6 8.5V22h6v-2.5c3.6-1.6 6-4.9 6-8.5a9 9 0 0 0-9-9z"/>
                <path d="M12 6v6l4 2"/>
            </svg>
            UofT Cognitive Synthesis Engine
        </h1>
        <div class="header-actions">
            <span class="brain-badge">Brain-Aligned RAG</span>
            <button class="header-btn" id="openAdminBtn" title="Open Admin Panel (Ctrl+Shift+A)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
                Admin Panel
            </button>
        </div>
    </header>

    <div class="main-container">
        <section class="chat-section">
            <div class="chat-header">
                <div class="chat-header-info">
                    <h2>Knowledge Synthesis Interface</h2>
                    <p>Ask questions to synthesize insights across your document corpus</p>
                </div>
                <div class="chat-header-actions">
                    <button class="chat-action-btn" id="clearChatBtn" title="Clear Chat History">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3,6 5,6 21,6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    Welcome! This engine performs <strong>cognitive synthesis</strong> by combining broad coverage retrieval, concept links, and instruction-aware response formatting.
                    <br><br>
                    Click the <strong>Admin Panel</strong> button (or press Ctrl+Shift+A) to upload documents and configure your API key.
                    <br><br>
                    You can also attach files directly to your messages for one-time analysis (not saved to corpus).
                </div>
            </div>

            <div class="synthesis-indicator" id="synthesisIndicator">
                <div class="pulse"></div>
                <span id="synthesisIndicatorText">Building mental model and synthesizing across documents...</span>
            </div>

            <div class="chat-input-container">
                <div class="attachment-preview" id="attachmentPreview">
                    <div class="attachment-preview-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                            <polyline points="14,2 14,8 20,8"/>
                        </svg>
                    </div>
                    <div class="attachment-preview-info">
                        <div class="attachment-preview-name" id="attachmentName">document.pdf</div>
                        <div class="attachment-preview-meta" id="attachmentMeta">Temporary analysis - not saved to corpus</div>
                    </div>
                    <button class="attachment-preview-remove" id="attachmentRemove" title="Remove attachment">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
                <input type="file" id="chatFileInput" accept=".pdf,.docx,.txt,.csv,.xlsx,.md" style="display:none;">
                <div class="chat-input-wrapper">
                    <button class="attach-btn" id="chatAttachBtn" title="Attach file for analysis (not saved to corpus)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                        </svg>
                    </button>
                    <textarea
                        class="chat-input"
                        id="chatInput"
                        placeholder="Ask a question to synthesize knowledge from your documents..."
                        rows="2"
                    ></textarea>
                    <button class="send-btn" id="sendBtn">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                        </svg>
                        Send
                    </button>
                </div>
            </div>
        </section>

        <aside class="corpus-sidebar">
            <div class="corpus-header">
                <h3>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                    </svg>
                    Document Corpus
                </h3>
                <div class="corpus-stats">
                    <span id="docCount">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        </svg>
                        0 documents
                    </span>
                    <span id="chunkCount">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="7" height="7"/>
                            <rect x="14" y="3" width="7" height="7"/>
                            <rect x="3" y="14" width="7" height="7"/>
                            <rect x="14" y="14" width="7" height="7"/>
                        </svg>
                        0 knowledge chunks
                    </span>
                </div>
            </div>
            <div class="corpus-list" id="corpusList">
                <div class="corpus-empty">
                    No documents uploaded yet.<br>
                    Press <kbd>Ctrl+Shift+A</kbd> to open Admin Panel.
                </div>
            </div>
        </aside>
    </div>

    <div class="admin-panel" id="adminPanel">
        <div class="admin-content">
            <div class="admin-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    Admin Panel
                </h2>
                <button class="admin-close" id="adminClose">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>

            <div class="admin-body">
                <div class="api-section">
                    <h4>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/>
                        </svg>
                        OpenAI API Key
                    </h4>
                    <div class="api-input-group">
                        <input type="password" class="api-input" id="apiKeyInput" placeholder="sk-...">
                        <button class="api-save-btn" id="saveApiKey">Save Key</button>
                    </div>
                    <div class="model-section">
                        <h4>Model Selection</h4>
                        <select class="model-select" id="modelSelect">
                            <option value="gpt-4.1">GPT-4.1 (Best synthesis quality)</option>
                            <option value="gpt-4o">GPT-4o (Balanced)</option>
                            <option value="gpt-4o-mini">GPT-4o mini (Faster)</option>
                        </select>
                        <p class="model-note">For long-document synthesis, use GPT-4.1 or GPT-4o. The engine applies multi-stage retrieval + memory to improve brain-like integration.</p>
                    </div>
                </div>

                <div class="upload-zone" id="uploadZone">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17,8 12,3 7,8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <h3>Drag & Drop Documents</h3>
                    <p>Or click to select files for permanent corpus</p>
                    <div class="file-types">Supported: PDF, DOCX, XLSX, TXT, CSV, MD</div>
                    <input type="file" id="fileInput" multiple accept=".pdf,.docx,.xlsx,.txt,.csv,.md" style="display:none;">
                </div>

                <div class="processing-status" id="processingStatus">
                    <div id="processingText">Processing documents...</div>
                    <div class="processing-bar">
                        <div class="processing-bar-fill" id="processingBarFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="admin-actions">
                    <button class="admin-action-btn" id="rebuildIndex">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="23,4 23,10 17,10"/>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                        </svg>
                        Rebuild Index
                    </button>
                    <button class="admin-action-btn danger" id="clearCorpus">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3,6 5,6 21,6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                        Clear All Documents
                    </button>
                    <button class="admin-action-btn" id="clearChatAdmin">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            <line x1="9" y1="9" x2="15" y2="9"/>
                            <line x1="9" y1="13" x2="15" y2="13"/>
                        </svg>
                        Clear Chat History
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="citation-modal" id="citationModal">
        <div class="citation-content">
            <div class="citation-header">
                <h3>Source Citation</h3>
                <button class="admin-close" id="citationClose">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="citation-body">
                <div class="citation-source" id="citationSource"></div>
                <div class="citation-text" id="citationText"></div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <div class="keyboard-hint">
        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>A</kbd> Admin Panel
    </div>

    <script>
    const DB_NAME = 'CognitiveSynthesisDB';
    const DB_VERSION = 2;
    const STORE_NAME = 'documents';

    const LONG_DOC_WORD_THRESHOLD = 12000;
    const MAX_CONTEXT_CHARS = 90000;
    const RETRIEVAL_LOW_SCORE_THRESHOLD = 0.18;
    const REFUSAL_PATTERNS = [
        /cannot\s+(?:directly\s+)?access/i,
        /outside of (?:the )?provided excerpts/i,
        /training cut[- ]?off/i,
        /cannot review documents outside/i,
        /i do not have access to your document/i
    ];

    class DocumentDatabase {
        constructor() {
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    this.db = request.result;
                    resolve(this.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('filename', 'filename', { unique: false });
                        store.createIndex('type', 'type', { unique: false });
                    }
                };
            });
        }

        async addDocument(doc) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.add(doc);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getAllDocuments() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async deleteDocument(id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async clearAll() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }

    class DocumentProcessor {
        constructor() {
            this.stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                'this', 'that', 'these', 'those', 'what', 'which', 'who', 'when',
                'where', 'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more',
                'most', 'other', 'some', 'such', 'than', 'too', 'very', 'just', 'also',
                'into', 'about', 'over', 'under', 'through', 'across'
            ]);

            this.unsupportedLegacyExtensions = new Set(['doc', 'xls']);
            this.supportedExtensions = new Set(['pdf', 'docx', 'xlsx', 'txt', 'csv', 'md']);

            this.mimeProcessors = {
                'application/pdf': this.processPDF.bind(this),
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': this.processDOCX.bind(this),
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': this.processXLSX.bind(this),
                'text/plain': this.processText.bind(this),
                'text/csv': this.processCSV.bind(this),
                'text/markdown': this.processText.bind(this)
            };

            this.extensionProcessors = {
                'pdf': this.processPDF.bind(this),
                'docx': this.processDOCX.bind(this),
                'xlsx': this.processXLSX.bind(this),
                'txt': this.processText.bind(this),
                'csv': this.processCSV.bind(this),
                'md': this.processText.bind(this)
            };
        }

        getExtension(filename = '') {
            const parts = filename.split('.');
            if (parts.length < 2) return '';
            return parts.pop().toLowerCase();
        }

        resolveProcessor(file, extension) {
            return this.extensionProcessors[extension] || this.mimeProcessors[file.type] || this.processText.bind(this);
        }

        normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\u0000/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/[^\S\n]+/g, ' ')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
        }

        splitIntoSentences(text) {
            return text
                .split(/(?<=[.!?])\s+(?=[A-Z0-9"“'`])/)
                .map(s => s.trim())
                .filter(Boolean);
        }

        tokenizeForMemory(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.stopWords.has(token));
        }

        extractHeadings(text) {
            const lines = text.split('\n');
            const headings = [];

            for (const lineRaw of lines) {
                const line = lineRaw.trim();
                if (!line || line.length > 120) continue;
                if (/^\[Page\s+\d+\]$/i.test(line)) {
                    headings.push(line);
                    continue;
                }

                const markdownHeading = /^#{1,6}\s+(.+)$/;
                const numberedHeading = /^\d+(\.\d+){0,3}\s+[A-Z]/;
                const titleCaseHeading = /^[A-Z][A-Za-z0-9\s,:;()/-]{4,}$/;

                if (markdownHeading.test(line) || numberedHeading.test(line) || titleCaseHeading.test(line)) {
                    if (!/[.!?]$/.test(line)) {
                        headings.push(line.replace(/^#{1,6}\s*/, ''));
                    }
                }
            }

            return Array.from(new Set(headings)).slice(0, 24);
        }

        isLikelyHeading(line) {
            if (!line) return false;
            if (line.length < 4 || line.length > 120) return false;
            if (/^[\[\](){}]/.test(line)) return false;
            if (/[.!?]$/.test(line)) return false;
            if (/^[-*•]/.test(line)) return false;
            if (/^\d+$/.test(line)) return false;
            return (
                /^#{1,6}\s+/.test(line) ||
                /^\d+(\.\d+){0,3}\s+[A-Z]/.test(line) ||
                /^[A-Z][A-Za-z0-9\s,:;()/-]+$/.test(line)
            );
        }

        splitLargeParagraph(paragraph, maxChars = 1500) {
            const cleaned = paragraph.trim();
            if (!cleaned) return [];
            if (cleaned.length <= maxChars) return [cleaned];

            const sentences = this.splitIntoSentences(cleaned);
            if (sentences.length <= 1) {
                const chunks = [];
                for (let i = 0; i < cleaned.length; i += maxChars) {
                    chunks.push(cleaned.slice(i, i + maxChars));
                }
                return chunks;
            }

            const result = [];
            let current = '';

            for (const sentence of sentences) {
                const candidate = current ? `${current} ${sentence}` : sentence;
                if (candidate.length > maxChars && current) {
                    result.push(current.trim());
                    current = sentence;
                } else if (sentence.length > maxChars) {
                    const hardSplit = this.splitLargeParagraph(sentence, maxChars);
                    if (current) {
                        result.push(current.trim());
                        current = '';
                    }
                    result.push(...hardSplit);
                } else {
                    current = candidate;
                }
            }

            if (current.trim()) result.push(current.trim());
            return result;
        }

        getOverlapTail(text, overlapChars = 260) {
            if (!text || text.length <= overlapChars) return text;
            const tail = text.slice(-overlapChars);
            const boundary = tail.search(/[.!?]\s+[A-Z]/);
            if (boundary > 0) {
                return tail.slice(boundary + 2).trim();
            }
            return tail.trim();
        }

        splitIntoSections(text) {
            const sections = [];
            const lines = text.split('\n');
            let currentTitle = 'Document';
            let currentPage = null;
            let buffer = [];

            const flush = () => {
                const content = buffer.join('\n').trim();
                if (content) {
                    sections.push({
                        title: currentTitle,
                        page: currentPage,
                        content
                    });
                }
                buffer = [];
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                const pageMatch = line.match(/^\[Page\s+(\d+)\]$/i);
                if (pageMatch) {
                    flush();
                    currentPage = parseInt(pageMatch[1], 10);
                    currentTitle = `Page ${currentPage}`;
                    continue;
                }

                if (this.isLikelyHeading(line) && buffer.join('\n').length > 700) {
                    flush();
                    currentTitle = line.replace(/^#{1,6}\s*/, '');
                    continue;
                }

                buffer.push(rawLine);
            }

            flush();
            return sections.length ? sections : [{ title: 'Document', page: null, content: text }];
        }

        extractPageFromText(text) {
            const match = text.match(/\[Page\s+(\d+)\]/i);
            return match ? parseInt(match[1], 10) : null;
        }

        scoreSentence(sentence, conceptSet) {
            const words = sentence.toLowerCase().match(/\b[a-z][a-z0-9-]+\b/g) || [];
            let score = 0;

            for (const word of words) {
                if (conceptSet.has(word)) score += 1;
            }

            if (/\d/.test(sentence)) score += 0.7;
            if (/[A-Z][a-z]+ [A-Z][a-z]+/.test(sentence)) score += 0.6;
            if (sentence.length >= 60 && sentence.length <= 260) score += 0.5;
            return score;
        }

        buildDocumentMemory(text, chunks, filename) {
            const words = text.split(/\s+/).filter(Boolean);
            const wordCount = words.length;
            const readingTimeMinutes = Math.max(1, Math.round(wordCount / 220));

            const headings = this.extractHeadings(text);
            const tokens = this.tokenizeForMemory(text);
            const frequencies = new Map();
            for (const token of tokens) {
                frequencies.set(token, (frequencies.get(token) || 0) + 1);
            }

            const keyConcepts = Array.from(frequencies.entries())
                .filter(([, count]) => count > 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 18)
                .map(([token]) => token);

            const conceptSet = new Set(keyConcepts);
            const sentences = this.splitIntoSentences(text)
                .filter(sentence => sentence.length >= 35 && sentence.length <= 320);
            const everyNth = Math.max(1, Math.floor(sentences.length / 14));
            const scored = sentences.map((sentence, idx) => ({
                sentence,
                score: this.scoreSentence(sentence, conceptSet) + ((idx % everyNth === 0) ? 0.3 : 0)
            }));

            const salientSentences = scored
                .sort((a, b) => b.score - a.score)
                .slice(0, 14)
                .map(item => item.sentence.trim());

            const synopsis = salientSentences.slice(0, 6).join(' ').trim();

            return {
                filename,
                wordCount,
                chunkCount: chunks.length,
                readingTimeMinutes,
                outline: headings,
                keyConcepts,
                salientSentences,
                synopsis
            };
        }

        intelligentChunk(text, filename, baseChunkSize = 1800, overlap = 260) {
            const cleaned = this.normalizeText(text);
            if (!cleaned) return [];

            const dynamicChunkSize = cleaned.length > 350000 ? 2400 :
                cleaned.length > 150000 ? 2100 :
                cleaned.length > 50000 ? 1900 : baseChunkSize;

            const sections = this.splitIntoSections(cleaned);
            const chunks = [];
            let chunkIndex = 0;

            for (const section of sections) {
                const paragraphs = section.content
                    .split(/\n{2,}/)
                    .map(p => p.trim())
                    .filter(Boolean);

                let current = section.title ? `${section.title}\n` : '';
                let currentPage = section.page || null;

                const pushChunk = () => {
                    const chunkText = current.trim();
                    if (!chunkText) return;
                    chunks.push({
                        id: `${filename}-chunk-${chunkIndex}`,
                        text: chunkText,
                        filename,
                        section: section.title || 'Document',
                        page: currentPage || this.extractPageFromText(chunkText),
                        index: chunkIndex,
                        preview: chunkText.replace(/\s+/g, ' ').slice(0, 120) + (chunkText.length > 120 ? '...' : '')
                    });
                    chunkIndex++;
                };

                for (const paragraph of paragraphs) {
                    const pageInParagraph = paragraph.match(/\[Page\s+(\d+)\]/i);
                    if (pageInParagraph) {
                        currentPage = parseInt(pageInParagraph[1], 10);
                    }

                    const units = this.splitLargeParagraph(paragraph, Math.floor(dynamicChunkSize * 0.9));
                    for (const unit of units) {
                        const candidate = current ? `${current}\n\n${unit}` : unit;
                        if (candidate.length > dynamicChunkSize && current.trim()) {
                            pushChunk();
                            const overlapText = this.getOverlapTail(current, overlap);
                            current = overlapText ? `${overlapText}\n\n${unit}` : unit;
                        } else if (candidate.length > dynamicChunkSize && !current.trim()) {
                            const hardUnits = this.splitLargeParagraph(unit, Math.floor(dynamicChunkSize * 0.8));
                            for (const hardUnit of hardUnits) {
                                current = hardUnit;
                                pushChunk();
                                current = '';
                            }
                        } else {
                            current = candidate;
                        }
                    }
                }

                if (current.trim()) {
                    pushChunk();
                }
            }

            return chunks;
        }

        async processFile(file) {
            const extension = this.getExtension(file.name);
            if (this.unsupportedLegacyExtensions.has(extension)) {
                throw new Error(`Legacy ${extension.toUpperCase()} is not supported in-browser. Convert to DOCX or XLSX first.`);
            }

            if (!this.supportedExtensions.has(extension)) {
                throw new Error(`Unsupported file type: .${extension || 'unknown'}`);
            }

            const processor = this.resolveProcessor(file, extension);
            const extracted = await processor(file);
            const text = this.normalizeText(extracted);

            if (!text || text.length < 20) {
                throw new Error(`Could not extract readable text from ${file.name}.`);
            }

            const chunks = this.intelligentChunk(text, file.name);
            const memory = this.buildDocumentMemory(text, chunks, file.name);

            return {
                filename: file.name,
                type: file.type || extension,
                extension,
                size: file.size,
                uploadedAt: new Date().toISOString(),
                fullText: text,
                chunks,
                memory
            };
        }

        async processText(file) {
            return await file.text();
        }

        async processCSV(file) {
            const text = await file.text();
            const lines = text.split('\n');
            let formatted = `CSV Data from ${file.name}:\n\n`;

            if (lines.length > 0) {
                const headers = lines[0].split(',').map(h => h.trim());
                formatted += `Columns: ${headers.join(', ')}\n\n`;

                for (let i = 1; i < Math.min(lines.length, 300); i++) {
                    const values = lines[i].split(',');
                    if (!values.some(value => value.trim())) continue;
                    formatted += `Row ${i}: `;
                    headers.forEach((header, idx) => {
                        if (values[idx] && values[idx].trim()) {
                            formatted += `${header}: ${values[idx].trim()}; `;
                        }
                    });
                    formatted += '\n';
                }
            }

            return formatted;
        }

        async processPDF(file) {
            if (typeof pdfjsLib === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js');
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += `[Page ${i}]\n${pageText}\n\n`;
            }

            return fullText;
        }

        async processDOCX(file) {
            if (typeof mammoth === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js');
            }

            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        async processXLSX(file) {
            if (typeof XLSX === 'undefined') {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
            }

            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            let fullText = '';

            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                fullText += `[Sheet: ${sheetName}]\n`;
                jsonData.forEach((row, rowIndex) => {
                    if (row.length > 0) {
                        fullText += `Row ${rowIndex + 1}: ${row.join(' | ')}\n`;
                    }
                });
                fullText += '\n';
            });

            return fullText;
        }

        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    }

    class CognitiveRetriever {
        constructor() {
            this.documents = [];
            this.allChunks = [];
            this.idf = new Map();
            this.avgChunkLength = 1;
            this.chunkTokenCache = new Map();
            this.chunkLookup = new Map();
            this.conceptIndex = new Map();
            this.documentConceptMap = new Map();
        }

        updateCorpus(documents) {
            this.documents = documents.map(doc => {
                if (doc.memory) return doc;
                return {
                    ...doc,
                    memory: this.deriveMemoryFromChunks(doc)
                };
            });

            this.allChunks = this.documents.flatMap(doc => doc.chunks || []);
            this.chunkLookup = new Map(this.allChunks.map(chunk => [chunk.id, chunk]));
            this.buildTokenStats();
            this.buildConceptIndex();
        }

        deriveMemoryFromChunks(doc) {
            const chunks = doc.chunks || [];
            const previews = chunks.slice(0, 8).map(chunk => chunk.preview || chunk.text.slice(0, 120));
            const synopsis = previews.join(' ');
            return {
                filename: doc.filename,
                wordCount: Math.max(0, Math.round((doc.fullText || '').split(/\s+/).filter(Boolean).length)),
                chunkCount: chunks.length,
                readingTimeMinutes: Math.max(1, Math.round(((doc.fullText || '').split(/\s+/).length || 0) / 220)),
                outline: [],
                keyConcepts: this.extractConcepts((doc.fullText || '').slice(0, 4000)).slice(0, 10),
                salientSentences: previews,
                synopsis
            };
        }

        buildTokenStats() {
            this.idf.clear();
            this.chunkTokenCache.clear();

            if (this.allChunks.length === 0) {
                this.avgChunkLength = 1;
                return;
            }

            const df = new Map();
            let totalLength = 0;

            for (const chunk of this.allChunks) {
                const tokens = this.tokenize(chunk.text);
                const tf = new Map();
                for (const token of tokens) {
                    tf.set(token, (tf.get(token) || 0) + 1);
                }
                this.chunkTokenCache.set(chunk.id, {
                    tokens,
                    tf,
                    length: tokens.length || 1
                });
                totalLength += tokens.length;

                const uniqueTokens = new Set(tokens);
                for (const token of uniqueTokens) {
                    df.set(token, (df.get(token) || 0) + 1);
                }
            }

            this.avgChunkLength = totalLength / Math.max(1, this.allChunks.length);
            const N = this.allChunks.length;

            for (const [token, count] of df.entries()) {
                const idf = Math.log(((N - count + 0.5) / (count + 0.5)) + 1);
                this.idf.set(token, idf);
            }
        }

        buildConceptIndex() {
            this.conceptIndex.clear();
            this.documentConceptMap.clear();

            for (const doc of this.documents) {
                const docConcepts = new Set();
                for (const chunk of (doc.chunks || [])) {
                    const concepts = this.extractKeyConceptsFromChunk(chunk.text);
                    for (const concept of concepts) {
                        docConcepts.add(concept);
                        if (!this.conceptIndex.has(concept)) {
                            this.conceptIndex.set(concept, []);
                        }
                        this.conceptIndex.get(concept).push({
                            docId: doc.id,
                            filename: doc.filename,
                            chunkId: chunk.id
                        });
                    }
                }
                this.documentConceptMap.set(doc.filename, docConcepts);
            }
        }

        detectQueryIntent(query) {
            const q = query.toLowerCase();
            return {
                broadCoverage: /\b(whole|entire|full|overall|comprehensive|big picture|summari[sz]e|main themes|analyze.*document|review.*document)\b/.test(q),
                comparative: /\b(compare|contrast|versus|vs\.?)\b/.test(q),
                extraction: /\b(list|extract|enumerate|all instances|find all)\b/.test(q),
                timeline: /\b(timeline|chronological|over time|sequence)\b/.test(q)
            };
        }

        tokenize(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 2 && !this.isStopWord(token));
        }

        isStopWord(word) {
            const stopWords = new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'this', 'that',
                'these', 'those', 'what', 'which', 'who', 'whom', 'whose', 'when', 'where',
                'why', 'how', 'all', 'each', 'every', 'both', 'few', 'more', 'most', 'other',
                'some', 'such', 'than', 'too', 'very', 'just', 'also', 'into', 'about'
            ]);
            return stopWords.has(word);
        }

        extractEntities(text) {
            const entities = [];
            const capitalizedWords = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
            entities.push(...capitalizedWords.map(e => e.toLowerCase()));
            const numbers = text.match(/\d+(?:\.\d+)?%?/g) || [];
            entities.push(...numbers);
            const dates = text.match(/\d{4}|\d{1,2}\/\d{1,2}\/\d{2,4}/g) || [];
            entities.push(...dates);
            return entities;
        }

        extractConcepts(text) {
            const concepts = [];
            const phrases = text.match(/\b\w+\s+\w+(?:\s+\w+)?\b/g) || [];
            concepts.push(...phrases.map(p => p.toLowerCase()));
            return concepts;
        }

        extractKeyConceptsFromChunk(text) {
            const concepts = new Set();
            const properNouns = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}\b/g) || [];
            properNouns.forEach(p => concepts.add(p.toLowerCase()));
            const technical = text.match(/\b[a-z]+[-_]?[a-z]*\d+[a-z]*\b/gi) || [];
            technical.forEach(t => concepts.add(t.toLowerCase()));
            const quoted = text.match(/"([^"]+)"/g) || [];
            quoted.forEach(q => concepts.add(q.replace(/"/g, '').toLowerCase()));
            return concepts;
        }

        calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts) {
            const cache = this.chunkTokenCache.get(chunk.id) || {
                tokens: this.tokenize(chunk.text),
                tf: new Map(),
                length: 1
            };

            if (cache.tf.size === 0) {
                for (const token of cache.tokens) {
                    cache.tf.set(token, (cache.tf.get(token) || 0) + 1);
                }
            }

            const uniqueQueryTokens = Array.from(new Set(queryTokens));
            const chunkTextLower = chunk.text.toLowerCase();
            const queryTextLower = query.toLowerCase().trim();

            let score = 0;

            if (uniqueQueryTokens.length > 0) {
                const k1 = 1.2;
                const b = 0.75;
                let bm25 = 0;
                let maxIdf = 0;
                for (const token of uniqueQueryTokens) {
                    const tf = cache.tf.get(token) || 0;
                    const idf = this.idf.get(token) || 0.4;
                    maxIdf += idf;
                    if (tf === 0) continue;
                    const numerator = tf * (k1 + 1);
                    const denominator = tf + k1 * (1 - b + b * (cache.length / this.avgChunkLength));
                    bm25 += idf * (numerator / denominator);
                }
                if (maxIdf > 0) {
                    score += (bm25 / maxIdf) * 0.55;
                }
            }

            if (queryTextLower.length > 12 && chunkTextLower.includes(queryTextLower)) {
                score += 0.2;
            }

            if (queryEntities.length > 0) {
                const entityMatches = queryEntities.filter(entity => chunkTextLower.includes(entity.toLowerCase())).length;
                score += (entityMatches / queryEntities.length) * 0.15;
            }

            if (queryConcepts.length > 0) {
                const conceptMatches = queryConcepts.filter(concept => chunkTextLower.includes(concept)).length;
                score += (conceptMatches / queryConcepts.length) * 0.08;
            }

            const tokenMatches = uniqueQueryTokens.filter(token => cache.tf.has(token)).length;
            const density = tokenMatches / Math.max(1, cache.length / 100);
            score += Math.min(density * 0.04, 0.06);

            return score;
        }

        pickEvenlyDistributed(chunks, count) {
            if (!chunks || chunks.length === 0 || count <= 0) return [];
            if (chunks.length <= count) return chunks.slice();

            const selected = [];
            for (let i = 0; i < count; i++) {
                const index = Math.floor((i * (chunks.length - 1)) / Math.max(1, count - 1));
                selected.push(chunks[index]);
            }
            return selected;
        }

        mergeUniqueChunks(primary, additions, limit) {
            const result = [];
            const seen = new Set();

            for (const chunk of [...primary, ...additions]) {
                if (!chunk || seen.has(chunk.id)) continue;
                result.push(chunk);
                seen.add(chunk.id);
                if (result.length >= limit) break;
            }

            return result;
        }

        diversifyResults(scoredChunks, topK) {
            const results = [];
            const seenDocuments = new Map();
            const maxPerDocument = Math.max(2, Math.ceil(topK / 2));

            for (const chunk of scoredChunks) {
                if (results.length >= topK) break;
                const docCount = seenDocuments.get(chunk.filename) || 0;
                if (docCount < maxPerDocument) {
                    results.push(chunk);
                    seenDocuments.set(chunk.filename, docCount + 1);
                }
            }

            if (results.length < topK) {
                for (const chunk of scoredChunks) {
                    if (results.length >= topK) break;
                    if (!results.some(existing => existing.id === chunk.id)) {
                        results.push(chunk);
                    }
                }
            }

            return results;
        }

        buildCoverageCandidates(primaryResults, scoredChunks, count) {
            if (count <= 0) return [];

            const topDocs = Array.from(new Set(primaryResults.map(chunk => chunk.filename)));
            if (topDocs.length === 0) {
                for (const chunk of scoredChunks.slice(0, 3)) {
                    topDocs.push(chunk.filename);
                }
            }

            const coverage = [];
            const perDoc = Math.max(1, Math.ceil(count / Math.max(1, topDocs.length)));

            for (const filename of topDocs) {
                const docChunks = this.allChunks
                    .filter(chunk => chunk.filename === filename)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                coverage.push(...this.pickEvenlyDistributed(docChunks, perDoc));
            }

            return coverage.slice(0, count);
        }

        findConceptLinkedChunks(primaryChunks, query, queryTokens, queryConcepts) {
            const linkedChunkIds = new Set();
            const linkedChunks = [];

            for (const chunk of primaryChunks) {
                const chunkConcepts = this.extractKeyConceptsFromChunk(chunk.text);
                for (const concept of chunkConcepts) {
                    const links = this.conceptIndex.get(concept) || [];
                    for (const link of links) {
                        if (linkedChunkIds.has(link.chunkId)) continue;
                        linkedChunkIds.add(link.chunkId);
                        const linkedChunk = this.chunkLookup.get(link.chunkId);
                        if (linkedChunk) {
                            const score = this.calculateRelevanceScore(linkedChunk, query, queryTokens, [], queryConcepts);
                            linkedChunks.push({ ...linkedChunk, score, isLinked: true });
                        }
                    }
                }
            }

            linkedChunks.sort((a, b) => b.score - a.score);
            return linkedChunks;
        }

        async retrieve(query, topK = null, options = {}) {
            if (this.allChunks.length === 0) return [];

            const intent = options.intent || this.detectQueryIntent(query);
            const corpusSize = this.allChunks.length;

            if (topK === null) {
                if (intent.broadCoverage) {
                    topK = corpusSize <= 60 ? 18 : corpusSize <= 200 ? 24 : Math.min(32, Math.ceil(corpusSize * 0.08));
                } else if (corpusSize <= 50) topK = 10;
                else if (corpusSize <= 200) topK = 15;
                else if (corpusSize <= 500) topK = 20;
                else topK = Math.min(25, Math.ceil(corpusSize * 0.05));
            }

            let queryTokens = this.tokenize(query);
            if (queryTokens.length === 0) {
                queryTokens = query.toLowerCase().split(/\s+/).filter(token => token.length > 1);
            }

            const queryEntities = this.extractEntities(query);
            const queryConcepts = this.extractConcepts(query);

            const scoredChunks = this.allChunks.map(chunk => {
                const score = this.calculateRelevanceScore(chunk, query, queryTokens, queryEntities, queryConcepts);
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let primaryResults = this.diversifyResults(scoredChunks, Math.ceil(topK * 0.7));

            const bestScore = primaryResults[0]?.score || 0;
            if (intent.broadCoverage || bestScore < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const coverage = this.buildCoverageCandidates(primaryResults, scoredChunks, Math.ceil(topK * 0.5));
                primaryResults = this.mergeUniqueChunks(primaryResults, coverage, topK);
            }

            const linkedChunks = this.findConceptLinkedChunks(primaryResults, query, queryTokens, queryConcepts)
                .slice(0, Math.max(2, Math.floor(topK * 0.25)));

            const merged = this.mergeUniqueChunks(primaryResults, linkedChunks, topK);

            if (merged.length === 0) {
                return this.allChunks.slice(0, topK);
            }

            return merged;
        }

        calculateLocalRelevanceScore(chunk, queryTokens, queryEntities, queryConcepts) {
            const chunkTokens = this.tokenize(chunk.text);
            const chunkTokenSet = new Set(chunkTokens);
            const chunkText = chunk.text.toLowerCase();
            let score = 0;

            if (queryTokens.length > 0) {
                const matches = queryTokens.filter(token => chunkTokenSet.has(token)).length;
                score += (matches / queryTokens.length) * 0.55;
            }

            if (queryEntities.length > 0) {
                const matches = queryEntities.filter(entity => chunkText.includes(entity.toLowerCase())).length;
                score += (matches / queryEntities.length) * 0.2;
            }

            if (queryConcepts.length > 0) {
                const matches = queryConcepts.filter(concept => chunkText.includes(concept)).length;
                score += (matches / queryConcepts.length) * 0.1;
            }

            if (queryTokens.length > 0) {
                const density = queryTokens.filter(token => chunkTokenSet.has(token)).length / Math.max(1, chunk.text.length / 120);
                score += Math.min(density * 0.06, 0.08);
            }

            return score;
        }

        retrieveFromChunks(query, chunks, topK = 10, options = {}) {
            if (!chunks || chunks.length === 0) return [];

            const intent = options.intent || this.detectQueryIntent(query);
            let queryTokens = this.tokenize(query);
            if (queryTokens.length === 0) {
                queryTokens = query.toLowerCase().split(/\s+/).filter(token => token.length > 1);
            }
            const queryEntities = this.extractEntities(query);
            const queryConcepts = this.extractConcepts(query);

            const scored = chunks.map(chunk => {
                const score = this.calculateLocalRelevanceScore(chunk, queryTokens, queryEntities, queryConcepts);
                return { ...chunk, score };
            }).sort((a, b) => b.score - a.score);

            let selected = scored.slice(0, Math.ceil(topK * 0.65));
            if (intent.broadCoverage || selected[0]?.score < RETRIEVAL_LOW_SCORE_THRESHOLD) {
                const orderedByIndex = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
                const coverage = this.pickEvenlyDistributed(orderedByIndex, Math.ceil(topK * 0.5));
                selected = this.mergeUniqueChunks(selected, coverage, topK);
            }

            return selected.slice(0, topK);
        }

        extractBestSentence(text, queryTokens) {
            const sentences = text
                .split(/(?<=[.!?])\s+/)
                .map(sentence => sentence.trim())
                .filter(Boolean);

            if (sentences.length === 0) return text.slice(0, 180);
            if (queryTokens.length === 0) return sentences[0].slice(0, 220);

            let bestSentence = sentences[0];
            let bestScore = -1;

            for (const sentence of sentences) {
                const lower = sentence.toLowerCase();
                const score = queryTokens.reduce((acc, token) => acc + (lower.includes(token) ? 1 : 0), 0);
                if (score > bestScore) {
                    bestScore = score;
                    bestSentence = sentence;
                }
            }

            return bestSentence.slice(0, 260);
        }

        buildAttachmentDigest(query, chunks, maxEntries = 14) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);

            const ranked = chunks.map(chunk => ({
                ...chunk,
                score: this.calculateLocalRelevanceScore(chunk, queryTokens, [], [])
            })).sort((a, b) => b.score - a.score);

            const top = ranked.slice(0, Math.ceil(maxEntries * 0.65));
            const ordered = chunks.slice().sort((a, b) => (a.index || 0) - (b.index || 0));
            const coverage = this.pickEvenlyDistributed(ordered, Math.ceil(maxEntries * 0.4));
            const merged = this.mergeUniqueChunks(top, coverage, maxEntries);

            return merged.map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        buildCorpusDigest(query, chunks, maxEntries = 16) {
            if (!chunks || chunks.length === 0) return '';
            const queryTokens = this.tokenize(query);
            return chunks.slice(0, maxEntries).map((chunk, idx) => {
                const pagePart = chunk.page ? `, page ${chunk.page}` : '';
                const sentence = this.extractBestSentence(chunk.text, queryTokens);
                return `${idx + 1}. [${chunk.filename}${pagePart}] ${sentence}`;
            }).join('\n');
        }

        getTopConnectedConcepts(limit = 10) {
            const conceptDocCounts = new Map();

            for (const [concept, links] of this.conceptIndex) {
                const uniqueDocs = new Set(links.map(link => link.filename));
                if (uniqueDocs.size > 1) {
                    conceptDocCounts.set(concept, uniqueDocs.size);
                }
            }

            return Array.from(conceptDocCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([concept, docCount]) => ({ concept, docCount }));
        }
    }

    class CognitiveSynthesizer {
        constructor() {
            this.apiKey = localStorage.getItem('openai_api_key') || '';
            this.model = localStorage.getItem('openai_model') || 'gpt-4.1';
            this.conversationHistory = this.loadChatHistory();
            this.workingMemory = this.loadWorkingMemory();
        }

        loadChatHistory() {
            const saved = localStorage.getItem('chat_history');
            try {
                return saved ? JSON.parse(saved) : [];
            } catch {
                return [];
            }
        }

        loadWorkingMemory() {
            const saved = localStorage.getItem('working_memory');
            try {
                return saved ? JSON.parse(saved) : [];
            } catch {
                return [];
            }
        }

        saveChatHistory() {
            const trimmed = this.conversationHistory.slice(-40);
            localStorage.setItem('chat_history', JSON.stringify(trimmed));
        }

        saveWorkingMemory() {
            const trimmed = this.workingMemory.slice(-18);
            localStorage.setItem('working_memory', JSON.stringify(trimmed));
        }

        clearHistory() {
            this.conversationHistory = [];
            this.workingMemory = [];
            localStorage.removeItem('chat_history');
            localStorage.removeItem('working_memory');
        }

        setApiKey(key) {
            this.apiKey = key;
            localStorage.setItem('openai_api_key', key);
        }

        setModel(model) {
            this.model = model;
            localStorage.setItem('openai_model', model);
        }

        buildInstructionProfile(query) {
            const lower = query.toLowerCase();
            const wordLimitMatch = query.match(/(\d{2,4})\s*words?/i);

            return {
                requestedFormat: /\btable\b/.test(lower) ? 'table' :
                    /\b(json)\b/.test(lower) ? 'json' :
                    /\b(bullet|bulleted|list|points)\b/.test(lower) ? 'bullet list' :
                    'structured prose',
                wantsSteps: /\b(step[- ]by[- ]step|steps)\b/.test(lower),
                wordLimit: wordLimitMatch ? parseInt(wordLimitMatch[1], 10) : null,
                strictSourceOnly: /\b(only use|based only|strictly from|from provided|from uploaded)\b/.test(lower),
                userIntent: lower
            };
        }

        getWorkingMemorySummary() {
            if (!this.workingMemory.length) return 'No prior working memory yet.';
            return this.workingMemory
                .slice(-6)
                .map((item, idx) => `${idx + 1}. Q: ${item.query}\n   Gist: ${item.gist}`)
                .join('\n');
        }

        rememberTurn(query, response) {
            const cleaned = response
                .replace(/\[Source:[^\]]+\]/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            const gist = cleaned.slice(0, 380);
            this.workingMemory.push({
                timestamp: new Date().toISOString(),
                query: query.slice(0, 160),
                gist
            });
            this.saveWorkingMemory();
        }

        getSystemPrompt(context, corpusStats = {}, instructionProfile = {}, workingMemorySummary = '') {
            const numDocs = corpusStats.numDocs || 0;
            const numChunks = corpusStats.numChunks || 0;
            const formatReq = instructionProfile.requestedFormat || 'structured prose';
            const stepReq = instructionProfile.wantsSteps ? 'Yes' : 'No';
            const wordLimit = instructionProfile.wordLimit ? `${instructionProfile.wordLimit} words` : 'No explicit limit';
            const sourceOnly = instructionProfile.strictSourceOnly ? 'Yes - strictly source-grounded.' : 'Ground all factual claims in provided sources.';

            return `You are a COGNITIVE SYNTHESIS ENGINE.

You are given:
1) Retrieved evidence chunks from uploaded documents.
2) Document-memory summaries generated from full uploaded files (outline, key concepts, salient sentences).
3) Optional temporary attachment memory for one-time analysis.

IMPORTANT ACCESS RULE:
- If context is provided, NEVER claim you cannot access the documents.
- Never mention "training cutoff" unless user explicitly asks about model knowledge limits.
- If evidence is missing, say: "Based on the available documents, I cannot fully confirm..."

Human-like synthesis mode (inspired by brain-mimicking LLM research):
- Working-memory loop: obey the current instruction contract precisely.
- Semantic-memory loop: use document-memory summaries to maintain long-range context.
- Retrieval loop: verify claims against cited chunks before finalizing.

Corpus snapshot:
- Documents: ${numDocs}
- Chunks: ${numChunks}

Instruction contract:
- Output format: ${formatReq}
- Step-by-step required: ${stepReq}
- Length target: ${wordLimit}
- Source policy: ${sourceOnly}

MANDATORY CITATION FORMAT:
[Source: filename, page X, "brief relevant quote"]

CONTEXT:
${context}

WORKING MEMORY FROM PRIOR TURNS:
${workingMemorySummary}
`;
        }

        formatDocumentMemories(documentMemories = []) {
            if (!documentMemories.length) return '';
            const blocks = documentMemories.slice(0, 10).map((doc, idx) => {
                const memory = doc.memory || {};
                const concepts = (memory.keyConcepts || []).slice(0, 10).join(', ') || 'N/A';
                const outline = (memory.outline || []).slice(0, 8).join(' | ') || 'N/A';
                const synopsis = memory.synopsis || (memory.salientSentences || []).slice(0, 3).join(' ');
                return `### Document Memory ${idx + 1}: ${doc.filename}
- Word count: ${memory.wordCount || 'N/A'}
- Reading time (min): ${memory.readingTimeMinutes || 'N/A'}
- Outline: ${outline}
- Key concepts: ${concepts}
- Synopsis: ${synopsis}`;
            });

            return `## DOCUMENT MEMORY BLOCKS (generated from full files)\n${blocks.join('\n\n')}`;
        }

        formatContext(chunks, maxChars = MAX_CONTEXT_CHARS) {
            if (!chunks || chunks.length === 0) {
                return { contextText: 'No relevant documents found in the corpus.', included: 0, omitted: 0 };
            }

            let totalChars = 0;
            const includedBlocks = [];
            let omitted = 0;

            for (const chunk of chunks) {
                const sectionLabel = chunk.section ? `, Section: ${chunk.section}` : '';
                const pageLabel = chunk.page ? `Page ${chunk.page}` : 'Page N/A';
                const block = `### Evidence: ${chunk.filename} (${pageLabel}${sectionLabel})
${chunk.text}`;

                if (totalChars + block.length > maxChars) {
                    omitted++;
                    continue;
                }

                includedBlocks.push(block);
                totalChars += block.length;
            }

            if (includedBlocks.length === 0 && chunks.length > 0) {
                const fallback = chunks[0];
                includedBlocks.push(`### Evidence: ${fallback.filename} (Page ${fallback.page || 'N/A'})
${fallback.text.slice(0, Math.min(2500, fallback.text.length))}`);
                omitted = Math.max(0, chunks.length - 1);
            }

            return {
                contextText: includedBlocks.join('\n\n---\n\n'),
                included: includedBlocks.length,
                omitted
            };
        }

        looksLikeContextRefusal(responseText) {
            if (!responseText) return false;
            return REFUSAL_PATTERNS.some(pattern => pattern.test(responseText));
        }

        buildUserPrompt(query, instructionProfile) {
            const lines = [
                `User question:\n${query}`,
                '',
                'Please obey this response contract:',
                `- Format: ${instructionProfile.requestedFormat}`,
                `- Step-by-step: ${instructionProfile.wantsSteps ? 'yes' : 'no'}`,
                `- Word limit: ${instructionProfile.wordLimit ? instructionProfile.wordLimit : 'no strict limit'}`,
                `- Source-only strictness: ${instructionProfile.strictSourceOnly ? 'strict' : 'grounded, with clear uncertainty if missing'}`
            ];
            return lines.join('\n');
        }

        async callCompletion(messages, overrides = {}) {
            const payload = {
                model: this.model,
                messages,
                temperature: 0.25,
                max_tokens: 2500,
                top_p: 0.9,
                ...overrides
            };

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let detail = 'API request failed';
                try {
                    const error = await response.json();
                    detail = error.error?.message || detail;
                } catch {
                    detail = `${detail} (HTTP ${response.status})`;
                }
                throw new Error(detail);
            }

            const data = await response.json();
            return data.choices?.[0]?.message?.content || '';
        }

        async synthesize(query, relevantChunks, attachmentContext = null, corpusStats = {}) {
            if (!this.apiKey) {
                throw new Error('API key not configured. Please set your OpenAI API key in the Admin Panel.');
            }

            const instructionProfile = this.buildInstructionProfile(query);
            const workingMemorySummary = this.getWorkingMemorySummary();

            const contextSections = [];
            if (attachmentContext?.memory) {
                const m = attachmentContext.memory;
                contextSections.push(`## ATTACHMENT MEMORY (FULL FILE)
File: ${attachmentContext.name}
Word count: ${m.wordCount || 'N/A'}
Outline: ${(m.outline || []).slice(0, 10).join(' | ') || 'N/A'}
Key concepts: ${(m.keyConcepts || []).slice(0, 12).join(', ') || 'N/A'}
Synopsis: ${m.synopsis || (m.salientSentences || []).slice(0, 4).join(' ')}`);
            }

            if (attachmentContext?.digest) {
                contextSections.push(`## ATTACHMENT WIDE-COVERAGE DIGEST
${attachmentContext.digest}`);
            }

            if (corpusStats.documentMemories && corpusStats.documentMemories.length > 0) {
                contextSections.push(this.formatDocumentMemories(corpusStats.documentMemories));
            }

            if (corpusStats.connectedConcepts && corpusStats.connectedConcepts.length > 0) {
                const conceptSummary = corpusStats.connectedConcepts
                    .slice(0, 10)
                    .map(item => `- "${item.concept}" appears in ${item.docCount} documents`)
                    .join('\n');
                contextSections.push(`## CROSS-DOCUMENT CONCEPT BRIDGES\n${conceptSummary}`);
            }

            if (corpusStats.corpusDigest) {
                contextSections.push(`## CORPUS DIGEST\n${corpusStats.corpusDigest}`);
            }

            const formattedContext = this.formatContext(relevantChunks, MAX_CONTEXT_CHARS);
            contextSections.push(`## RETRIEVED EVIDENCE CHUNKS
Included chunks: ${formattedContext.included}
Omitted due to context budget: ${formattedContext.omitted}

${formattedContext.contextText}`);

            if (attachmentContext?.chunks && attachmentContext.chunks.length > 0) {
                const attachmentEvidence = this.formatContext(attachmentContext.chunks, Math.floor(MAX_CONTEXT_CHARS * 0.35));
                contextSections.push(`## ATTACHMENT QUERY-SPECIFIC EVIDENCE
Included chunks: ${attachmentEvidence.included}
Omitted due to context budget: ${attachmentEvidence.omitted}

${attachmentEvidence.contextText}`);
            }

            const context = contextSections.join('\n\n');
            const systemPrompt = this.getSystemPrompt(context, corpusStats, instructionProfile, workingMemorySummary);
            const userPrompt = this.buildUserPrompt(query, instructionProfile);

            const messages = [
                { role: 'system', content: systemPrompt },
                ...this.conversationHistory.slice(-10),
                { role: 'user', content: userPrompt }
            ];

            let assistantMessage = await this.callCompletion(messages);

            if ((relevantChunks.length > 0 || (attachmentContext?.chunks?.length || 0) > 0) && this.looksLikeContextRefusal(assistantMessage)) {
                const retryMessages = [
                    ...messages,
                    { role: 'assistant', content: assistantMessage },
                    {
                        role: 'user',
                        content: 'You incorrectly stated you cannot access documents. Re-answer using the provided evidence and document-memory blocks above. Do not mention training cutoff unless explicitly asked. Keep strict citations.'
                    }
                ];
                assistantMessage = await this.callCompletion(retryMessages, { temperature: 0.15 });
            }

            this.conversationHistory.push(
                { role: 'user', content: query },
                { role: 'assistant', content: assistantMessage }
            );
            this.saveChatHistory();
            this.rememberTurn(query, assistantMessage);

            let sources = [...(relevantChunks || [])];
            if (attachmentContext?.chunks) {
                const attachmentSources = attachmentContext.chunks.map(chunk => ({
                    ...chunk,
                    source: attachmentContext.name,
                    filename: attachmentContext.name,
                    isTemporary: true
                }));
                sources = [...attachmentSources, ...sources];
            }

            return {
                response: assistantMessage,
                sources
            };
        }
    }

    class UIController {
        constructor(db, processor, retriever, synthesizer) {
            this.db = db;
            this.processor = processor;
            this.retriever = retriever;
            this.synthesizer = synthesizer;
            this.currentAttachment = null;
            this.defaultSynthesisText = 'Building mental model and synthesizing across documents...';

            this.initializeElements();
            this.bindEvents();
            this.loadCorpus();
            this.restoreChatHistory();
        }

        initializeElements() {
            this.chatMessages = document.getElementById('chatMessages');
            this.chatInput = document.getElementById('chatInput');
            this.sendBtn = document.getElementById('sendBtn');
            this.synthesisIndicator = document.getElementById('synthesisIndicator');
            this.synthesisIndicatorText = document.getElementById('synthesisIndicatorText');
            this.clearChatBtn = document.getElementById('clearChatBtn');

            this.chatAttachBtn = document.getElementById('chatAttachBtn');
            this.chatFileInput = document.getElementById('chatFileInput');
            this.attachmentPreview = document.getElementById('attachmentPreview');
            this.attachmentName = document.getElementById('attachmentName');
            this.attachmentMeta = document.getElementById('attachmentMeta');
            this.attachmentRemove = document.getElementById('attachmentRemove');

            this.corpusList = document.getElementById('corpusList');
            this.docCount = document.getElementById('docCount');
            this.chunkCount = document.getElementById('chunkCount');

            this.adminPanel = document.getElementById('adminPanel');
            this.adminClose = document.getElementById('adminClose');
            this.openAdminBtn = document.getElementById('openAdminBtn');
            this.uploadZone = document.getElementById('uploadZone');
            this.fileInput = document.getElementById('fileInput');
            this.apiKeyInput = document.getElementById('apiKeyInput');
            this.saveApiKeyBtn = document.getElementById('saveApiKey');
            this.modelSelect = document.getElementById('modelSelect');
            this.processingStatus = document.getElementById('processingStatus');
            this.processingText = document.getElementById('processingText');
            this.processingBarFill = document.getElementById('processingBarFill');
            this.rebuildIndexBtn = document.getElementById('rebuildIndex');
            this.clearCorpusBtn = document.getElementById('clearCorpus');
            this.clearChatAdminBtn = document.getElementById('clearChatAdmin');

            this.citationModal = document.getElementById('citationModal');
            this.citationClose = document.getElementById('citationClose');
            this.citationSource = document.getElementById('citationSource');
            this.citationText = document.getElementById('citationText');

            this.toastContainer = document.getElementById('toastContainer');

            this.apiKeyInput.value = localStorage.getItem('openai_api_key') || '';
            this.modelSelect.value = localStorage.getItem('openai_model') || 'gpt-4.1';
        }

        bindEvents() {
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            this.chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });

            this.clearChatBtn.addEventListener('click', () => this.clearChatHistory());
            this.chatAttachBtn.addEventListener('click', () => this.chatFileInput.click());
            this.chatFileInput.addEventListener('change', (e) => this.handleChatAttachment(e));
            this.attachmentRemove.addEventListener('click', () => this.removeChatAttachment());

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyA') {
                    e.preventDefault();
                    this.toggleAdminPanel();
                }
            });

            this.openAdminBtn.addEventListener('click', () => this.toggleAdminPanel(true));
            this.adminClose.addEventListener('click', () => this.toggleAdminPanel(false));
            this.adminPanel.addEventListener('click', (e) => {
                if (e.target === this.adminPanel) {
                    this.toggleAdminPanel(false);
                }
            });

            this.uploadZone.addEventListener('click', () => this.fileInput.click());
            this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

            this.uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                this.uploadZone.classList.add('dragover');
            });

            this.uploadZone.addEventListener('dragleave', () => {
                this.uploadZone.classList.remove('dragover');
            });

            this.uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                this.uploadZone.classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            });

            this.saveApiKeyBtn.addEventListener('click', () => {
                const key = this.apiKeyInput.value.trim();
                if (key) {
                    this.synthesizer.setApiKey(key);
                    this.showToast('API key saved successfully', 'success');
                } else {
                    this.showToast('Please enter a valid API key', 'error');
                }
            });

            this.modelSelect.addEventListener('change', () => {
                this.synthesizer.setModel(this.modelSelect.value);
                this.showToast(`Model changed to ${this.modelSelect.value}`, 'success');
            });

            this.rebuildIndexBtn.addEventListener('click', () => this.rebuildIndex());
            this.clearCorpusBtn.addEventListener('click', () => this.clearCorpus());
            this.clearChatAdminBtn.addEventListener('click', () => this.clearChatHistory());

            this.citationClose.addEventListener('click', () => this.citationModal.classList.remove('active'));
            this.citationModal.addEventListener('click', (e) => {
                if (e.target === this.citationModal) {
                    this.citationModal.classList.remove('active');
                }
            });
        }

        toggleAdminPanel(show = null) {
            if (show === null) {
                this.adminPanel.classList.toggle('active');
            } else {
                this.adminPanel.classList.toggle('active', show);
            }
        }

        async loadCorpus() {
            const documents = await this.db.getAllDocuments();
            this.retriever.updateCorpus(documents);
            this.updateCorpusUI(documents);
        }

        updateCorpusUI(documents) {
            const totalChunks = documents.reduce((sum, doc) => sum + (doc.chunks?.length || 0), 0);

            this.docCount.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                </svg>
                ${documents.length} documents
            `;

            this.chunkCount.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"/>
                    <rect x="14" y="3" width="7" height="7"/>
                    <rect x="3" y="14" width="7" height="7"/>
                    <rect x="14" y="14" width="7" height="7"/>
                </svg>
                ${totalChunks} knowledge chunks
            `;

            if (documents.length === 0) {
                this.corpusList.innerHTML = `
                    <div class="corpus-empty">
                        No documents uploaded yet.<br>
                        Press <kbd>Ctrl+Shift+A</kbd> to open Admin Panel.
                    </div>
                `;
                return;
            }

            this.corpusList.innerHTML = documents.map(doc => `
                <div class="corpus-item" data-id="${doc.id}">
                    <div class="corpus-item-info">
                        <div class="corpus-item-name" title="${this.escapeHtml(doc.filename)}">${this.escapeHtml(doc.filename)}</div>
                        <div class="corpus-item-meta">
                            ${(doc.size / 1024).toFixed(1)} KB • ${doc.chunks?.length || 0} chunks
                        </div>
                    </div>
                    <button class="corpus-item-delete" onclick="app.deleteDocument(${doc.id})">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            `).join('');
        }

        async handleFiles(files) {
            const fileArray = Array.from(files);
            if (fileArray.length === 0) return;

            this.processingStatus.classList.add('active');

            let processed = 0;
            const total = fileArray.length;

            for (const file of fileArray) {
                this.processingText.textContent = `Processing ${file.name}...`;
                this.processingBarFill.style.width = `${(processed / total) * 100}%`;

                try {
                    const document = await this.processor.processFile(file);
                    await this.db.addDocument(document);
                    processed++;
                    this.showToast(`Processed: ${file.name}`, 'success');
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    this.showToast(`Failed: ${file.name} (${error.message})`, 'error');
                }
            }

            this.processingBarFill.style.width = '100%';
            this.processingText.textContent = `Completed! Processed ${processed} of ${total} files.`;

            setTimeout(() => {
                this.processingStatus.classList.remove('active');
                this.processingBarFill.style.width = '0%';
            }, 2000);

            await this.loadCorpus();
            this.fileInput.value = '';
        }

        async handleChatAttachment(event) {
            const file = event.target.files[0];
            if (!file) return;

            const ext = (file.name.split('.').pop() || '').toLowerCase();
            const supportedTypes = ['pdf', 'docx', 'txt', 'csv', 'xlsx', 'md'];
            const legacyTypes = ['doc', 'xls'];

            if (legacyTypes.includes(ext)) {
                this.showToast(`.${ext} is not supported in-browser. Convert to ${ext === 'doc' ? 'DOCX' : 'XLSX'} first.`, 'warning');
                this.chatFileInput.value = '';
                return;
            }

            if (!supportedTypes.includes(ext)) {
                this.showToast('Unsupported file type. Supported: PDF, DOCX, TXT, CSV, XLSX, MD', 'error');
                this.chatFileInput.value = '';
                return;
            }

            try {
                this.showToast('Processing attachment...', 'info');
                const result = await this.processor.processFile(file);
                const wordCount = result.memory?.wordCount || result.fullText.split(/\s+/).filter(Boolean).length;

                this.currentAttachment = {
                    name: file.name,
                    chunks: result.chunks,
                    memory: result.memory,
                    type: ext,
                    wordCount
                };

                this.attachmentName.textContent = file.name;
                this.attachmentMeta.textContent = `${wordCount.toLocaleString()} words - Temporary analysis (not saved to corpus)`;
                this.attachmentPreview.classList.add('active');

                this.showToast(`Attached: ${file.name}`, 'success');
            } catch (error) {
                console.error('Attachment processing error:', error);
                this.showToast(`Failed to process attachment: ${error.message}`, 'error');
            }

            this.chatFileInput.value = '';
        }

        removeChatAttachment() {
            this.currentAttachment = null;
            this.attachmentPreview.classList.remove('active');
            this.chatFileInput.value = '';
        }

        async deleteDocument(id) {
            if (confirm('Are you sure you want to delete this document?')) {
                await this.db.deleteDocument(id);
                await this.loadCorpus();
                this.showToast('Document deleted', 'success');
            }
        }

        async rebuildIndex() {
            this.showToast('Rebuilding index...', 'info');
            await this.loadCorpus();
            this.showToast('Index rebuilt successfully', 'success');
        }

        async clearCorpus() {
            if (confirm('Are you sure you want to delete ALL documents? This cannot be undone.')) {
                await this.db.clearAll();
                await this.loadCorpus();
                this.showToast('All documents cleared', 'success');
            }
        }

        clearChatHistory() {
            if (confirm('Clear all chat history?')) {
                this.synthesizer.clearHistory();
                this.chatMessages.innerHTML = `
                    <div class="message system">
                        Chat history cleared. Upload documents via the Admin Panel (Ctrl+Shift+A), then ask questions.
                        You can also attach files directly for one-time analysis.
                    </div>
                `;
                this.showToast('Chat history cleared', 'success');
            }
        }

        restoreChatHistory() {
            const history = this.synthesizer.conversationHistory;
            if (history.length === 0) return;
            for (const msg of history) {
                this.addMessage(msg.content, msg.role);
            }
        }

        setSynthesisMessage(isBroadCoverage) {
            this.synthesisIndicatorText.textContent = isBroadCoverage
                ? 'Running deep coverage synthesis across long context...'
                : this.defaultSynthesisText;
        }

        async sendMessage() {
            const query = this.chatInput.value.trim();
            if (!query) return;

            if (!this.synthesizer.apiKey) {
                this.showToast('Please configure your OpenAI API key in the Admin Panel', 'error');
                this.toggleAdminPanel(true);
                return;
            }

            const hasCorpus = this.retriever.allChunks.length > 0;
            const hasAttachment = this.currentAttachment !== null;

            if (!hasCorpus && !hasAttachment) {
                this.showToast('Please upload documents via Admin Panel or attach a file for analysis', 'warning');
                return;
            }

            let displayMessage = this.escapeHtml(query);
            if (hasAttachment) {
                displayMessage = `<div class="attachment-indicator">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                    </svg>
                    <span>${this.escapeHtml(this.currentAttachment.name)}</span>
                </div>
                ${displayMessage}`;
            }

            this.addMessage(displayMessage, 'user');
            this.chatInput.value = '';
            this.sendBtn.disabled = true;

            const intent = this.retriever.detectQueryIntent(query);
            this.setSynthesisMessage(intent.broadCoverage);
            this.synthesisIndicator.classList.add('active');

            try {
                let relevantChunks = hasCorpus
                    ? await this.retriever.retrieve(query, null, { intent })
                    : [];

                let attachmentContext = null;
                if (hasAttachment) {
                    const broadCoverage = intent.broadCoverage || (this.currentAttachment.wordCount >= LONG_DOC_WORD_THRESHOLD);
                    const attachmentChunks = this.retriever.retrieveFromChunks(
                        query,
                        this.currentAttachment.chunks,
                        broadCoverage ? 20 : 12,
                        { intent: { ...intent, broadCoverage } }
                    );

                    attachmentContext = {
                        name: this.currentAttachment.name,
                        chunks: attachmentChunks,
                        memory: this.currentAttachment.memory,
                        digest: broadCoverage
                            ? this.retriever.buildAttachmentDigest(query, this.currentAttachment.chunks, 16)
                            : '',
                        isTemporary: true
                    };
                }

                const relevantFilenames = new Set(relevantChunks.map(chunk => chunk.filename));
                const documentMemories = this.retriever.documents
                    .filter(doc => relevantFilenames.has(doc.filename))
                    .slice(0, 10)
                    .map(doc => ({
                        filename: doc.filename,
                        memory: doc.memory
                    }));

                const corpusStats = {
                    numDocs: this.retriever.documents.length,
                    numChunks: this.retriever.allChunks.length,
                    connectedConcepts: this.retriever.getTopConnectedConcepts(10),
                    documentMemories,
                    corpusDigest: intent.broadCoverage
                        ? this.retriever.buildCorpusDigest(query, relevantChunks, 16)
                        : ''
                };

                const result = await this.synthesizer.synthesize(query, relevantChunks, attachmentContext, corpusStats);
                this.addMessage(result.response, 'assistant', result.sources);
            } catch (error) {
                console.error('Error:', error);
                this.addMessage(
                    `I encountered an error: ${this.escapeHtml(error.message)}. Please check your API key/model and try again.`,
                    'system'
                );
            } finally {
                this.sendBtn.disabled = false;
                this.synthesisIndicator.classList.remove('active');
                this.setSynthesisMessage(false);
                this.removeChatAttachment();
            }
        }

        escapeHtml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        renderMarkdownLite(escapedText) {
            let text = escapedText
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');

            const lines = text.split('\n');
            let html = '';
            let inUl = false;
            let inOl = false;

            const closeLists = () => {
                if (inUl) { html += '</ul>'; inUl = false; }
                if (inOl) { html += '</ol>'; inOl = false; }
            };

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) {
                    closeLists();
                    continue;
                }

                const ulMatch = line.match(/^- (.+)$/);
                const olMatch = line.match(/^\d+\. (.+)$/);

                if (ulMatch) {
                    if (!inUl) {
                        closeLists();
                        html += '<ul>';
                        inUl = true;
                    }
                    html += `<li>${ulMatch[1]}</li>`;
                    continue;
                }

                if (olMatch) {
                    if (!inOl) {
                        closeLists();
                        html += '<ol>';
                        inOl = true;
                    }
                    html += `<li>${olMatch[1]}</li>`;
                    continue;
                }

                closeLists();
                html += `<p>${line}</p>`;
            }

            closeLists();
            return html || '<p></p>';
        }

        formatCitations(content, sources) {
            const citationRegex = /\[Source:\s*([^,\]]+),\s*(?:page\s*)?([^,\]]+),\s*"([^"]+)"\]/gi;
            const citationTokens = [];
            let tokenized = content.replace(citationRegex, (match, filename, page, quote) => {
                const token = `__CITATION_${citationTokens.length}__`;
                citationTokens.push({
                    token,
                    filename: String(filename || '').trim(),
                    page: String(page || '').trim(),
                    quote: String(quote || '').trim()
                });
                return token;
            });

            tokenized = this.escapeHtml(tokenized);
            let rendered = this.renderMarkdownLite(tokenized);

            for (const citation of citationTokens) {
                const sourceInfo = `${citation.filename}, Page ${citation.page}`;
                const html = `<span class="citation" data-source="${this.escapeHtml(sourceInfo)}" data-text="${this.escapeHtml(citation.quote)}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                    </svg>
                    ${this.escapeHtml(citation.filename).slice(0, 20)}...
                </span>`;
                rendered = rendered.replace(citation.token, html);
            }

            return rendered;
        }

        addMessage(content, role, sources = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            let processedContent = content;
            if (role === 'assistant') {
                processedContent = this.formatCitations(content, sources);
            } else if (role === 'system') {
                processedContent = `<p>${this.escapeHtml(content)}</p>`;
            }

            messageDiv.innerHTML = processedContent;
            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;

            if (role === 'assistant') {
                messageDiv.querySelectorAll('.citation').forEach(citation => {
                    citation.addEventListener('click', () => {
                        const source = citation.dataset.source;
                        const text = citation.dataset.text;
                        this.showCitation(source, text);
                    });
                });
            }
        }

        showCitation(source, text) {
            this.citationSource.textContent = source;
            this.citationText.textContent = text;
            this.citationModal.classList.add('active');
        }

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            const safe = this.escapeHtml(message);
            toast.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${type === 'success' ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22,4 12,14.01 9,11.01"/>' :
                      type === 'error' ? '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>' :
                      type === 'warning' ? '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>' :
                      '<circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>'}
                </svg>
                <span>${safe}</span>
            `;

            this.toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }
    }

    let app;

    async function initializeApp() {
        try {
            const db = new DocumentDatabase();
            await db.init();

            const processor = new DocumentProcessor();
            const retriever = new CognitiveRetriever();
            const synthesizer = new CognitiveSynthesizer();

            app = new UIController(db, processor, retriever, synthesizer);
            window.app = app;

            console.log('Cognitive Synthesis Engine initialized successfully');
        } catch (error) {
            console.error('Failed to initialize application:', error);
            alert('Failed to initialize the application. Please refresh the page.');
        }
    }

    document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
